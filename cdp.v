// this file generated by gen_protocol.vsh

module cdv

import x.json2 as json

pub const map_method = {
	'Accessibility.disable':                             MessageType.command
	'Accessibility.enable':                              MessageType.command
	'Accessibility.getPartialAXTree':                    MessageType.command
	'Accessibility.getFullAXTree':                       MessageType.command
	'Accessibility.getRootAXNode':                       MessageType.command
	'Accessibility.getAXNodeAndAncestors':               MessageType.command
	'Accessibility.getChildAXNodes':                     MessageType.command
	'Accessibility.queryAXTree':                         MessageType.command
	'Accessibility.loadComplete':                        MessageType.event
	'Accessibility.nodesUpdated':                        MessageType.event
	'Animation.disable':                                 MessageType.command
	'Animation.enable':                                  MessageType.command
	'Animation.getCurrentTime':                          MessageType.command
	'Animation.getPlaybackRate':                         MessageType.command
	'Animation.releaseAnimations':                       MessageType.command
	'Animation.resolveAnimation':                        MessageType.command
	'Animation.seekAnimations':                          MessageType.command
	'Animation.setPaused':                               MessageType.command
	'Animation.setPlaybackRate':                         MessageType.command
	'Animation.setTiming':                               MessageType.command
	'Animation.animationCanceled':                       MessageType.event
	'Animation.animationCreated':                        MessageType.event
	'Animation.animationStarted':                        MessageType.event
	'Animation.animationUpdated':                        MessageType.event
	'Audits.getEncodedResponse':                         MessageType.command
	'Audits.disable':                                    MessageType.command
	'Audits.enable':                                     MessageType.command
	'Audits.checkContrast':                              MessageType.command
	'Audits.checkFormsIssues':                           MessageType.command
	'Audits.issueAdded':                                 MessageType.event
	'Extensions.loadUnpacked':                           MessageType.command
	'Extensions.getStorageItems':                        MessageType.command
	'Extensions.removeStorageItems':                     MessageType.command
	'Extensions.clearStorageItems':                      MessageType.command
	'Extensions.setStorageItems':                        MessageType.command
	'Autofill.trigger':                                  MessageType.command
	'Autofill.setAddresses':                             MessageType.command
	'Autofill.disable':                                  MessageType.command
	'Autofill.enable':                                   MessageType.command
	'Autofill.addressFormFilled':                        MessageType.event
	'BackgroundService.startObserving':                  MessageType.command
	'BackgroundService.stopObserving':                   MessageType.command
	'BackgroundService.setRecording':                    MessageType.command
	'BackgroundService.clearEvents':                     MessageType.command
	'BackgroundService.recordingStateChanged':           MessageType.event
	'BackgroundService.backgroundServiceEventReceived':  MessageType.event
	'Browser.setPermission':                             MessageType.command
	'Browser.grantPermissions':                          MessageType.command
	'Browser.resetPermissions':                          MessageType.command
	'Browser.setDownloadBehavior':                       MessageType.command
	'Browser.cancelDownload':                            MessageType.command
	'Browser.close':                                     MessageType.command
	'Browser.crash':                                     MessageType.command
	'Browser.crashGpuProcess':                           MessageType.command
	'Browser.getVersion':                                MessageType.command
	'Browser.getBrowserCommandLine':                     MessageType.command
	'Browser.getHistograms':                             MessageType.command
	'Browser.getHistogram':                              MessageType.command
	'Browser.getWindowBounds':                           MessageType.command
	'Browser.getWindowForTarget':                        MessageType.command
	'Browser.setWindowBounds':                           MessageType.command
	'Browser.setDockTile':                               MessageType.command
	'Browser.executeBrowserCommand':                     MessageType.command
	'Browser.addPrivacySandboxEnrollmentOverride':       MessageType.command
	'Browser.downloadWillBegin':                         MessageType.event
	'Browser.downloadProgress':                          MessageType.event
	'CSS.addRule':                                       MessageType.command
	'CSS.collectClassNames':                             MessageType.command
	'CSS.createStyleSheet':                              MessageType.command
	'CSS.disable':                                       MessageType.command
	'CSS.enable':                                        MessageType.command
	'CSS.forcePseudoState':                              MessageType.command
	'CSS.forceStartingStyle':                            MessageType.command
	'CSS.getBackgroundColors':                           MessageType.command
	'CSS.getComputedStyleForNode':                       MessageType.command
	'CSS.resolveValues':                                 MessageType.command
	'CSS.getInlineStylesForNode':                        MessageType.command
	'CSS.getAnimatedStylesForNode':                      MessageType.command
	'CSS.getMatchedStylesForNode':                       MessageType.command
	'CSS.getMediaQueries':                               MessageType.command
	'CSS.getPlatformFontsForNode':                       MessageType.command
	'CSS.getStyleSheetText':                             MessageType.command
	'CSS.getLayersForNode':                              MessageType.command
	'CSS.getLocationForSelector':                        MessageType.command
	'CSS.trackComputedStyleUpdatesForNode':              MessageType.command
	'CSS.trackComputedStyleUpdates':                     MessageType.command
	'CSS.takeComputedStyleUpdates':                      MessageType.command
	'CSS.setEffectivePropertyValueForNode':              MessageType.command
	'CSS.setPropertyRulePropertyName':                   MessageType.command
	'CSS.setKeyframeKey':                                MessageType.command
	'CSS.setMediaText':                                  MessageType.command
	'CSS.setContainerQueryText':                         MessageType.command
	'CSS.setSupportsText':                               MessageType.command
	'CSS.setScopeText':                                  MessageType.command
	'CSS.setRuleSelector':                               MessageType.command
	'CSS.setStyleSheetText':                             MessageType.command
	'CSS.setStyleTexts':                                 MessageType.command
	'CSS.startRuleUsageTracking':                        MessageType.command
	'CSS.stopRuleUsageTracking':                         MessageType.command
	'CSS.takeCoverageDelta':                             MessageType.command
	'CSS.setLocalFontsEnabled':                          MessageType.command
	'CSS.fontsUpdated':                                  MessageType.event
	'CSS.mediaQueryResultChanged':                       MessageType.event
	'CSS.styleSheetAdded':                               MessageType.event
	'CSS.styleSheetChanged':                             MessageType.event
	'CSS.styleSheetRemoved':                             MessageType.event
	'CSS.computedStyleUpdated':                          MessageType.event
	'CacheStorage.deleteCache':                          MessageType.command
	'CacheStorage.deleteEntry':                          MessageType.command
	'CacheStorage.requestCacheNames':                    MessageType.command
	'CacheStorage.requestCachedResponse':                MessageType.command
	'CacheStorage.requestEntries':                       MessageType.command
	'Cast.enable':                                       MessageType.command
	'Cast.disable':                                      MessageType.command
	'Cast.setSinkToUse':                                 MessageType.command
	'Cast.startDesktopMirroring':                        MessageType.command
	'Cast.startTabMirroring':                            MessageType.command
	'Cast.stopCasting':                                  MessageType.command
	'Cast.sinksUpdated':                                 MessageType.event
	'Cast.issueUpdated':                                 MessageType.event
	'DOM.collectClassNamesFromSubtree':                  MessageType.command
	'DOM.copyTo':                                        MessageType.command
	'DOM.describeNode':                                  MessageType.command
	'DOM.scrollIntoViewIfNeeded':                        MessageType.command
	'DOM.disable':                                       MessageType.command
	'DOM.discardSearchResults':                          MessageType.command
	'DOM.enable':                                        MessageType.command
	'DOM.focus':                                         MessageType.command
	'DOM.getAttributes':                                 MessageType.command
	'DOM.getBoxModel':                                   MessageType.command
	'DOM.getContentQuads':                               MessageType.command
	'DOM.getDocument':                                   MessageType.command
	'DOM.getFlattenedDocument':                          MessageType.command
	'DOM.getNodesForSubtreeByStyle':                     MessageType.command
	'DOM.getNodeForLocation':                            MessageType.command
	'DOM.getOuterHTML':                                  MessageType.command
	'DOM.getRelayoutBoundary':                           MessageType.command
	'DOM.getSearchResults':                              MessageType.command
	'DOM.hideHighlight':                                 MessageType.command
	'DOM.highlightNode':                                 MessageType.command
	'DOM.highlightRect':                                 MessageType.command
	'DOM.markUndoableState':                             MessageType.command
	'DOM.moveTo':                                        MessageType.command
	'DOM.performSearch':                                 MessageType.command
	'DOM.pushNodeByPathToFrontend':                      MessageType.command
	'DOM.pushNodesByBackendIdsToFrontend':               MessageType.command
	'DOM.querySelector':                                 MessageType.command
	'DOM.querySelectorAll':                              MessageType.command
	'DOM.getTopLayerElements':                           MessageType.command
	'DOM.getElementByRelation':                          MessageType.command
	'DOM.redo':                                          MessageType.command
	'DOM.removeAttribute':                               MessageType.command
	'DOM.removeNode':                                    MessageType.command
	'DOM.requestChildNodes':                             MessageType.command
	'DOM.requestNode':                                   MessageType.command
	'DOM.resolveNode':                                   MessageType.command
	'DOM.setAttributeValue':                             MessageType.command
	'DOM.setAttributesAsText':                           MessageType.command
	'DOM.setFileInputFiles':                             MessageType.command
	'DOM.setNodeStackTracesEnabled':                     MessageType.command
	'DOM.getNodeStackTraces':                            MessageType.command
	'DOM.getFileInfo':                                   MessageType.command
	'DOM.getDetachedDomNodes':                           MessageType.command
	'DOM.setInspectedNode':                              MessageType.command
	'DOM.setNodeName':                                   MessageType.command
	'DOM.setNodeValue':                                  MessageType.command
	'DOM.setOuterHTML':                                  MessageType.command
	'DOM.undo':                                          MessageType.command
	'DOM.getFrameOwner':                                 MessageType.command
	'DOM.getContainerForNode':                           MessageType.command
	'DOM.getQueryingDescendantsForContainer':            MessageType.command
	'DOM.getAnchorElement':                              MessageType.command
	'DOM.attributeModified':                             MessageType.event
	'DOM.attributeRemoved':                              MessageType.event
	'DOM.characterDataModified':                         MessageType.event
	'DOM.childNodeCountUpdated':                         MessageType.event
	'DOM.childNodeInserted':                             MessageType.event
	'DOM.childNodeRemoved':                              MessageType.event
	'DOM.distributedNodesUpdated':                       MessageType.event
	'DOM.documentUpdated':                               MessageType.event
	'DOM.inlineStyleInvalidated':                        MessageType.event
	'DOM.pseudoElementAdded':                            MessageType.event
	'DOM.topLayerElementsUpdated':                       MessageType.event
	'DOM.scrollableFlagUpdated':                         MessageType.event
	'DOM.pseudoElementRemoved':                          MessageType.event
	'DOM.setChildNodes':                                 MessageType.event
	'DOM.shadowRootPopped':                              MessageType.event
	'DOM.shadowRootPushed':                              MessageType.event
	'DOMDebugger.getEventListeners':                     MessageType.command
	'DOMDebugger.removeDOMBreakpoint':                   MessageType.command
	'DOMDebugger.removeEventListenerBreakpoint':         MessageType.command
	'DOMDebugger.removeInstrumentationBreakpoint':       MessageType.command
	'DOMDebugger.removeXHRBreakpoint':                   MessageType.command
	'DOMDebugger.setBreakOnCSPViolation':                MessageType.command
	'DOMDebugger.setDOMBreakpoint':                      MessageType.command
	'DOMDebugger.setEventListenerBreakpoint':            MessageType.command
	'DOMDebugger.setInstrumentationBreakpoint':          MessageType.command
	'DOMDebugger.setXHRBreakpoint':                      MessageType.command
	'EventBreakpoints.setInstrumentationBreakpoint':     MessageType.command
	'EventBreakpoints.removeInstrumentationBreakpoint':  MessageType.command
	'EventBreakpoints.disable':                          MessageType.command
	'DOMSnapshot.disable':                               MessageType.command
	'DOMSnapshot.enable':                                MessageType.command
	'DOMSnapshot.getSnapshot':                           MessageType.command
	'DOMSnapshot.captureSnapshot':                       MessageType.command
	'DOMStorage.clear':                                  MessageType.command
	'DOMStorage.disable':                                MessageType.command
	'DOMStorage.enable':                                 MessageType.command
	'DOMStorage.getDOMStorageItems':                     MessageType.command
	'DOMStorage.removeDOMStorageItem':                   MessageType.command
	'DOMStorage.setDOMStorageItem':                      MessageType.command
	'DOMStorage.domStorageItemAdded':                    MessageType.event
	'DOMStorage.domStorageItemRemoved':                  MessageType.event
	'DOMStorage.domStorageItemUpdated':                  MessageType.event
	'DOMStorage.domStorageItemsCleared':                 MessageType.event
	'Database.disable':                                  MessageType.command
	'Database.enable':                                   MessageType.command
	'Database.executeSQL':                               MessageType.command
	'Database.getDatabaseTableNames':                    MessageType.command
	'Database.addDatabase':                              MessageType.event
	'DeviceOrientation.clearDeviceOrientationOverride':  MessageType.command
	'DeviceOrientation.setDeviceOrientationOverride':    MessageType.command
	'Emulation.canEmulate':                              MessageType.command
	'Emulation.clearDeviceMetricsOverride':              MessageType.command
	'Emulation.clearGeolocationOverride':                MessageType.command
	'Emulation.resetPageScaleFactor':                    MessageType.command
	'Emulation.setFocusEmulationEnabled':                MessageType.command
	'Emulation.setAutoDarkModeOverride':                 MessageType.command
	'Emulation.setCPUThrottlingRate':                    MessageType.command
	'Emulation.setDefaultBackgroundColorOverride':       MessageType.command
	'Emulation.setDeviceMetricsOverride':                MessageType.command
	'Emulation.setDevicePostureOverride':                MessageType.command
	'Emulation.clearDevicePostureOverride':              MessageType.command
	'Emulation.setScrollbarsHidden':                     MessageType.command
	'Emulation.setDocumentCookieDisabled':               MessageType.command
	'Emulation.setEmitTouchEventsForMouse':              MessageType.command
	'Emulation.setEmulatedMedia':                        MessageType.command
	'Emulation.setEmulatedVisionDeficiency':             MessageType.command
	'Emulation.setGeolocationOverride':                  MessageType.command
	'Emulation.getOverriddenSensorInformation':          MessageType.command
	'Emulation.setSensorOverrideEnabled':                MessageType.command
	'Emulation.setSensorOverrideReadings':               MessageType.command
	'Emulation.setPressureSourceOverrideEnabled':        MessageType.command
	'Emulation.setPressureStateOverride':                MessageType.command
	'Emulation.setIdleOverride':                         MessageType.command
	'Emulation.clearIdleOverride':                       MessageType.command
	'Emulation.setNavigatorOverrides':                   MessageType.command
	'Emulation.setPageScaleFactor':                      MessageType.command
	'Emulation.setScriptExecutionDisabled':              MessageType.command
	'Emulation.setTouchEmulationEnabled':                MessageType.command
	'Emulation.setVirtualTimePolicy':                    MessageType.command
	'Emulation.setLocaleOverride':                       MessageType.command
	'Emulation.setTimezoneOverride':                     MessageType.command
	'Emulation.setVisibleSize':                          MessageType.command
	'Emulation.setDisabledImageTypes':                   MessageType.command
	'Emulation.setHardwareConcurrencyOverride':          MessageType.command
	'Emulation.setUserAgentOverride':                    MessageType.command
	'Emulation.setAutomationOverride':                   MessageType.command
	'Emulation.virtualTimeBudgetExpired':                MessageType.event
	'HeadlessExperimental.beginFrame':                   MessageType.command
	'HeadlessExperimental.disable':                      MessageType.command
	'HeadlessExperimental.enable':                       MessageType.command
	'IO.close':                                          MessageType.command
	'IO.read':                                           MessageType.command
	'IO.resolveBlob':                                    MessageType.command
	'FileSystem.getDirectory':                           MessageType.command
	'IndexedDB.clearObjectStore':                        MessageType.command
	'IndexedDB.deleteDatabase':                          MessageType.command
	'IndexedDB.deleteObjectStoreEntries':                MessageType.command
	'IndexedDB.disable':                                 MessageType.command
	'IndexedDB.enable':                                  MessageType.command
	'IndexedDB.requestData':                             MessageType.command
	'IndexedDB.getMetadata':                             MessageType.command
	'IndexedDB.requestDatabase':                         MessageType.command
	'IndexedDB.requestDatabaseNames':                    MessageType.command
	'Input.dispatchDragEvent':                           MessageType.command
	'Input.dispatchKeyEvent':                            MessageType.command
	'Input.insertText':                                  MessageType.command
	'Input.imeSetComposition':                           MessageType.command
	'Input.dispatchMouseEvent':                          MessageType.command
	'Input.dispatchTouchEvent':                          MessageType.command
	'Input.cancelDragging':                              MessageType.command
	'Input.emulateTouchFromMouseEvent':                  MessageType.command
	'Input.setIgnoreInputEvents':                        MessageType.command
	'Input.setInterceptDrags':                           MessageType.command
	'Input.synthesizePinchGesture':                      MessageType.command
	'Input.synthesizeScrollGesture':                     MessageType.command
	'Input.synthesizeTapGesture':                        MessageType.command
	'Input.dragIntercepted':                             MessageType.event
	'Inspector.disable':                                 MessageType.command
	'Inspector.enable':                                  MessageType.command
	'Inspector.detached':                                MessageType.event
	'Inspector.targetCrashed':                           MessageType.event
	'Inspector.targetReloadedAfterCrash':                MessageType.event
	'LayerTree.compositingReasons':                      MessageType.command
	'LayerTree.disable':                                 MessageType.command
	'LayerTree.enable':                                  MessageType.command
	'LayerTree.loadSnapshot':                            MessageType.command
	'LayerTree.makeSnapshot':                            MessageType.command
	'LayerTree.profileSnapshot':                         MessageType.command
	'LayerTree.releaseSnapshot':                         MessageType.command
	'LayerTree.replaySnapshot':                          MessageType.command
	'LayerTree.snapshotCommandLog':                      MessageType.command
	'LayerTree.layerPainted':                            MessageType.event
	'LayerTree.layerTreeDidChange':                      MessageType.event
	'Log.clear':                                         MessageType.command
	'Log.disable':                                       MessageType.command
	'Log.enable':                                        MessageType.command
	'Log.startViolationsReport':                         MessageType.command
	'Log.stopViolationsReport':                          MessageType.command
	'Log.entryAdded':                                    MessageType.event
	'Memory.getDOMCounters':                             MessageType.command
	'Memory.getDOMCountersForLeakDetection':             MessageType.command
	'Memory.prepareForLeakDetection':                    MessageType.command
	'Memory.forciblyPurgeJavaScriptMemory':              MessageType.command
	'Memory.setPressureNotificationsSuppressed':         MessageType.command
	'Memory.simulatePressureNotification':               MessageType.command
	'Memory.startSampling':                              MessageType.command
	'Memory.stopSampling':                               MessageType.command
	'Memory.getAllTimeSamplingProfile':                  MessageType.command
	'Memory.getBrowserSamplingProfile':                  MessageType.command
	'Memory.getSamplingProfile':                         MessageType.command
	'Network.setAcceptedEncodings':                      MessageType.command
	'Network.clearAcceptedEncodingsOverride':            MessageType.command
	'Network.canClearBrowserCache':                      MessageType.command
	'Network.canClearBrowserCookies':                    MessageType.command
	'Network.canEmulateNetworkConditions':               MessageType.command
	'Network.clearBrowserCache':                         MessageType.command
	'Network.clearBrowserCookies':                       MessageType.command
	'Network.continueInterceptedRequest':                MessageType.command
	'Network.deleteCookies':                             MessageType.command
	'Network.disable':                                   MessageType.command
	'Network.emulateNetworkConditions':                  MessageType.command
	'Network.enable':                                    MessageType.command
	'Network.getAllCookies':                             MessageType.command
	'Network.getCertificate':                            MessageType.command
	'Network.getCookies':                                MessageType.command
	'Network.getResponseBody':                           MessageType.command
	'Network.getRequestPostData':                        MessageType.command
	'Network.getResponseBodyForInterception':            MessageType.command
	'Network.takeResponseBodyForInterceptionAsStream':   MessageType.command
	'Network.replayXHR':                                 MessageType.command
	'Network.searchInResponseBody':                      MessageType.command
	'Network.setBlockedURLs':                            MessageType.command
	'Network.setBypassServiceWorker':                    MessageType.command
	'Network.setCacheDisabled':                          MessageType.command
	'Network.setCookie':                                 MessageType.command
	'Network.setCookies':                                MessageType.command
	'Network.setExtraHTTPHeaders':                       MessageType.command
	'Network.setAttachDebugStack':                       MessageType.command
	'Network.setRequestInterception':                    MessageType.command
	'Network.setUserAgentOverride':                      MessageType.command
	'Network.streamResourceContent':                     MessageType.command
	'Network.getSecurityIsolationStatus':                MessageType.command
	'Network.enableReportingApi':                        MessageType.command
	'Network.loadNetworkResource':                       MessageType.command
	'Network.dataReceived':                              MessageType.event
	'Network.eventSourceMessageReceived':                MessageType.event
	'Network.loadingFailed':                             MessageType.event
	'Network.loadingFinished':                           MessageType.event
	'Network.requestIntercepted':                        MessageType.event
	'Network.requestServedFromCache':                    MessageType.event
	'Network.requestWillBeSent':                         MessageType.event
	'Network.resourceChangedPriority':                   MessageType.event
	'Network.signedExchangeReceived':                    MessageType.event
	'Network.responseReceived':                          MessageType.event
	'Network.webSocketClosed':                           MessageType.event
	'Network.webSocketCreated':                          MessageType.event
	'Network.webSocketFrameError':                       MessageType.event
	'Network.webSocketFrameReceived':                    MessageType.event
	'Network.webSocketFrameSent':                        MessageType.event
	'Network.webSocketHandshakeResponseReceived':        MessageType.event
	'Network.webSocketWillSendHandshakeRequest':         MessageType.event
	'Network.webTransportCreated':                       MessageType.event
	'Network.webTransportConnectionEstablished':         MessageType.event
	'Network.webTransportClosed':                        MessageType.event
	'Network.requestWillBeSentExtraInfo':                MessageType.event
	'Network.responseReceivedExtraInfo':                 MessageType.event
	'Network.responseReceivedEarlyHints':                MessageType.event
	'Network.trustTokenOperationDone':                   MessageType.event
	'Network.policyUpdated':                             MessageType.event
	'Network.subresourceWebBundleMetadataReceived':      MessageType.event
	'Network.subresourceWebBundleMetadataError':         MessageType.event
	'Network.subresourceWebBundleInnerResponseParsed':   MessageType.event
	'Network.subresourceWebBundleInnerResponseError':    MessageType.event
	'Network.reportingApiReportAdded':                   MessageType.event
	'Network.reportingApiReportUpdated':                 MessageType.event
	'Network.reportingApiEndpointsChangedForOrigin':     MessageType.event
	'Overlay.disable':                                   MessageType.command
	'Overlay.enable':                                    MessageType.command
	'Overlay.getHighlightObjectForTest':                 MessageType.command
	'Overlay.getGridHighlightObjectsForTest':            MessageType.command
	'Overlay.getSourceOrderHighlightObjectForTest':      MessageType.command
	'Overlay.hideHighlight':                             MessageType.command
	'Overlay.highlightFrame':                            MessageType.command
	'Overlay.highlightNode':                             MessageType.command
	'Overlay.highlightQuad':                             MessageType.command
	'Overlay.highlightRect':                             MessageType.command
	'Overlay.highlightSourceOrder':                      MessageType.command
	'Overlay.setInspectMode':                            MessageType.command
	'Overlay.setShowAdHighlights':                       MessageType.command
	'Overlay.setPausedInDebuggerMessage':                MessageType.command
	'Overlay.setShowDebugBorders':                       MessageType.command
	'Overlay.setShowFPSCounter':                         MessageType.command
	'Overlay.setShowGridOverlays':                       MessageType.command
	'Overlay.setShowFlexOverlays':                       MessageType.command
	'Overlay.setShowScrollSnapOverlays':                 MessageType.command
	'Overlay.setShowContainerQueryOverlays':             MessageType.command
	'Overlay.setShowPaintRects':                         MessageType.command
	'Overlay.setShowLayoutShiftRegions':                 MessageType.command
	'Overlay.setShowScrollBottleneckRects':              MessageType.command
	'Overlay.setShowHitTestBorders':                     MessageType.command
	'Overlay.setShowWebVitals':                          MessageType.command
	'Overlay.setShowViewportSizeOnResize':               MessageType.command
	'Overlay.setShowHinge':                              MessageType.command
	'Overlay.setShowIsolatedElements':                   MessageType.command
	'Overlay.setShowWindowControlsOverlay':              MessageType.command
	'Overlay.inspectNodeRequested':                      MessageType.event
	'Overlay.nodeHighlightRequested':                    MessageType.event
	'Overlay.screenshotRequested':                       MessageType.event
	'Overlay.inspectModeCanceled':                       MessageType.event
	'Page.addScriptToEvaluateOnLoad':                    MessageType.command
	'Page.addScriptToEvaluateOnNewDocument':             MessageType.command
	'Page.bringToFront':                                 MessageType.command
	'Page.captureScreenshot':                            MessageType.command
	'Page.captureSnapshot':                              MessageType.command
	'Page.clearDeviceMetricsOverride':                   MessageType.command
	'Page.clearDeviceOrientationOverride':               MessageType.command
	'Page.clearGeolocationOverride':                     MessageType.command
	'Page.createIsolatedWorld':                          MessageType.command
	'Page.deleteCookie':                                 MessageType.command
	'Page.disable':                                      MessageType.command
	'Page.enable':                                       MessageType.command
	'Page.getAppManifest':                               MessageType.command
	'Page.getInstallabilityErrors':                      MessageType.command
	'Page.getManifestIcons':                             MessageType.command
	'Page.getAppId':                                     MessageType.command
	'Page.getAdScriptId':                                MessageType.command
	'Page.getFrameTree':                                 MessageType.command
	'Page.getLayoutMetrics':                             MessageType.command
	'Page.getNavigationHistory':                         MessageType.command
	'Page.resetNavigationHistory':                       MessageType.command
	'Page.getResourceContent':                           MessageType.command
	'Page.getResourceTree':                              MessageType.command
	'Page.handleJavaScriptDialog':                       MessageType.command
	'Page.navigate':                                     MessageType.command
	'Page.navigateToHistoryEntry':                       MessageType.command
	'Page.printToPDF':                                   MessageType.command
	'Page.reload':                                       MessageType.command
	'Page.removeScriptToEvaluateOnLoad':                 MessageType.command
	'Page.removeScriptToEvaluateOnNewDocument':          MessageType.command
	'Page.screencastFrameAck':                           MessageType.command
	'Page.searchInResource':                             MessageType.command
	'Page.setAdBlockingEnabled':                         MessageType.command
	'Page.setBypassCSP':                                 MessageType.command
	'Page.getPermissionsPolicyState':                    MessageType.command
	'Page.getOriginTrials':                              MessageType.command
	'Page.setDeviceMetricsOverride':                     MessageType.command
	'Page.setDeviceOrientationOverride':                 MessageType.command
	'Page.setFontFamilies':                              MessageType.command
	'Page.setFontSizes':                                 MessageType.command
	'Page.setDocumentContent':                           MessageType.command
	'Page.setDownloadBehavior':                          MessageType.command
	'Page.setGeolocationOverride':                       MessageType.command
	'Page.setLifecycleEventsEnabled':                    MessageType.command
	'Page.setTouchEmulationEnabled':                     MessageType.command
	'Page.startScreencast':                              MessageType.command
	'Page.stopLoading':                                  MessageType.command
	'Page.crash':                                        MessageType.command
	'Page.close':                                        MessageType.command
	'Page.setWebLifecycleState':                         MessageType.command
	'Page.stopScreencast':                               MessageType.command
	'Page.produceCompilationCache':                      MessageType.command
	'Page.addCompilationCache':                          MessageType.command
	'Page.clearCompilationCache':                        MessageType.command
	'Page.setSPCTransactionMode':                        MessageType.command
	'Page.setRPHRegistrationMode':                       MessageType.command
	'Page.generateTestReport':                           MessageType.command
	'Page.waitForDebugger':                              MessageType.command
	'Page.setInterceptFileChooserDialog':                MessageType.command
	'Page.setPrerenderingAllowed':                       MessageType.command
	'Page.domContentEventFired':                         MessageType.event
	'Page.fileChooserOpened':                            MessageType.event
	'Page.frameAttached':                                MessageType.event
	'Page.frameClearedScheduledNavigation':              MessageType.event
	'Page.frameDetached':                                MessageType.event
	'Page.frameSubtreeWillBeDetached':                   MessageType.event
	'Page.frameNavigated':                               MessageType.event
	'Page.documentOpened':                               MessageType.event
	'Page.frameResized':                                 MessageType.event
	'Page.frameRequestedNavigation':                     MessageType.event
	'Page.frameScheduledNavigation':                     MessageType.event
	'Page.frameStartedLoading':                          MessageType.event
	'Page.frameStoppedLoading':                          MessageType.event
	'Page.downloadWillBegin':                            MessageType.event
	'Page.downloadProgress':                             MessageType.event
	'Page.interstitialHidden':                           MessageType.event
	'Page.interstitialShown':                            MessageType.event
	'Page.javascriptDialogClosed':                       MessageType.event
	'Page.javascriptDialogOpening':                      MessageType.event
	'Page.lifecycleEvent':                               MessageType.event
	'Page.backForwardCacheNotUsed':                      MessageType.event
	'Page.loadEventFired':                               MessageType.event
	'Page.navigatedWithinDocument':                      MessageType.event
	'Page.screencastFrame':                              MessageType.event
	'Page.screencastVisibilityChanged':                  MessageType.event
	'Page.windowOpen':                                   MessageType.event
	'Page.compilationCacheProduced':                     MessageType.event
	'Performance.disable':                               MessageType.command
	'Performance.enable':                                MessageType.command
	'Performance.setTimeDomain':                         MessageType.command
	'Performance.getMetrics':                            MessageType.command
	'Performance.metrics':                               MessageType.event
	'PerformanceTimeline.enable':                        MessageType.command
	'PerformanceTimeline.timelineEventAdded':            MessageType.event
	'Security.disable':                                  MessageType.command
	'Security.enable':                                   MessageType.command
	'Security.setIgnoreCertificateErrors':               MessageType.command
	'Security.handleCertificateError':                   MessageType.command
	'Security.setOverrideCertificateErrors':             MessageType.command
	'Security.certificateError':                         MessageType.event
	'Security.visibleSecurityStateChanged':              MessageType.event
	'Security.securityStateChanged':                     MessageType.event
	'ServiceWorker.deliverPushMessage':                  MessageType.command
	'ServiceWorker.disable':                             MessageType.command
	'ServiceWorker.dispatchSyncEvent':                   MessageType.command
	'ServiceWorker.dispatchPeriodicSyncEvent':           MessageType.command
	'ServiceWorker.enable':                              MessageType.command
	'ServiceWorker.inspectWorker':                       MessageType.command
	'ServiceWorker.setForceUpdateOnPageLoad':            MessageType.command
	'ServiceWorker.skipWaiting':                         MessageType.command
	'ServiceWorker.startWorker':                         MessageType.command
	'ServiceWorker.stopAllWorkers':                      MessageType.command
	'ServiceWorker.stopWorker':                          MessageType.command
	'ServiceWorker.unregister':                          MessageType.command
	'ServiceWorker.updateRegistration':                  MessageType.command
	'ServiceWorker.workerErrorReported':                 MessageType.event
	'ServiceWorker.workerRegistrationUpdated':           MessageType.event
	'ServiceWorker.workerVersionUpdated':                MessageType.event
	'Storage.getStorageKeyForFrame':                     MessageType.command
	'Storage.clearDataForOrigin':                        MessageType.command
	'Storage.clearDataForStorageKey':                    MessageType.command
	'Storage.getCookies':                                MessageType.command
	'Storage.setCookies':                                MessageType.command
	'Storage.clearCookies':                              MessageType.command
	'Storage.getUsageAndQuota':                          MessageType.command
	'Storage.overrideQuotaForOrigin':                    MessageType.command
	'Storage.trackCacheStorageForOrigin':                MessageType.command
	'Storage.trackCacheStorageForStorageKey':            MessageType.command
	'Storage.trackIndexedDBForOrigin':                   MessageType.command
	'Storage.trackIndexedDBForStorageKey':               MessageType.command
	'Storage.untrackCacheStorageForOrigin':              MessageType.command
	'Storage.untrackCacheStorageForStorageKey':          MessageType.command
	'Storage.untrackIndexedDBForOrigin':                 MessageType.command
	'Storage.untrackIndexedDBForStorageKey':             MessageType.command
	'Storage.getTrustTokens':                            MessageType.command
	'Storage.clearTrustTokens':                          MessageType.command
	'Storage.getInterestGroupDetails':                   MessageType.command
	'Storage.setInterestGroupTracking':                  MessageType.command
	'Storage.setInterestGroupAuctionTracking':           MessageType.command
	'Storage.getSharedStorageMetadata':                  MessageType.command
	'Storage.getSharedStorageEntries':                   MessageType.command
	'Storage.setSharedStorageEntry':                     MessageType.command
	'Storage.deleteSharedStorageEntry':                  MessageType.command
	'Storage.clearSharedStorageEntries':                 MessageType.command
	'Storage.resetSharedStorageBudget':                  MessageType.command
	'Storage.setSharedStorageTracking':                  MessageType.command
	'Storage.setStorageBucketTracking':                  MessageType.command
	'Storage.deleteStorageBucket':                       MessageType.command
	'Storage.runBounceTrackingMitigations':              MessageType.command
	'Storage.setAttributionReportingLocalTestingMode':   MessageType.command
	'Storage.setAttributionReportingTracking':           MessageType.command
	'Storage.sendPendingAttributionReports':             MessageType.command
	'Storage.getRelatedWebsiteSets':                     MessageType.command
	'Storage.cacheStorageContentUpdated':                MessageType.event
	'Storage.cacheStorageListUpdated':                   MessageType.event
	'Storage.indexedDBContentUpdated':                   MessageType.event
	'Storage.indexedDBListUpdated':                      MessageType.event
	'Storage.interestGroupAccessed':                     MessageType.event
	'Storage.interestGroupAuctionEventOccurred':         MessageType.event
	'Storage.interestGroupAuctionNetworkRequestCreated': MessageType.event
	'Storage.sharedStorageAccessed':                     MessageType.event
	'Storage.storageBucketCreatedOrUpdated':             MessageType.event
	'Storage.storageBucketDeleted':                      MessageType.event
	'Storage.attributionReportingSourceRegistered':      MessageType.event
	'Storage.attributionReportingTriggerRegistered':     MessageType.event
	'SystemInfo.getInfo':                                MessageType.command
	'SystemInfo.getFeatureState':                        MessageType.command
	'SystemInfo.getProcessInfo':                         MessageType.command
	'Target.activateTarget':                             MessageType.command
	'Target.attachToTarget':                             MessageType.command
	'Target.attachToBrowserTarget':                      MessageType.command
	'Target.closeTarget':                                MessageType.command
	'Target.exposeDevToolsProtocol':                     MessageType.command
	'Target.createBrowserContext':                       MessageType.command
	'Target.getBrowserContexts':                         MessageType.command
	'Target.createTarget':                               MessageType.command
	'Target.detachFromTarget':                           MessageType.command
	'Target.disposeBrowserContext':                      MessageType.command
	'Target.getTargetInfo':                              MessageType.command
	'Target.getTargets':                                 MessageType.command
	'Target.sendMessageToTarget':                        MessageType.command
	'Target.setAutoAttach':                              MessageType.command
	'Target.autoAttachRelated':                          MessageType.command
	'Target.setDiscoverTargets':                         MessageType.command
	'Target.setRemoteLocations':                         MessageType.command
	'Target.attachedToTarget':                           MessageType.event
	'Target.detachedFromTarget':                         MessageType.event
	'Target.receivedMessageFromTarget':                  MessageType.event
	'Target.targetCreated':                              MessageType.event
	'Target.targetDestroyed':                            MessageType.event
	'Target.targetCrashed':                              MessageType.event
	'Target.targetInfoChanged':                          MessageType.event
	'Tethering.bind':                                    MessageType.command
	'Tethering.unbind':                                  MessageType.command
	'Tethering.accepted':                                MessageType.event
	'Tracing.end':                                       MessageType.command
	'Tracing.getCategories':                             MessageType.command
	'Tracing.recordClockSyncMarker':                     MessageType.command
	'Tracing.requestMemoryDump':                         MessageType.command
	'Tracing.start':                                     MessageType.command
	'Tracing.bufferUsage':                               MessageType.event
	'Tracing.dataCollected':                             MessageType.event
	'Tracing.tracingComplete':                           MessageType.event
	'Fetch.disable':                                     MessageType.command
	'Fetch.enable':                                      MessageType.command
	'Fetch.failRequest':                                 MessageType.command
	'Fetch.fulfillRequest':                              MessageType.command
	'Fetch.continueRequest':                             MessageType.command
	'Fetch.continueWithAuth':                            MessageType.command
	'Fetch.continueResponse':                            MessageType.command
	'Fetch.getResponseBody':                             MessageType.command
	'Fetch.takeResponseBodyAsStream':                    MessageType.command
	'Fetch.requestPaused':                               MessageType.event
	'Fetch.authRequired':                                MessageType.event
	'WebAudio.enable':                                   MessageType.command
	'WebAudio.disable':                                  MessageType.command
	'WebAudio.getRealtimeData':                          MessageType.command
	'WebAudio.contextCreated':                           MessageType.event
	'WebAudio.contextWillBeDestroyed':                   MessageType.event
	'WebAudio.contextChanged':                           MessageType.event
	'WebAudio.audioListenerCreated':                     MessageType.event
	'WebAudio.audioListenerWillBeDestroyed':             MessageType.event
	'WebAudio.audioNodeCreated':                         MessageType.event
	'WebAudio.audioNodeWillBeDestroyed':                 MessageType.event
	'WebAudio.audioParamCreated':                        MessageType.event
	'WebAudio.audioParamWillBeDestroyed':                MessageType.event
	'WebAudio.nodesConnected':                           MessageType.event
	'WebAudio.nodesDisconnected':                        MessageType.event
	'WebAudio.nodeParamConnected':                       MessageType.event
	'WebAudio.nodeParamDisconnected':                    MessageType.event
	'WebAuthn.enable':                                   MessageType.command
	'WebAuthn.disable':                                  MessageType.command
	'WebAuthn.addVirtualAuthenticator':                  MessageType.command
	'WebAuthn.setResponseOverrideBits':                  MessageType.command
	'WebAuthn.removeVirtualAuthenticator':               MessageType.command
	'WebAuthn.addCredential':                            MessageType.command
	'WebAuthn.getCredential':                            MessageType.command
	'WebAuthn.getCredentials':                           MessageType.command
	'WebAuthn.removeCredential':                         MessageType.command
	'WebAuthn.clearCredentials':                         MessageType.command
	'WebAuthn.setUserVerified':                          MessageType.command
	'WebAuthn.setAutomaticPresenceSimulation':           MessageType.command
	'WebAuthn.setCredentialProperties':                  MessageType.command
	'WebAuthn.credentialAdded':                          MessageType.event
	'WebAuthn.credentialDeleted':                        MessageType.event
	'WebAuthn.credentialUpdated':                        MessageType.event
	'WebAuthn.credentialAsserted':                       MessageType.event
	'Media.enable':                                      MessageType.command
	'Media.disable':                                     MessageType.command
	'Media.playerPropertiesChanged':                     MessageType.event
	'Media.playerEventsAdded':                           MessageType.event
	'Media.playerMessagesLogged':                        MessageType.event
	'Media.playerErrorsRaised':                          MessageType.event
	'Media.playersCreated':                              MessageType.event
	'DeviceAccess.enable':                               MessageType.command
	'DeviceAccess.disable':                              MessageType.command
	'DeviceAccess.selectPrompt':                         MessageType.command
	'DeviceAccess.cancelPrompt':                         MessageType.command
	'DeviceAccess.deviceRequestPrompted':                MessageType.event
	'Preload.enable':                                    MessageType.command
	'Preload.disable':                                   MessageType.command
	'Preload.ruleSetUpdated':                            MessageType.event
	'Preload.ruleSetRemoved':                            MessageType.event
	'Preload.preloadEnabledStateUpdated':                MessageType.event
	'Preload.prefetchStatusUpdated':                     MessageType.event
	'Preload.prerenderStatusUpdated':                    MessageType.event
	'Preload.preloadingAttemptSourcesUpdated':           MessageType.event
	'FedCm.enable':                                      MessageType.command
	'FedCm.disable':                                     MessageType.command
	'FedCm.selectAccount':                               MessageType.command
	'FedCm.clickDialogButton':                           MessageType.command
	'FedCm.openUrl':                                     MessageType.command
	'FedCm.dismissDialog':                               MessageType.command
	'FedCm.resetCooldown':                               MessageType.command
	'FedCm.dialogShown':                                 MessageType.event
	'FedCm.dialogClosed':                                MessageType.event
	'PWA.getOsAppState':                                 MessageType.command
	'PWA.install':                                       MessageType.command
	'PWA.uninstall':                                     MessageType.command
	'PWA.launch':                                        MessageType.command
	'PWA.launchFilesInApp':                              MessageType.command
	'PWA.openCurrentPageInApp':                          MessageType.command
	'PWA.changeAppUserSettings':                         MessageType.command
	'BluetoothEmulation.enable':                         MessageType.command
	'BluetoothEmulation.disable':                        MessageType.command
	'BluetoothEmulation.simulatePreconnectedPeripheral': MessageType.command
	'BluetoothEmulation.simulateAdvertisement':          MessageType.command
	'Console.clearMessages':                             MessageType.command
	'Console.disable':                                   MessageType.command
	'Console.enable':                                    MessageType.command
	'Console.messageAdded':                              MessageType.event
	'Debugger.continueToLocation':                       MessageType.command
	'Debugger.disable':                                  MessageType.command
	'Debugger.enable':                                   MessageType.command
	'Debugger.evaluateOnCallFrame':                      MessageType.command
	'Debugger.getPossibleBreakpoints':                   MessageType.command
	'Debugger.getScriptSource':                          MessageType.command
	'Debugger.disassembleWasmModule':                    MessageType.command
	'Debugger.nextWasmDisassemblyChunk':                 MessageType.command
	'Debugger.getWasmBytecode':                          MessageType.command
	'Debugger.getStackTrace':                            MessageType.command
	'Debugger.pause':                                    MessageType.command
	'Debugger.pauseOnAsyncCall':                         MessageType.command
	'Debugger.removeBreakpoint':                         MessageType.command
	'Debugger.restartFrame':                             MessageType.command
	'Debugger.resume':                                   MessageType.command
	'Debugger.searchInContent':                          MessageType.command
	'Debugger.setAsyncCallStackDepth':                   MessageType.command
	'Debugger.setBlackboxExecutionContexts':             MessageType.command
	'Debugger.setBlackboxPatterns':                      MessageType.command
	'Debugger.setBlackboxedRanges':                      MessageType.command
	'Debugger.setBreakpoint':                            MessageType.command
	'Debugger.setInstrumentationBreakpoint':             MessageType.command
	'Debugger.setBreakpointByUrl':                       MessageType.command
	'Debugger.setBreakpointOnFunctionCall':              MessageType.command
	'Debugger.setBreakpointsActive':                     MessageType.command
	'Debugger.setPauseOnExceptions':                     MessageType.command
	'Debugger.setReturnValue':                           MessageType.command
	'Debugger.setScriptSource':                          MessageType.command
	'Debugger.setSkipAllPauses':                         MessageType.command
	'Debugger.setVariableValue':                         MessageType.command
	'Debugger.stepInto':                                 MessageType.command
	'Debugger.stepOut':                                  MessageType.command
	'Debugger.stepOver':                                 MessageType.command
	'Debugger.breakpointResolved':                       MessageType.event
	'Debugger.paused':                                   MessageType.event
	'Debugger.resumed':                                  MessageType.event
	'Debugger.scriptFailedToParse':                      MessageType.event
	'Debugger.scriptParsed':                             MessageType.event
	'HeapProfiler.addInspectedHeapObject':               MessageType.command
	'HeapProfiler.collectGarbage':                       MessageType.command
	'HeapProfiler.disable':                              MessageType.command
	'HeapProfiler.enable':                               MessageType.command
	'HeapProfiler.getHeapObjectId':                      MessageType.command
	'HeapProfiler.getObjectByHeapObjectId':              MessageType.command
	'HeapProfiler.getSamplingProfile':                   MessageType.command
	'HeapProfiler.startSampling':                        MessageType.command
	'HeapProfiler.startTrackingHeapObjects':             MessageType.command
	'HeapProfiler.stopSampling':                         MessageType.command
	'HeapProfiler.stopTrackingHeapObjects':              MessageType.command
	'HeapProfiler.takeHeapSnapshot':                     MessageType.command
	'HeapProfiler.addHeapSnapshotChunk':                 MessageType.event
	'HeapProfiler.heapStatsUpdate':                      MessageType.event
	'HeapProfiler.lastSeenObjectId':                     MessageType.event
	'HeapProfiler.reportHeapSnapshotProgress':           MessageType.event
	'HeapProfiler.resetProfiles':                        MessageType.event
	'Profiler.disable':                                  MessageType.command
	'Profiler.enable':                                   MessageType.command
	'Profiler.getBestEffortCoverage':                    MessageType.command
	'Profiler.setSamplingInterval':                      MessageType.command
	'Profiler.start':                                    MessageType.command
	'Profiler.startPreciseCoverage':                     MessageType.command
	'Profiler.stop':                                     MessageType.command
	'Profiler.stopPreciseCoverage':                      MessageType.command
	'Profiler.takePreciseCoverage':                      MessageType.command
	'Profiler.consoleProfileFinished':                   MessageType.event
	'Profiler.consoleProfileStarted':                    MessageType.event
	'Profiler.preciseCoverageDeltaUpdate':               MessageType.event
	'Runtime.awaitPromise':                              MessageType.command
	'Runtime.callFunctionOn':                            MessageType.command
	'Runtime.compileScript':                             MessageType.command
	'Runtime.disable':                                   MessageType.command
	'Runtime.discardConsoleEntries':                     MessageType.command
	'Runtime.enable':                                    MessageType.command
	'Runtime.evaluate':                                  MessageType.command
	'Runtime.getIsolateId':                              MessageType.command
	'Runtime.getHeapUsage':                              MessageType.command
	'Runtime.getProperties':                             MessageType.command
	'Runtime.globalLexicalScopeNames':                   MessageType.command
	'Runtime.queryObjects':                              MessageType.command
	'Runtime.releaseObject':                             MessageType.command
	'Runtime.releaseObjectGroup':                        MessageType.command
	'Runtime.runIfWaitingForDebugger':                   MessageType.command
	'Runtime.runScript':                                 MessageType.command
	'Runtime.setAsyncCallStackDepth':                    MessageType.command
	'Runtime.setCustomObjectFormatterEnabled':           MessageType.command
	'Runtime.setMaxCallStackSizeToCapture':              MessageType.command
	'Runtime.terminateExecution':                        MessageType.command
	'Runtime.addBinding':                                MessageType.command
	'Runtime.removeBinding':                             MessageType.command
	'Runtime.getExceptionDetails':                       MessageType.command
	'Runtime.bindingCalled':                             MessageType.event
	'Runtime.consoleAPICalled':                          MessageType.event
	'Runtime.exceptionRevoked':                          MessageType.event
	'Runtime.exceptionThrown':                           MessageType.event
	'Runtime.executionContextCreated':                   MessageType.event
	'Runtime.executionContextDestroyed':                 MessageType.event
	'Runtime.executionContextsCleared':                  MessageType.event
	'Runtime.inspectRequested':                          MessageType.event
	'Schema.getDomains':                                 MessageType.command
}

fn (mut tab Tab) is_inactive_deps(name string) bool {
	return !tab.deps.contains(name) && name + '.enable' in map_method
}

fn struct_to_map[T](d T) !map[string]json.Any {
	return json.decode[json.Any](json.encode(d))!.as_map()
}

@[params]
pub struct AccessibilityGetPartialAXTreeParams {
pub:
	node_id         ?int      @[json: 'nodeId']
	backend_node_id ?int      @[json: 'backendNodeId']
	object_id       ?string   @[json: 'objectId']
	fetch_relatives ?bool     @[json: 'fetchRelatives']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AccessibilityGetFullAXTreeParams {
pub:
	depth    ?int      @[json: 'depth']
	frame_id ?string   @[json: 'frameId']
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AccessibilityGetRootAXNodeParams {
pub:
	frame_id ?string   @[json: 'frameId']
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AccessibilityGetAXNodeAndAncestorsParams {
pub:
	node_id         ?int      @[json: 'nodeId']
	backend_node_id ?int      @[json: 'backendNodeId']
	object_id       ?string   @[json: 'objectId']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AccessibilityGetChildAXNodesParams {
pub:
	id       string    @[json: 'id'; required]
	frame_id ?string   @[json: 'frameId']
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AccessibilityQueryAXTreeParams {
pub:
	node_id         ?int      @[json: 'nodeId']
	backend_node_id ?int      @[json: 'backendNodeId']
	object_id       ?string   @[json: 'objectId']
	accessible_name ?string   @[json: 'accessibleName']
	role            ?string   @[json: 'role']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AnimationGetCurrentTimeParams {
pub:
	id   string    @[json: 'id'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AnimationReleaseAnimationsParams {
pub:
	animations []json.Any @[json: 'animations'; required]
	cb         EventFunc = unsafe { nil }  @[json: '-']
	wait       bool      = true       @[json: '-']
	ref        voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct AnimationResolveAnimationParams {
pub:
	animation_id string    @[json: 'animationId'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AnimationSeekAnimationsParams {
pub:
	animations   []json.Any @[json: 'animations'; required]
	current_time f64        @[json: 'currentTime'; required]
	cb           EventFunc = unsafe { nil }  @[json: '-']
	wait         bool      = true       @[json: '-']
	ref          voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct AnimationSetPausedParams {
pub:
	animations []json.Any @[json: 'animations'; required]
	paused     bool       @[json: 'paused'; required]
	cb         EventFunc = unsafe { nil }  @[json: '-']
	wait       bool      = true       @[json: '-']
	ref        voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct AnimationSetPlaybackRateParams {
pub:
	playback_rate f64       @[json: 'playbackRate'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AnimationSetTimingParams {
pub:
	animation_id string    @[json: 'animationId'; required]
	duration     f64       @[json: 'duration'; required]
	delay        f64       @[json: 'delay'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AuditsGetEncodedResponseParams {
pub:
	request_id string    @[json: 'requestId'; required]
	encoding   string    @[json: 'encoding'; required]
	quality    ?f64      @[json: 'quality']
	size_only  ?bool     @[json: 'sizeOnly']
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct AuditsCheckContrastParams {
pub:
	reportaaa ?bool     @[json: 'reportAAA']
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ExtensionsLoadUnpackedParams {
pub:
	path string    @[json: 'path'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ExtensionsGetStorageItemsParams {
pub:
	id           string      @[json: 'id'; required]
	storage_area string      @[json: 'storageArea'; required]
	keys         ?[]json.Any @[json: 'keys']
	cb           EventFunc = unsafe { nil }   @[json: '-']
	wait         bool      = true        @[json: '-']
	ref          voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct ExtensionsRemoveStorageItemsParams {
pub:
	id           string     @[json: 'id'; required]
	storage_area string     @[json: 'storageArea'; required]
	keys         []json.Any @[json: 'keys'; required]
	cb           EventFunc = unsafe { nil }  @[json: '-']
	wait         bool      = true       @[json: '-']
	ref          voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct ExtensionsClearStorageItemsParams {
pub:
	id           string    @[json: 'id'; required]
	storage_area string    @[json: 'storageArea'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ExtensionsSetStorageItemsParams {
pub:
	id           string              @[json: 'id'; required]
	storage_area string              @[json: 'storageArea'; required]
	values       map[string]json.Any @[json: 'values'; required]
	cb           EventFunc = unsafe { nil }           @[json: '-']
	wait         bool      = true                @[json: '-']
	ref          voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct AutofillTriggerParams {
pub:
	field_id int                 @[json: 'fieldId'; required]
	frame_id ?string             @[json: 'frameId']
	card     map[string]json.Any @[json: 'card'; required]
	cb       EventFunc = unsafe { nil }           @[json: '-']
	wait     bool      = true                @[json: '-']
	ref      voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct AutofillSetAddressesParams {
pub:
	addresses []json.Any @[json: 'addresses'; required]
	cb        EventFunc = unsafe { nil }  @[json: '-']
	wait      bool      = true       @[json: '-']
	ref       voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct BackgroundServiceStartObservingParams {
pub:
	service string    @[json: 'service'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BackgroundServiceStopObservingParams {
pub:
	service string    @[json: 'service'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BackgroundServiceSetRecordingParams {
pub:
	should_record bool      @[json: 'shouldRecord'; required]
	service       string    @[json: 'service'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BackgroundServiceClearEventsParams {
pub:
	service string    @[json: 'service'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BrowserSetPermissionParams {
pub:
	permission         map[string]json.Any @[json: 'permission'; required]
	setting            string              @[json: 'setting'; required]
	origin             ?string             @[json: 'origin']
	browser_context_id ?string             @[json: 'browserContextId']
	cb                 EventFunc = unsafe { nil }           @[json: '-']
	wait               bool      = true                @[json: '-']
	ref                voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct BrowserGrantPermissionsParams {
pub:
	permissions        []json.Any @[json: 'permissions'; required]
	origin             ?string    @[json: 'origin']
	browser_context_id ?string    @[json: 'browserContextId']
	cb                 EventFunc = unsafe { nil }  @[json: '-']
	wait               bool      = true       @[json: '-']
	ref                voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct BrowserResetPermissionsParams {
pub:
	browser_context_id ?string   @[json: 'browserContextId']
	cb                 EventFunc = unsafe { nil } @[json: '-']
	wait               bool      = true      @[json: '-']
	ref                voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BrowserSetDownloadBehaviorParams {
pub:
	behavior           string    @[json: 'behavior'; required]
	browser_context_id ?string   @[json: 'browserContextId']
	download_path      ?string   @[json: 'downloadPath']
	events_enabled     ?bool     @[json: 'eventsEnabled']
	cb                 EventFunc = unsafe { nil } @[json: '-']
	wait               bool      = true      @[json: '-']
	ref                voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BrowserCancelDownloadParams {
pub:
	guid               string    @[json: 'guid'; required]
	browser_context_id ?string   @[json: 'browserContextId']
	cb                 EventFunc = unsafe { nil } @[json: '-']
	wait               bool      = true      @[json: '-']
	ref                voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BrowserGetHistogramsParams {
pub:
	query ?string   @[json: 'query']
	delta ?bool     @[json: 'delta']
	cb    EventFunc = unsafe { nil } @[json: '-']
	wait  bool      = true      @[json: '-']
	ref   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BrowserGetHistogramParams {
pub:
	name  string    @[json: 'name'; required]
	delta ?bool     @[json: 'delta']
	cb    EventFunc = unsafe { nil } @[json: '-']
	wait  bool      = true      @[json: '-']
	ref   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BrowserGetWindowBoundsParams {
pub:
	window_id int       @[json: 'windowId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BrowserGetWindowForTargetParams {
pub:
	target_id ?string   @[json: 'targetId']
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BrowserSetWindowBoundsParams {
pub:
	window_id int                 @[json: 'windowId'; required]
	bounds    map[string]json.Any @[json: 'bounds'; required]
	cb        EventFunc = unsafe { nil }           @[json: '-']
	wait      bool      = true                @[json: '-']
	ref       voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct BrowserSetDockTileParams {
pub:
	badge_label ?string   @[json: 'badgeLabel']
	image       ?string   @[json: 'image']
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BrowserExecuteBrowserCommandParams {
pub:
	command_id string    @[json: 'commandId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BrowserAddPrivacySandboxEnrollmentOverrideParams {
pub:
	url  string    @[json: 'url'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSAddRuleParams {
pub:
	style_sheet_id                      string              @[json: 'styleSheetId'; required]
	rule_text                           string              @[json: 'ruleText'; required]
	location                            map[string]json.Any @[json: 'location'; required]
	node_for_property_syntax_validation ?int                @[json: 'nodeForPropertySyntaxValidation']
	cb                                  EventFunc = unsafe { nil }           @[json: '-']
	wait                                bool      = true                @[json: '-']
	ref                                 voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct CSSCollectClassNamesParams {
pub:
	style_sheet_id string    @[json: 'styleSheetId'; required]
	cb             EventFunc = unsafe { nil } @[json: '-']
	wait           bool      = true      @[json: '-']
	ref            voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSCreateStyleSheetParams {
pub:
	frame_id string    @[json: 'frameId'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSForcePseudoStateParams {
pub:
	node_id               int        @[json: 'nodeId'; required]
	forced_pseudo_classes []json.Any @[json: 'forcedPseudoClasses'; required]
	cb                    EventFunc = unsafe { nil }  @[json: '-']
	wait                  bool      = true       @[json: '-']
	ref                   voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct CSSForceStartingStyleParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	forced  bool      @[json: 'forced'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSGetBackgroundColorsParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSGetComputedStyleForNodeParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSResolveValuesParams {
pub:
	values            []json.Any @[json: 'values'; required]
	node_id           int        @[json: 'nodeId'; required]
	property_name     ?string    @[json: 'propertyName']
	pseudo_type       ?string    @[json: 'pseudoType']
	pseudo_identifier ?string    @[json: 'pseudoIdentifier']
	cb                EventFunc = unsafe { nil }  @[json: '-']
	wait              bool      = true       @[json: '-']
	ref               voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct CSSGetInlineStylesForNodeParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSGetAnimatedStylesForNodeParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSGetMatchedStylesForNodeParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSGetPlatformFontsForNodeParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSGetStyleSheetTextParams {
pub:
	style_sheet_id string    @[json: 'styleSheetId'; required]
	cb             EventFunc = unsafe { nil } @[json: '-']
	wait           bool      = true      @[json: '-']
	ref            voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSGetLayersForNodeParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSGetLocationForSelectorParams {
pub:
	style_sheet_id string    @[json: 'styleSheetId'; required]
	selector_text  string    @[json: 'selectorText'; required]
	cb             EventFunc = unsafe { nil } @[json: '-']
	wait           bool      = true      @[json: '-']
	ref            voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSTrackComputedStyleUpdatesForNodeParams {
pub:
	node_id ?int      @[json: 'nodeId']
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSTrackComputedStyleUpdatesParams {
pub:
	properties_to_track []json.Any @[json: 'propertiesToTrack'; required]
	cb                  EventFunc = unsafe { nil }  @[json: '-']
	wait                bool      = true       @[json: '-']
	ref                 voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct CSSSetEffectivePropertyValueForNodeParams {
pub:
	node_id       int       @[json: 'nodeId'; required]
	property_name string    @[json: 'propertyName'; required]
	value         string    @[json: 'value'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSSetPropertyRulePropertyNameParams {
pub:
	style_sheet_id string              @[json: 'styleSheetId'; required]
	range          map[string]json.Any @[json: 'range'; required]
	property_name  string              @[json: 'propertyName'; required]
	cb             EventFunc = unsafe { nil }           @[json: '-']
	wait           bool      = true                @[json: '-']
	ref            voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct CSSSetKeyframeKeyParams {
pub:
	style_sheet_id string              @[json: 'styleSheetId'; required]
	range          map[string]json.Any @[json: 'range'; required]
	key_text       string              @[json: 'keyText'; required]
	cb             EventFunc = unsafe { nil }           @[json: '-']
	wait           bool      = true                @[json: '-']
	ref            voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct CSSSetMediaTextParams {
pub:
	style_sheet_id string              @[json: 'styleSheetId'; required]
	range          map[string]json.Any @[json: 'range'; required]
	text           string              @[json: 'text'; required]
	cb             EventFunc = unsafe { nil }           @[json: '-']
	wait           bool      = true                @[json: '-']
	ref            voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct CSSSetContainerQueryTextParams {
pub:
	style_sheet_id string              @[json: 'styleSheetId'; required]
	range          map[string]json.Any @[json: 'range'; required]
	text           string              @[json: 'text'; required]
	cb             EventFunc = unsafe { nil }           @[json: '-']
	wait           bool      = true                @[json: '-']
	ref            voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct CSSSetSupportsTextParams {
pub:
	style_sheet_id string              @[json: 'styleSheetId'; required]
	range          map[string]json.Any @[json: 'range'; required]
	text           string              @[json: 'text'; required]
	cb             EventFunc = unsafe { nil }           @[json: '-']
	wait           bool      = true                @[json: '-']
	ref            voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct CSSSetScopeTextParams {
pub:
	style_sheet_id string              @[json: 'styleSheetId'; required]
	range          map[string]json.Any @[json: 'range'; required]
	text           string              @[json: 'text'; required]
	cb             EventFunc = unsafe { nil }           @[json: '-']
	wait           bool      = true                @[json: '-']
	ref            voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct CSSSetRuleSelectorParams {
pub:
	style_sheet_id string              @[json: 'styleSheetId'; required]
	range          map[string]json.Any @[json: 'range'; required]
	selector       string              @[json: 'selector'; required]
	cb             EventFunc = unsafe { nil }           @[json: '-']
	wait           bool      = true                @[json: '-']
	ref            voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct CSSSetStyleSheetTextParams {
pub:
	style_sheet_id string    @[json: 'styleSheetId'; required]
	text           string    @[json: 'text'; required]
	cb             EventFunc = unsafe { nil } @[json: '-']
	wait           bool      = true      @[json: '-']
	ref            voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CSSSetStyleTextsParams {
pub:
	edits                               []json.Any @[json: 'edits'; required]
	node_for_property_syntax_validation ?int       @[json: 'nodeForPropertySyntaxValidation']
	cb                                  EventFunc = unsafe { nil }  @[json: '-']
	wait                                bool      = true       @[json: '-']
	ref                                 voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct CSSSetLocalFontsEnabledParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CacheStorageDeleteCacheParams {
pub:
	cache_id string    @[json: 'cacheId'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CacheStorageDeleteEntryParams {
pub:
	cache_id string    @[json: 'cacheId'; required]
	request  string    @[json: 'request'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CacheStorageRequestCacheNamesParams {
pub:
	security_origin ?string              @[json: 'securityOrigin']
	storage_key     ?string              @[json: 'storageKey']
	storage_bucket  ?map[string]json.Any @[json: 'storageBucket']
	cb              EventFunc = unsafe { nil }            @[json: '-']
	wait            bool      = true                 @[json: '-']
	ref             voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct CacheStorageRequestCachedResponseParams {
pub:
	cache_id        string     @[json: 'cacheId'; required]
	request_url     string     @[json: 'requestURL'; required]
	request_headers []json.Any @[json: 'requestHeaders'; required]
	cb              EventFunc = unsafe { nil }  @[json: '-']
	wait            bool      = true       @[json: '-']
	ref             voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct CacheStorageRequestEntriesParams {
pub:
	cache_id    string    @[json: 'cacheId'; required]
	skip_count  ?int      @[json: 'skipCount']
	page_size   ?int      @[json: 'pageSize']
	path_filter ?string   @[json: 'pathFilter']
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CastEnableParams {
pub:
	presentation_url ?string   @[json: 'presentationUrl']
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CastSetSinkToUseParams {
pub:
	sink_name string    @[json: 'sinkName'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CastStartDesktopMirroringParams {
pub:
	sink_name string    @[json: 'sinkName'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CastStartTabMirroringParams {
pub:
	sink_name string    @[json: 'sinkName'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct CastStopCastingParams {
pub:
	sink_name string    @[json: 'sinkName'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMCollectClassNamesFromSubtreeParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMCopyToParams {
pub:
	node_id               int       @[json: 'nodeId'; required]
	target_node_id        int       @[json: 'targetNodeId'; required]
	insert_before_node_id ?int      @[json: 'insertBeforeNodeId']
	cb                    EventFunc = unsafe { nil } @[json: '-']
	wait                  bool      = true      @[json: '-']
	ref                   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMDescribeNodeParams {
pub:
	node_id         ?int      @[json: 'nodeId']
	backend_node_id ?int      @[json: 'backendNodeId']
	object_id       ?string   @[json: 'objectId']
	depth           ?int      @[json: 'depth']
	pierce          ?bool     @[json: 'pierce']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMScrollIntoViewIfNeededParams {
pub:
	node_id         ?int                 @[json: 'nodeId']
	backend_node_id ?int                 @[json: 'backendNodeId']
	object_id       ?string              @[json: 'objectId']
	rect            ?map[string]json.Any @[json: 'rect']
	cb              EventFunc = unsafe { nil }            @[json: '-']
	wait            bool      = true                 @[json: '-']
	ref             voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct DOMDiscardSearchResultsParams {
pub:
	search_id string    @[json: 'searchId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMEnableParams {
pub:
	include_whitespace ?string   @[json: 'includeWhitespace']
	cb                 EventFunc = unsafe { nil } @[json: '-']
	wait               bool      = true      @[json: '-']
	ref                voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMFocusParams {
pub:
	node_id         ?int      @[json: 'nodeId']
	backend_node_id ?int      @[json: 'backendNodeId']
	object_id       ?string   @[json: 'objectId']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetAttributesParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetBoxModelParams {
pub:
	node_id         ?int      @[json: 'nodeId']
	backend_node_id ?int      @[json: 'backendNodeId']
	object_id       ?string   @[json: 'objectId']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetContentQuadsParams {
pub:
	node_id         ?int      @[json: 'nodeId']
	backend_node_id ?int      @[json: 'backendNodeId']
	object_id       ?string   @[json: 'objectId']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetDocumentParams {
pub:
	depth  ?int      @[json: 'depth']
	pierce ?bool     @[json: 'pierce']
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetFlattenedDocumentParams {
pub:
	depth  ?int      @[json: 'depth']
	pierce ?bool     @[json: 'pierce']
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetNodesForSubtreeByStyleParams {
pub:
	node_id         int        @[json: 'nodeId'; required]
	computed_styles []json.Any @[json: 'computedStyles'; required]
	pierce          ?bool      @[json: 'pierce']
	cb              EventFunc = unsafe { nil }  @[json: '-']
	wait            bool      = true       @[json: '-']
	ref             voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct DOMGetNodeForLocationParams {
pub:
	x                             int       @[json: 'x'; required]
	y                             int       @[json: 'y'; required]
	include_user_agent_shadow_dom ?bool     @[json: 'includeUserAgentShadowDOM']
	ignore_pointer_events_none    ?bool     @[json: 'ignorePointerEventsNone']
	cb                            EventFunc = unsafe { nil } @[json: '-']
	wait                          bool      = true      @[json: '-']
	ref                           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetOuterHTMLParams {
pub:
	node_id         ?int      @[json: 'nodeId']
	backend_node_id ?int      @[json: 'backendNodeId']
	object_id       ?string   @[json: 'objectId']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetRelayoutBoundaryParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetSearchResultsParams {
pub:
	search_id  string    @[json: 'searchId'; required]
	from_index int       @[json: 'fromIndex'; required]
	to_index   int       @[json: 'toIndex'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMMoveToParams {
pub:
	node_id               int       @[json: 'nodeId'; required]
	target_node_id        int       @[json: 'targetNodeId'; required]
	insert_before_node_id ?int      @[json: 'insertBeforeNodeId']
	cb                    EventFunc = unsafe { nil } @[json: '-']
	wait                  bool      = true      @[json: '-']
	ref                   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMPerformSearchParams {
pub:
	query                         string    @[json: 'query'; required]
	include_user_agent_shadow_dom ?bool     @[json: 'includeUserAgentShadowDOM']
	cb                            EventFunc = unsafe { nil } @[json: '-']
	wait                          bool      = true      @[json: '-']
	ref                           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMPushNodeByPathToFrontendParams {
pub:
	path string    @[json: 'path'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMPushNodesByBackendIdsToFrontendParams {
pub:
	backend_node_ids []json.Any @[json: 'backendNodeIds'; required]
	cb               EventFunc = unsafe { nil }  @[json: '-']
	wait             bool      = true       @[json: '-']
	ref              voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct DOMQuerySelectorParams {
pub:
	node_id  int       @[json: 'nodeId'; required]
	selector string    @[json: 'selector'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMQuerySelectorAllParams {
pub:
	node_id  int       @[json: 'nodeId'; required]
	selector string    @[json: 'selector'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetElementByRelationParams {
pub:
	node_id  int       @[json: 'nodeId'; required]
	relation string    @[json: 'relation'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMRemoveAttributeParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	name    string    @[json: 'name'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMRemoveNodeParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMRequestChildNodesParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	depth   ?int      @[json: 'depth']
	pierce  ?bool     @[json: 'pierce']
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMRequestNodeParams {
pub:
	object_id string    @[json: 'objectId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMResolveNodeParams {
pub:
	node_id              ?int      @[json: 'nodeId']
	backend_node_id      ?int      @[json: 'backendNodeId']
	object_group         ?string   @[json: 'objectGroup']
	execution_context_id ?int      @[json: 'executionContextId']
	cb                   EventFunc = unsafe { nil } @[json: '-']
	wait                 bool      = true      @[json: '-']
	ref                  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMSetAttributeValueParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	name    string    @[json: 'name'; required]
	value   string    @[json: 'value'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMSetAttributesAsTextParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	text    string    @[json: 'text'; required]
	name    ?string   @[json: 'name']
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMSetFileInputFilesParams {
pub:
	files           []json.Any @[json: 'files'; required]
	node_id         ?int       @[json: 'nodeId']
	backend_node_id ?int       @[json: 'backendNodeId']
	object_id       ?string    @[json: 'objectId']
	cb              EventFunc = unsafe { nil }  @[json: '-']
	wait            bool      = true       @[json: '-']
	ref             voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct DOMSetNodeStackTracesEnabledParams {
pub:
	enable bool      @[json: 'enable'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetNodeStackTracesParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetFileInfoParams {
pub:
	object_id string    @[json: 'objectId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMSetInspectedNodeParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMSetNodeNameParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	name    string    @[json: 'name'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMSetNodeValueParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	value   string    @[json: 'value'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMSetOuterHTMLParams {
pub:
	node_id    int       @[json: 'nodeId'; required]
	outer_html string    @[json: 'outerHTML'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetFrameOwnerParams {
pub:
	frame_id string    @[json: 'frameId'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetContainerForNodeParams {
pub:
	node_id              int       @[json: 'nodeId'; required]
	container_name       ?string   @[json: 'containerName']
	physical_axes        ?string   @[json: 'physicalAxes']
	logical_axes         ?string   @[json: 'logicalAxes']
	queries_scroll_state ?bool     @[json: 'queriesScrollState']
	cb                   EventFunc = unsafe { nil } @[json: '-']
	wait                 bool      = true      @[json: '-']
	ref                  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetQueryingDescendantsForContainerParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMGetAnchorElementParams {
pub:
	node_id          int       @[json: 'nodeId'; required]
	anchor_specifier ?string   @[json: 'anchorSpecifier']
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMDebuggerGetEventListenersParams {
pub:
	object_id string    @[json: 'objectId'; required]
	depth     ?int      @[json: 'depth']
	pierce    ?bool     @[json: 'pierce']
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMDebuggerRemoveDOMBreakpointParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	type    string    @[json: 'type'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMDebuggerRemoveEventListenerBreakpointParams {
pub:
	event_name  string    @[json: 'eventName'; required]
	target_name ?string   @[json: 'targetName']
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMDebuggerRemoveInstrumentationBreakpointParams {
pub:
	event_name string    @[json: 'eventName'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMDebuggerRemoveXHRBreakpointParams {
pub:
	url  string    @[json: 'url'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMDebuggerSetBreakOnCSPViolationParams {
pub:
	violation_types []json.Any @[json: 'violationTypes'; required]
	cb              EventFunc = unsafe { nil }  @[json: '-']
	wait            bool      = true       @[json: '-']
	ref             voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct DOMDebuggerSetDOMBreakpointParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	type    string    @[json: 'type'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMDebuggerSetEventListenerBreakpointParams {
pub:
	event_name  string    @[json: 'eventName'; required]
	target_name ?string   @[json: 'targetName']
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMDebuggerSetInstrumentationBreakpointParams {
pub:
	event_name string    @[json: 'eventName'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMDebuggerSetXHRBreakpointParams {
pub:
	url  string    @[json: 'url'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EventBreakpointsSetInstrumentationBreakpointParams {
pub:
	event_name string    @[json: 'eventName'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EventBreakpointsRemoveInstrumentationBreakpointParams {
pub:
	event_name string    @[json: 'eventName'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DOMSnapshotGetSnapshotParams {
pub:
	computed_style_whitelist       []json.Any @[json: 'computedStyleWhitelist'; required]
	include_event_listeners        ?bool      @[json: 'includeEventListeners']
	include_paint_order            ?bool      @[json: 'includePaintOrder']
	include_user_agent_shadow_tree ?bool      @[json: 'includeUserAgentShadowTree']
	cb                             EventFunc = unsafe { nil }  @[json: '-']
	wait                           bool      = true       @[json: '-']
	ref                            voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct DOMSnapshotCaptureSnapshotParams {
pub:
	computed_styles                   []json.Any @[json: 'computedStyles'; required]
	include_paint_order               ?bool      @[json: 'includePaintOrder']
	include_dom_rects                 ?bool      @[json: 'includeDOMRects']
	include_blended_background_colors ?bool      @[json: 'includeBlendedBackgroundColors']
	include_text_color_opacities      ?bool      @[json: 'includeTextColorOpacities']
	cb                                EventFunc = unsafe { nil }  @[json: '-']
	wait                              bool      = true       @[json: '-']
	ref                               voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct DOMStorageClearParams {
pub:
	storage_id map[string]json.Any @[json: 'storageId'; required]
	cb         EventFunc = unsafe { nil }           @[json: '-']
	wait       bool      = true                @[json: '-']
	ref        voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DOMStorageGetDOMStorageItemsParams {
pub:
	storage_id map[string]json.Any @[json: 'storageId'; required]
	cb         EventFunc = unsafe { nil }           @[json: '-']
	wait       bool      = true                @[json: '-']
	ref        voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DOMStorageRemoveDOMStorageItemParams {
pub:
	storage_id map[string]json.Any @[json: 'storageId'; required]
	key        string              @[json: 'key'; required]
	cb         EventFunc = unsafe { nil }           @[json: '-']
	wait       bool      = true                @[json: '-']
	ref        voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DOMStorageSetDOMStorageItemParams {
pub:
	storage_id map[string]json.Any @[json: 'storageId'; required]
	key        string              @[json: 'key'; required]
	value      string              @[json: 'value'; required]
	cb         EventFunc = unsafe { nil }           @[json: '-']
	wait       bool      = true                @[json: '-']
	ref        voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DatabaseExecuteSQLParams {
pub:
	database_id string    @[json: 'databaseId'; required]
	query       string    @[json: 'query'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DatabaseGetDatabaseTableNamesParams {
pub:
	database_id string    @[json: 'databaseId'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DeviceOrientationSetDeviceOrientationOverrideParams {
pub:
	alpha f64       @[json: 'alpha'; required]
	beta  f64       @[json: 'beta'; required]
	gamma f64       @[json: 'gamma'; required]
	cb    EventFunc = unsafe { nil } @[json: '-']
	wait  bool      = true      @[json: '-']
	ref   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetFocusEmulationEnabledParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetAutoDarkModeOverrideParams {
pub:
	enabled ?bool     @[json: 'enabled']
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetCPUThrottlingRateParams {
pub:
	rate f64       @[json: 'rate'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetDefaultBackgroundColorOverrideParams {
pub:
	color ?map[string]json.Any @[json: 'color']
	cb    EventFunc = unsafe { nil }            @[json: '-']
	wait  bool      = true                 @[json: '-']
	ref   voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct EmulationSetDeviceMetricsOverrideParams {
pub:
	width                 int                  @[json: 'width'; required]
	height                int                  @[json: 'height'; required]
	device_scale_factor   f64                  @[json: 'deviceScaleFactor'; required]
	mobile                bool                 @[json: 'mobile'; required]
	scale                 ?f64                 @[json: 'scale']
	screen_width          ?int                 @[json: 'screenWidth']
	screen_height         ?int                 @[json: 'screenHeight']
	positionx             ?int                 @[json: 'positionX']
	positiony             ?int                 @[json: 'positionY']
	dont_set_visible_size ?bool                @[json: 'dontSetVisibleSize']
	screen_orientation    ?map[string]json.Any @[json: 'screenOrientation']
	viewport              ?map[string]json.Any @[json: 'viewport']
	display_feature       ?map[string]json.Any @[json: 'displayFeature']
	device_posture        ?map[string]json.Any @[json: 'devicePosture']
	cb                    EventFunc = unsafe { nil }            @[json: '-']
	wait                  bool      = true                 @[json: '-']
	ref                   voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct EmulationSetDevicePostureOverrideParams {
pub:
	posture map[string]json.Any @[json: 'posture'; required]
	cb      EventFunc = unsafe { nil }           @[json: '-']
	wait    bool      = true                @[json: '-']
	ref     voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct EmulationSetScrollbarsHiddenParams {
pub:
	hidden bool      @[json: 'hidden'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetDocumentCookieDisabledParams {
pub:
	disabled bool      @[json: 'disabled'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetEmitTouchEventsForMouseParams {
pub:
	enabled       bool      @[json: 'enabled'; required]
	configuration ?string   @[json: 'configuration']
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetEmulatedMediaParams {
pub:
	media    ?string     @[json: 'media']
	features ?[]json.Any @[json: 'features']
	cb       EventFunc = unsafe { nil }   @[json: '-']
	wait     bool      = true        @[json: '-']
	ref      voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct EmulationSetEmulatedVisionDeficiencyParams {
pub:
	type string    @[json: 'type'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetGeolocationOverrideParams {
pub:
	latitude  ?f64      @[json: 'latitude']
	longitude ?f64      @[json: 'longitude']
	accuracy  ?f64      @[json: 'accuracy']
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationGetOverriddenSensorInformationParams {
pub:
	type string    @[json: 'type'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetSensorOverrideEnabledParams {
pub:
	enabled  bool                 @[json: 'enabled'; required]
	type     string               @[json: 'type'; required]
	metadata ?map[string]json.Any @[json: 'metadata']
	cb       EventFunc = unsafe { nil }            @[json: '-']
	wait     bool      = true                 @[json: '-']
	ref      voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct EmulationSetSensorOverrideReadingsParams {
pub:
	type    string              @[json: 'type'; required]
	reading map[string]json.Any @[json: 'reading'; required]
	cb      EventFunc = unsafe { nil }           @[json: '-']
	wait    bool      = true                @[json: '-']
	ref     voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct EmulationSetPressureSourceOverrideEnabledParams {
pub:
	enabled  bool                 @[json: 'enabled'; required]
	source   string               @[json: 'source'; required]
	metadata ?map[string]json.Any @[json: 'metadata']
	cb       EventFunc = unsafe { nil }            @[json: '-']
	wait     bool      = true                 @[json: '-']
	ref      voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct EmulationSetPressureStateOverrideParams {
pub:
	source string    @[json: 'source'; required]
	state  string    @[json: 'state'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetIdleOverrideParams {
pub:
	is_user_active     bool      @[json: 'isUserActive'; required]
	is_screen_unlocked bool      @[json: 'isScreenUnlocked'; required]
	cb                 EventFunc = unsafe { nil } @[json: '-']
	wait               bool      = true      @[json: '-']
	ref                voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetNavigatorOverridesParams {
pub:
	platform string    @[json: 'platform'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetPageScaleFactorParams {
pub:
	page_scale_factor f64       @[json: 'pageScaleFactor'; required]
	cb                EventFunc = unsafe { nil } @[json: '-']
	wait              bool      = true      @[json: '-']
	ref               voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetScriptExecutionDisabledParams {
pub:
	value bool      @[json: 'value'; required]
	cb    EventFunc = unsafe { nil } @[json: '-']
	wait  bool      = true      @[json: '-']
	ref   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetTouchEmulationEnabledParams {
pub:
	enabled          bool      @[json: 'enabled'; required]
	max_touch_points ?int      @[json: 'maxTouchPoints']
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetVirtualTimePolicyParams {
pub:
	policy                                 string    @[json: 'policy'; required]
	budget                                 ?f64      @[json: 'budget']
	max_virtual_time_task_starvation_count ?int      @[json: 'maxVirtualTimeTaskStarvationCount']
	initial_virtual_time                   ?f64      @[json: 'initialVirtualTime']
	cb                                     EventFunc = unsafe { nil } @[json: '-']
	wait                                   bool      = true      @[json: '-']
	ref                                    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetLocaleOverrideParams {
pub:
	locale ?string   @[json: 'locale']
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetTimezoneOverrideParams {
pub:
	timezone_id string    @[json: 'timezoneId'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetVisibleSizeParams {
pub:
	width  int       @[json: 'width'; required]
	height int       @[json: 'height'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetDisabledImageTypesParams {
pub:
	image_types []json.Any @[json: 'imageTypes'; required]
	cb          EventFunc = unsafe { nil }  @[json: '-']
	wait        bool      = true       @[json: '-']
	ref         voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct EmulationSetHardwareConcurrencyOverrideParams {
pub:
	hardware_concurrency int       @[json: 'hardwareConcurrency'; required]
	cb                   EventFunc = unsafe { nil } @[json: '-']
	wait                 bool      = true      @[json: '-']
	ref                  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct EmulationSetUserAgentOverrideParams {
pub:
	user_agent          string               @[json: 'userAgent'; required]
	accept_language     ?string              @[json: 'acceptLanguage']
	platform            ?string              @[json: 'platform']
	user_agent_metadata ?map[string]json.Any @[json: 'userAgentMetadata']
	cb                  EventFunc = unsafe { nil }            @[json: '-']
	wait                bool      = true                 @[json: '-']
	ref                 voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct EmulationSetAutomationOverrideParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct HeadlessExperimentalBeginFrameParams {
pub:
	frame_time_ticks   ?f64                 @[json: 'frameTimeTicks']
	interval           ?f64                 @[json: 'interval']
	no_display_updates ?bool                @[json: 'noDisplayUpdates']
	screenshot         ?map[string]json.Any @[json: 'screenshot']
	cb                 EventFunc = unsafe { nil }            @[json: '-']
	wait               bool      = true                 @[json: '-']
	ref                voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct IOCloseParams {
pub:
	handle string    @[json: 'handle'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct IOReadParams {
pub:
	handle string    @[json: 'handle'; required]
	offset ?int      @[json: 'offset']
	size   ?int      @[json: 'size']
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct IOResolveBlobParams {
pub:
	object_id string    @[json: 'objectId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct FileSystemGetDirectoryParams {
pub:
	bucket_file_system_locator map[string]json.Any @[json: 'bucketFileSystemLocator'; required]
	cb                         EventFunc = unsafe { nil }           @[json: '-']
	wait                       bool      = true                @[json: '-']
	ref                        voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct IndexedDBClearObjectStoreParams {
pub:
	security_origin   ?string              @[json: 'securityOrigin']
	storage_key       ?string              @[json: 'storageKey']
	storage_bucket    ?map[string]json.Any @[json: 'storageBucket']
	database_name     string               @[json: 'databaseName'; required]
	object_store_name string               @[json: 'objectStoreName'; required]
	cb                EventFunc = unsafe { nil }            @[json: '-']
	wait              bool      = true                 @[json: '-']
	ref               voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct IndexedDBDeleteDatabaseParams {
pub:
	security_origin ?string              @[json: 'securityOrigin']
	storage_key     ?string              @[json: 'storageKey']
	storage_bucket  ?map[string]json.Any @[json: 'storageBucket']
	database_name   string               @[json: 'databaseName'; required]
	cb              EventFunc = unsafe { nil }            @[json: '-']
	wait            bool      = true                 @[json: '-']
	ref             voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct IndexedDBDeleteObjectStoreEntriesParams {
pub:
	security_origin   ?string              @[json: 'securityOrigin']
	storage_key       ?string              @[json: 'storageKey']
	storage_bucket    ?map[string]json.Any @[json: 'storageBucket']
	database_name     string               @[json: 'databaseName'; required]
	object_store_name string               @[json: 'objectStoreName'; required]
	key_range         map[string]json.Any  @[json: 'keyRange'; required]
	cb                EventFunc = unsafe { nil }            @[json: '-']
	wait              bool      = true                 @[json: '-']
	ref               voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct IndexedDBRequestDataParams {
pub:
	security_origin   ?string              @[json: 'securityOrigin']
	storage_key       ?string              @[json: 'storageKey']
	storage_bucket    ?map[string]json.Any @[json: 'storageBucket']
	database_name     string               @[json: 'databaseName'; required]
	object_store_name string               @[json: 'objectStoreName'; required]
	index_name        string               @[json: 'indexName'; required]
	skip_count        int                  @[json: 'skipCount'; required]
	page_size         int                  @[json: 'pageSize'; required]
	key_range         ?map[string]json.Any @[json: 'keyRange']
	cb                EventFunc = unsafe { nil }            @[json: '-']
	wait              bool      = true                 @[json: '-']
	ref               voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct IndexedDBGetMetadataParams {
pub:
	security_origin   ?string              @[json: 'securityOrigin']
	storage_key       ?string              @[json: 'storageKey']
	storage_bucket    ?map[string]json.Any @[json: 'storageBucket']
	database_name     string               @[json: 'databaseName'; required]
	object_store_name string               @[json: 'objectStoreName'; required]
	cb                EventFunc = unsafe { nil }            @[json: '-']
	wait              bool      = true                 @[json: '-']
	ref               voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct IndexedDBRequestDatabaseParams {
pub:
	security_origin ?string              @[json: 'securityOrigin']
	storage_key     ?string              @[json: 'storageKey']
	storage_bucket  ?map[string]json.Any @[json: 'storageBucket']
	database_name   string               @[json: 'databaseName'; required]
	cb              EventFunc = unsafe { nil }            @[json: '-']
	wait            bool      = true                 @[json: '-']
	ref             voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct IndexedDBRequestDatabaseNamesParams {
pub:
	security_origin ?string              @[json: 'securityOrigin']
	storage_key     ?string              @[json: 'storageKey']
	storage_bucket  ?map[string]json.Any @[json: 'storageBucket']
	cb              EventFunc = unsafe { nil }            @[json: '-']
	wait            bool      = true                 @[json: '-']
	ref             voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct InputDispatchDragEventParams {
pub:
	type      string              @[json: 'type'; required]
	x         f64                 @[json: 'x'; required]
	y         f64                 @[json: 'y'; required]
	data      map[string]json.Any @[json: 'data'; required]
	modifiers ?int                @[json: 'modifiers']
	cb        EventFunc = unsafe { nil }           @[json: '-']
	wait      bool      = true                @[json: '-']
	ref       voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct InputDispatchKeyEventParams {
pub:
	type                     string      @[json: 'type'; required]
	modifiers                ?int        @[json: 'modifiers']
	timestamp                ?f64        @[json: 'timestamp']
	text                     ?string     @[json: 'text']
	unmodified_text          ?string     @[json: 'unmodifiedText']
	key_identifier           ?string     @[json: 'keyIdentifier']
	code                     ?string     @[json: 'code']
	key                      ?string     @[json: 'key']
	windows_virtual_key_code ?int        @[json: 'windowsVirtualKeyCode']
	native_virtual_key_code  ?int        @[json: 'nativeVirtualKeyCode']
	auto_repeat              ?bool       @[json: 'autoRepeat']
	is_keypad                ?bool       @[json: 'isKeypad']
	is_system_key            ?bool       @[json: 'isSystemKey']
	location                 ?int        @[json: 'location']
	commands                 ?[]json.Any @[json: 'commands']
	cb                       EventFunc = unsafe { nil }   @[json: '-']
	wait                     bool      = true        @[json: '-']
	ref                      voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct InputInsertTextParams {
pub:
	text string    @[json: 'text'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct InputImeSetCompositionParams {
pub:
	text              string    @[json: 'text'; required]
	selection_start   int       @[json: 'selectionStart'; required]
	selection_end     int       @[json: 'selectionEnd'; required]
	replacement_start ?int      @[json: 'replacementStart']
	replacement_end   ?int      @[json: 'replacementEnd']
	cb                EventFunc = unsafe { nil } @[json: '-']
	wait              bool      = true      @[json: '-']
	ref               voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct InputDispatchMouseEventParams {
pub:
	type                string    @[json: 'type'; required]
	x                   f64       @[json: 'x'; required]
	y                   f64       @[json: 'y'; required]
	modifiers           ?int      @[json: 'modifiers']
	timestamp           ?f64      @[json: 'timestamp']
	button              ?string   @[json: 'button']
	buttons             ?int      @[json: 'buttons']
	click_count         ?int      @[json: 'clickCount']
	force               ?f64      @[json: 'force']
	tangential_pressure ?f64      @[json: 'tangentialPressure']
	tiltx               ?f64      @[json: 'tiltX']
	tilty               ?f64      @[json: 'tiltY']
	twist               ?int      @[json: 'twist']
	deltax              ?f64      @[json: 'deltaX']
	deltay              ?f64      @[json: 'deltaY']
	pointer_type        ?string   @[json: 'pointerType']
	cb                  EventFunc = unsafe { nil } @[json: '-']
	wait                bool      = true      @[json: '-']
	ref                 voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct InputDispatchTouchEventParams {
pub:
	type         string     @[json: 'type'; required]
	touch_points []json.Any @[json: 'touchPoints'; required]
	modifiers    ?int       @[json: 'modifiers']
	timestamp    ?f64       @[json: 'timestamp']
	cb           EventFunc = unsafe { nil }  @[json: '-']
	wait         bool      = true       @[json: '-']
	ref          voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct InputEmulateTouchFromMouseEventParams {
pub:
	type        string    @[json: 'type'; required]
	x           int       @[json: 'x'; required]
	y           int       @[json: 'y'; required]
	button      string    @[json: 'button'; required]
	timestamp   ?f64      @[json: 'timestamp']
	deltax      ?f64      @[json: 'deltaX']
	deltay      ?f64      @[json: 'deltaY']
	modifiers   ?int      @[json: 'modifiers']
	click_count ?int      @[json: 'clickCount']
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct InputSetIgnoreInputEventsParams {
pub:
	ignore bool      @[json: 'ignore'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct InputSetInterceptDragsParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct InputSynthesizePinchGestureParams {
pub:
	x                   f64       @[json: 'x'; required]
	y                   f64       @[json: 'y'; required]
	scale_factor        f64       @[json: 'scaleFactor'; required]
	relative_speed      ?int      @[json: 'relativeSpeed']
	gesture_source_type ?string   @[json: 'gestureSourceType']
	cb                  EventFunc = unsafe { nil } @[json: '-']
	wait                bool      = true      @[json: '-']
	ref                 voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct InputSynthesizeScrollGestureParams {
pub:
	x                       f64       @[json: 'x'; required]
	y                       f64       @[json: 'y'; required]
	x_distance              ?f64      @[json: 'xDistance']
	y_distance              ?f64      @[json: 'yDistance']
	x_overscroll            ?f64      @[json: 'xOverscroll']
	y_overscroll            ?f64      @[json: 'yOverscroll']
	prevent_fling           ?bool     @[json: 'preventFling']
	speed                   ?int      @[json: 'speed']
	gesture_source_type     ?string   @[json: 'gestureSourceType']
	repeat_count            ?int      @[json: 'repeatCount']
	repeat_delay_ms         ?int      @[json: 'repeatDelayMs']
	interaction_marker_name ?string   @[json: 'interactionMarkerName']
	cb                      EventFunc = unsafe { nil } @[json: '-']
	wait                    bool      = true      @[json: '-']
	ref                     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct InputSynthesizeTapGestureParams {
pub:
	x                   f64       @[json: 'x'; required]
	y                   f64       @[json: 'y'; required]
	duration            ?int      @[json: 'duration']
	tap_count           ?int      @[json: 'tapCount']
	gesture_source_type ?string   @[json: 'gestureSourceType']
	cb                  EventFunc = unsafe { nil } @[json: '-']
	wait                bool      = true      @[json: '-']
	ref                 voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct LayerTreeCompositingReasonsParams {
pub:
	layer_id string    @[json: 'layerId'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct LayerTreeLoadSnapshotParams {
pub:
	tiles []json.Any @[json: 'tiles'; required]
	cb    EventFunc = unsafe { nil }  @[json: '-']
	wait  bool      = true       @[json: '-']
	ref   voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct LayerTreeMakeSnapshotParams {
pub:
	layer_id string    @[json: 'layerId'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct LayerTreeProfileSnapshotParams {
pub:
	snapshot_id      string               @[json: 'snapshotId'; required]
	min_repeat_count ?int                 @[json: 'minRepeatCount']
	min_duration     ?f64                 @[json: 'minDuration']
	clip_rect        ?map[string]json.Any @[json: 'clipRect']
	cb               EventFunc = unsafe { nil }            @[json: '-']
	wait             bool      = true                 @[json: '-']
	ref              voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct LayerTreeReleaseSnapshotParams {
pub:
	snapshot_id string    @[json: 'snapshotId'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct LayerTreeReplaySnapshotParams {
pub:
	snapshot_id string    @[json: 'snapshotId'; required]
	from_step   ?int      @[json: 'fromStep']
	to_step     ?int      @[json: 'toStep']
	scale       ?f64      @[json: 'scale']
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct LayerTreeSnapshotCommandLogParams {
pub:
	snapshot_id string    @[json: 'snapshotId'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct LogStartViolationsReportParams {
pub:
	config []json.Any @[json: 'config'; required]
	cb     EventFunc = unsafe { nil }  @[json: '-']
	wait   bool      = true       @[json: '-']
	ref    voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct MemorySetPressureNotificationsSuppressedParams {
pub:
	suppressed bool      @[json: 'suppressed'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct MemorySimulatePressureNotificationParams {
pub:
	level string    @[json: 'level'; required]
	cb    EventFunc = unsafe { nil } @[json: '-']
	wait  bool      = true      @[json: '-']
	ref   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct MemoryStartSamplingParams {
pub:
	sampling_interval   ?int      @[json: 'samplingInterval']
	suppress_randomness ?bool     @[json: 'suppressRandomness']
	cb                  EventFunc = unsafe { nil } @[json: '-']
	wait                bool      = true      @[json: '-']
	ref                 voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkSetAcceptedEncodingsParams {
pub:
	encodings []json.Any @[json: 'encodings'; required]
	cb        EventFunc = unsafe { nil }  @[json: '-']
	wait      bool      = true       @[json: '-']
	ref       voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct NetworkContinueInterceptedRequestParams {
pub:
	interception_id         string               @[json: 'interceptionId'; required]
	error_reason            ?string              @[json: 'errorReason']
	raw_response            ?string              @[json: 'rawResponse']
	url                     ?string              @[json: 'url']
	method                  ?string              @[json: 'method']
	post_data               ?string              @[json: 'postData']
	headers                 ?map[string]json.Any @[json: 'headers']
	auth_challenge_response ?map[string]json.Any @[json: 'authChallengeResponse']
	cb                      EventFunc = unsafe { nil }            @[json: '-']
	wait                    bool      = true                 @[json: '-']
	ref                     voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct NetworkDeleteCookiesParams {
pub:
	name          string               @[json: 'name'; required]
	url           ?string              @[json: 'url']
	domain        ?string              @[json: 'domain']
	path          ?string              @[json: 'path']
	partition_key ?map[string]json.Any @[json: 'partitionKey']
	cb            EventFunc = unsafe { nil }            @[json: '-']
	wait          bool      = true                 @[json: '-']
	ref           voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct NetworkEmulateNetworkConditionsParams {
pub:
	offline             bool      @[json: 'offline'; required]
	latency             f64       @[json: 'latency'; required]
	download_throughput f64       @[json: 'downloadThroughput'; required]
	upload_throughput   f64       @[json: 'uploadThroughput'; required]
	connection_type     ?string   @[json: 'connectionType']
	packet_loss         ?f64      @[json: 'packetLoss']
	packet_queue_length ?int      @[json: 'packetQueueLength']
	packet_reordering   ?bool     @[json: 'packetReordering']
	cb                  EventFunc = unsafe { nil } @[json: '-']
	wait                bool      = true      @[json: '-']
	ref                 voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkEnableParams {
pub:
	max_total_buffer_size    ?int      @[json: 'maxTotalBufferSize']
	max_resource_buffer_size ?int      @[json: 'maxResourceBufferSize']
	max_post_data_size       ?int      @[json: 'maxPostDataSize']
	cb                       EventFunc = unsafe { nil } @[json: '-']
	wait                     bool      = true      @[json: '-']
	ref                      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkGetCertificateParams {
pub:
	origin string    @[json: 'origin'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkGetCookiesParams {
pub:
	urls ?[]json.Any @[json: 'urls']
	cb   EventFunc = unsafe { nil }   @[json: '-']
	wait bool      = true        @[json: '-']
	ref  voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct NetworkGetResponseBodyParams {
pub:
	request_id string    @[json: 'requestId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkGetRequestPostDataParams {
pub:
	request_id string    @[json: 'requestId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkGetResponseBodyForInterceptionParams {
pub:
	interception_id string    @[json: 'interceptionId'; required]
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkTakeResponseBodyForInterceptionAsStreamParams {
pub:
	interception_id string    @[json: 'interceptionId'; required]
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkReplayXHRParams {
pub:
	request_id string    @[json: 'requestId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkSearchInResponseBodyParams {
pub:
	request_id     string    @[json: 'requestId'; required]
	query          string    @[json: 'query'; required]
	case_sensitive ?bool     @[json: 'caseSensitive']
	is_regex       ?bool     @[json: 'isRegex']
	cb             EventFunc = unsafe { nil } @[json: '-']
	wait           bool      = true      @[json: '-']
	ref            voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkSetBlockedURLsParams {
pub:
	urls []json.Any @[json: 'urls'; required]
	cb   EventFunc = unsafe { nil }  @[json: '-']
	wait bool      = true       @[json: '-']
	ref  voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct NetworkSetBypassServiceWorkerParams {
pub:
	bypass bool      @[json: 'bypass'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkSetCacheDisabledParams {
pub:
	cache_disabled bool      @[json: 'cacheDisabled'; required]
	cb             EventFunc = unsafe { nil } @[json: '-']
	wait           bool      = true      @[json: '-']
	ref            voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkSetCookieParams {
pub:
	name          string               @[json: 'name'; required]
	value         string               @[json: 'value'; required]
	url           ?string              @[json: 'url']
	domain        ?string              @[json: 'domain']
	path          ?string              @[json: 'path']
	secure        ?bool                @[json: 'secure']
	http_only     ?bool                @[json: 'httpOnly']
	same_site     ?string              @[json: 'sameSite']
	expires       ?f64                 @[json: 'expires']
	priority      ?string              @[json: 'priority']
	same_party    ?bool                @[json: 'sameParty']
	source_scheme ?string              @[json: 'sourceScheme']
	source_port   ?int                 @[json: 'sourcePort']
	partition_key ?map[string]json.Any @[json: 'partitionKey']
	cb            EventFunc = unsafe { nil }            @[json: '-']
	wait          bool      = true                 @[json: '-']
	ref           voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct NetworkSetCookiesParams {
pub:
	cookies []json.Any @[json: 'cookies'; required]
	cb      EventFunc = unsafe { nil }  @[json: '-']
	wait    bool      = true       @[json: '-']
	ref     voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct NetworkSetExtraHTTPHeadersParams {
pub:
	headers map[string]json.Any @[json: 'headers'; required]
	cb      EventFunc = unsafe { nil }           @[json: '-']
	wait    bool      = true                @[json: '-']
	ref     voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct NetworkSetAttachDebugStackParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkSetRequestInterceptionParams {
pub:
	patterns []json.Any @[json: 'patterns'; required]
	cb       EventFunc = unsafe { nil }  @[json: '-']
	wait     bool      = true       @[json: '-']
	ref      voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct NetworkSetUserAgentOverrideParams {
pub:
	user_agent          string               @[json: 'userAgent'; required]
	accept_language     ?string              @[json: 'acceptLanguage']
	platform            ?string              @[json: 'platform']
	user_agent_metadata ?map[string]json.Any @[json: 'userAgentMetadata']
	cb                  EventFunc = unsafe { nil }            @[json: '-']
	wait                bool      = true                 @[json: '-']
	ref                 voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct NetworkStreamResourceContentParams {
pub:
	request_id string    @[json: 'requestId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkGetSecurityIsolationStatusParams {
pub:
	frame_id ?string   @[json: 'frameId']
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkEnableReportingApiParams {
pub:
	enable bool      @[json: 'enable'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct NetworkLoadNetworkResourceParams {
pub:
	frame_id ?string             @[json: 'frameId']
	url      string              @[json: 'url'; required]
	options  map[string]json.Any @[json: 'options'; required]
	cb       EventFunc = unsafe { nil }           @[json: '-']
	wait     bool      = true                @[json: '-']
	ref      voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct OverlayGetHighlightObjectForTestParams {
pub:
	node_id                 int       @[json: 'nodeId'; required]
	include_distance        ?bool     @[json: 'includeDistance']
	include_style           ?bool     @[json: 'includeStyle']
	color_format            ?string   @[json: 'colorFormat']
	show_accessibility_info ?bool     @[json: 'showAccessibilityInfo']
	cb                      EventFunc = unsafe { nil } @[json: '-']
	wait                    bool      = true      @[json: '-']
	ref                     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlayGetGridHighlightObjectsForTestParams {
pub:
	node_ids []json.Any @[json: 'nodeIds'; required]
	cb       EventFunc = unsafe { nil }  @[json: '-']
	wait     bool      = true       @[json: '-']
	ref      voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct OverlayGetSourceOrderHighlightObjectForTestParams {
pub:
	node_id int       @[json: 'nodeId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlayHighlightFrameParams {
pub:
	frame_id              string               @[json: 'frameId'; required]
	content_color         ?map[string]json.Any @[json: 'contentColor']
	content_outline_color ?map[string]json.Any @[json: 'contentOutlineColor']
	cb                    EventFunc = unsafe { nil }            @[json: '-']
	wait                  bool      = true                 @[json: '-']
	ref                   voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct OverlayHighlightNodeParams {
pub:
	highlight_config map[string]json.Any @[json: 'highlightConfig'; required]
	node_id          ?int                @[json: 'nodeId']
	backend_node_id  ?int                @[json: 'backendNodeId']
	object_id        ?string             @[json: 'objectId']
	selector         ?string             @[json: 'selector']
	cb               EventFunc = unsafe { nil }           @[json: '-']
	wait             bool      = true                @[json: '-']
	ref              voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct OverlayHighlightQuadParams {
pub:
	quad          []json.Any           @[json: 'quad'; required]
	color         ?map[string]json.Any @[json: 'color']
	outline_color ?map[string]json.Any @[json: 'outlineColor']
	cb            EventFunc = unsafe { nil }            @[json: '-']
	wait          bool      = true                 @[json: '-']
	ref           voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct OverlayHighlightRectParams {
pub:
	x             int                  @[json: 'x'; required]
	y             int                  @[json: 'y'; required]
	width         int                  @[json: 'width'; required]
	height        int                  @[json: 'height'; required]
	color         ?map[string]json.Any @[json: 'color']
	outline_color ?map[string]json.Any @[json: 'outlineColor']
	cb            EventFunc = unsafe { nil }            @[json: '-']
	wait          bool      = true                 @[json: '-']
	ref           voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct OverlayHighlightSourceOrderParams {
pub:
	source_order_config map[string]json.Any @[json: 'sourceOrderConfig'; required]
	node_id             ?int                @[json: 'nodeId']
	backend_node_id     ?int                @[json: 'backendNodeId']
	object_id           ?string             @[json: 'objectId']
	cb                  EventFunc = unsafe { nil }           @[json: '-']
	wait                bool      = true                @[json: '-']
	ref                 voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct OverlaySetInspectModeParams {
pub:
	mode             string               @[json: 'mode'; required]
	highlight_config ?map[string]json.Any @[json: 'highlightConfig']
	cb               EventFunc = unsafe { nil }            @[json: '-']
	wait             bool      = true                 @[json: '-']
	ref              voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct OverlaySetShowAdHighlightsParams {
pub:
	show bool      @[json: 'show'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlaySetPausedInDebuggerMessageParams {
pub:
	message ?string   @[json: 'message']
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlaySetShowDebugBordersParams {
pub:
	show bool      @[json: 'show'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlaySetShowFPSCounterParams {
pub:
	show bool      @[json: 'show'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlaySetShowGridOverlaysParams {
pub:
	grid_node_highlight_configs []json.Any @[json: 'gridNodeHighlightConfigs'; required]
	cb                          EventFunc = unsafe { nil }  @[json: '-']
	wait                        bool      = true       @[json: '-']
	ref                         voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct OverlaySetShowFlexOverlaysParams {
pub:
	flex_node_highlight_configs []json.Any @[json: 'flexNodeHighlightConfigs'; required]
	cb                          EventFunc = unsafe { nil }  @[json: '-']
	wait                        bool      = true       @[json: '-']
	ref                         voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct OverlaySetShowScrollSnapOverlaysParams {
pub:
	scroll_snap_highlight_configs []json.Any @[json: 'scrollSnapHighlightConfigs'; required]
	cb                            EventFunc = unsafe { nil }  @[json: '-']
	wait                          bool      = true       @[json: '-']
	ref                           voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct OverlaySetShowContainerQueryOverlaysParams {
pub:
	container_query_highlight_configs []json.Any @[json: 'containerQueryHighlightConfigs'; required]
	cb                                EventFunc = unsafe { nil }  @[json: '-']
	wait                              bool      = true       @[json: '-']
	ref                               voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct OverlaySetShowPaintRectsParams {
pub:
	result bool      @[json: 'result'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlaySetShowLayoutShiftRegionsParams {
pub:
	result bool      @[json: 'result'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlaySetShowScrollBottleneckRectsParams {
pub:
	show bool      @[json: 'show'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlaySetShowHitTestBordersParams {
pub:
	show bool      @[json: 'show'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlaySetShowWebVitalsParams {
pub:
	show bool      @[json: 'show'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlaySetShowViewportSizeOnResizeParams {
pub:
	show bool      @[json: 'show'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct OverlaySetShowHingeParams {
pub:
	hinge_config ?map[string]json.Any @[json: 'hingeConfig']
	cb           EventFunc = unsafe { nil }            @[json: '-']
	wait         bool      = true                 @[json: '-']
	ref          voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct OverlaySetShowIsolatedElementsParams {
pub:
	isolated_element_highlight_configs []json.Any @[json: 'isolatedElementHighlightConfigs'; required]
	cb                                 EventFunc = unsafe { nil }  @[json: '-']
	wait                               bool      = true       @[json: '-']
	ref                                voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct OverlaySetShowWindowControlsOverlayParams {
pub:
	window_controls_overlay_config ?map[string]json.Any @[json: 'windowControlsOverlayConfig']
	cb                             EventFunc = unsafe { nil }            @[json: '-']
	wait                           bool      = true                 @[json: '-']
	ref                            voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct PageAddScriptToEvaluateOnLoadParams {
pub:
	script_source string    @[json: 'scriptSource'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageAddScriptToEvaluateOnNewDocumentParams {
pub:
	source                   string    @[json: 'source'; required]
	world_name               ?string   @[json: 'worldName']
	include_command_line_api ?bool     @[json: 'includeCommandLineAPI']
	run_immediately          ?bool     @[json: 'runImmediately']
	cb                       EventFunc = unsafe { nil } @[json: '-']
	wait                     bool      = true      @[json: '-']
	ref                      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageCaptureScreenshotParams {
pub:
	format                  ?string              @[json: 'format']
	quality                 ?int                 @[json: 'quality']
	clip                    ?map[string]json.Any @[json: 'clip']
	from_surface            ?bool                @[json: 'fromSurface']
	capture_beyond_viewport ?bool                @[json: 'captureBeyondViewport']
	optimize_for_speed      ?bool                @[json: 'optimizeForSpeed']
	cb                      EventFunc = unsafe { nil }            @[json: '-']
	wait                    bool      = true                 @[json: '-']
	ref                     voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct PageCaptureSnapshotParams {
pub:
	format ?string   @[json: 'format']
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageCreateIsolatedWorldParams {
pub:
	frame_id              string    @[json: 'frameId'; required]
	world_name            ?string   @[json: 'worldName']
	grant_univeral_access ?bool     @[json: 'grantUniveralAccess']
	cb                    EventFunc = unsafe { nil } @[json: '-']
	wait                  bool      = true      @[json: '-']
	ref                   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageDeleteCookieParams {
pub:
	cookie_name string    @[json: 'cookieName'; required]
	url         string    @[json: 'url'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageGetAppManifestParams {
pub:
	manifest_id ?string   @[json: 'manifestId']
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageGetAdScriptIdParams {
pub:
	frame_id string    @[json: 'frameId'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageGetResourceContentParams {
pub:
	frame_id string    @[json: 'frameId'; required]
	url      string    @[json: 'url'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageHandleJavaScriptDialogParams {
pub:
	accept      bool      @[json: 'accept'; required]
	prompt_text ?string   @[json: 'promptText']
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageNavigateParams {
pub:
	url             string    @[json: 'url'; required]
	referrer        ?string   @[json: 'referrer']
	transition_type ?string   @[json: 'transitionType']
	frame_id        ?string   @[json: 'frameId']
	referrer_policy ?string   @[json: 'referrerPolicy']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageNavigateToHistoryEntryParams {
pub:
	entry_id int       @[json: 'entryId'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PagePrintToPDFParams {
pub:
	landscape                 ?bool     @[json: 'landscape']
	display_header_footer     ?bool     @[json: 'displayHeaderFooter']
	print_background          ?bool     @[json: 'printBackground']
	scale                     ?f64      @[json: 'scale']
	paper_width               ?f64      @[json: 'paperWidth']
	paper_height              ?f64      @[json: 'paperHeight']
	margin_top                ?f64      @[json: 'marginTop']
	margin_bottom             ?f64      @[json: 'marginBottom']
	margin_left               ?f64      @[json: 'marginLeft']
	margin_right              ?f64      @[json: 'marginRight']
	page_ranges               ?string   @[json: 'pageRanges']
	header_template           ?string   @[json: 'headerTemplate']
	footer_template           ?string   @[json: 'footerTemplate']
	prefer_css_page_size      ?bool     @[json: 'preferCSSPageSize']
	transfer_mode             ?string   @[json: 'transferMode']
	generate_tagged_pdf       ?bool     @[json: 'generateTaggedPDF']
	generate_document_outline ?bool     @[json: 'generateDocumentOutline']
	cb                        EventFunc = unsafe { nil } @[json: '-']
	wait                      bool      = true      @[json: '-']
	ref                       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageReloadParams {
pub:
	ignore_cache               ?bool     @[json: 'ignoreCache']
	script_to_evaluate_on_load ?string   @[json: 'scriptToEvaluateOnLoad']
	loader_id                  ?string   @[json: 'loaderId']
	cb                         EventFunc = unsafe { nil } @[json: '-']
	wait                       bool      = true      @[json: '-']
	ref                        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageRemoveScriptToEvaluateOnLoadParams {
pub:
	identifier string    @[json: 'identifier'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageRemoveScriptToEvaluateOnNewDocumentParams {
pub:
	identifier string    @[json: 'identifier'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageScreencastFrameAckParams {
pub:
	session_id int       @[json: 'sessionId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSearchInResourceParams {
pub:
	frame_id       string    @[json: 'frameId'; required]
	url            string    @[json: 'url'; required]
	query          string    @[json: 'query'; required]
	case_sensitive ?bool     @[json: 'caseSensitive']
	is_regex       ?bool     @[json: 'isRegex']
	cb             EventFunc = unsafe { nil } @[json: '-']
	wait           bool      = true      @[json: '-']
	ref            voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetAdBlockingEnabledParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetBypassCSPParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageGetPermissionsPolicyStateParams {
pub:
	frame_id string    @[json: 'frameId'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageGetOriginTrialsParams {
pub:
	frame_id string    @[json: 'frameId'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetDeviceMetricsOverrideParams {
pub:
	width                 int                  @[json: 'width'; required]
	height                int                  @[json: 'height'; required]
	device_scale_factor   f64                  @[json: 'deviceScaleFactor'; required]
	mobile                bool                 @[json: 'mobile'; required]
	scale                 ?f64                 @[json: 'scale']
	screen_width          ?int                 @[json: 'screenWidth']
	screen_height         ?int                 @[json: 'screenHeight']
	positionx             ?int                 @[json: 'positionX']
	positiony             ?int                 @[json: 'positionY']
	dont_set_visible_size ?bool                @[json: 'dontSetVisibleSize']
	screen_orientation    ?map[string]json.Any @[json: 'screenOrientation']
	viewport              ?map[string]json.Any @[json: 'viewport']
	cb                    EventFunc = unsafe { nil }            @[json: '-']
	wait                  bool      = true                 @[json: '-']
	ref                   voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct PageSetDeviceOrientationOverrideParams {
pub:
	alpha f64       @[json: 'alpha'; required]
	beta  f64       @[json: 'beta'; required]
	gamma f64       @[json: 'gamma'; required]
	cb    EventFunc = unsafe { nil } @[json: '-']
	wait  bool      = true      @[json: '-']
	ref   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetFontFamiliesParams {
pub:
	font_families map[string]json.Any @[json: 'fontFamilies'; required]
	for_scripts   ?[]json.Any         @[json: 'forScripts']
	cb            EventFunc = unsafe { nil }           @[json: '-']
	wait          bool      = true                @[json: '-']
	ref           voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct PageSetFontSizesParams {
pub:
	font_sizes map[string]json.Any @[json: 'fontSizes'; required]
	cb         EventFunc = unsafe { nil }           @[json: '-']
	wait       bool      = true                @[json: '-']
	ref        voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct PageSetDocumentContentParams {
pub:
	frame_id string    @[json: 'frameId'; required]
	html     string    @[json: 'html'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetDownloadBehaviorParams {
pub:
	behavior      string    @[json: 'behavior'; required]
	download_path ?string   @[json: 'downloadPath']
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetGeolocationOverrideParams {
pub:
	latitude  ?f64      @[json: 'latitude']
	longitude ?f64      @[json: 'longitude']
	accuracy  ?f64      @[json: 'accuracy']
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetLifecycleEventsEnabledParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetTouchEmulationEnabledParams {
pub:
	enabled       bool      @[json: 'enabled'; required]
	configuration ?string   @[json: 'configuration']
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageStartScreencastParams {
pub:
	format          ?string   @[json: 'format']
	quality         ?int      @[json: 'quality']
	max_width       ?int      @[json: 'maxWidth']
	max_height      ?int      @[json: 'maxHeight']
	every_nth_frame ?int      @[json: 'everyNthFrame']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetWebLifecycleStateParams {
pub:
	state string    @[json: 'state'; required]
	cb    EventFunc = unsafe { nil } @[json: '-']
	wait  bool      = true      @[json: '-']
	ref   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageProduceCompilationCacheParams {
pub:
	scripts []json.Any @[json: 'scripts'; required]
	cb      EventFunc = unsafe { nil }  @[json: '-']
	wait    bool      = true       @[json: '-']
	ref     voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct PageAddCompilationCacheParams {
pub:
	url  string    @[json: 'url'; required]
	data string    @[json: 'data'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetSPCTransactionModeParams {
pub:
	mode string    @[json: 'mode'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetRPHRegistrationModeParams {
pub:
	mode string    @[json: 'mode'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageGenerateTestReportParams {
pub:
	message string    @[json: 'message'; required]
	group   ?string   @[json: 'group']
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetInterceptFileChooserDialogParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PageSetPrerenderingAllowedParams {
pub:
	is_allowed bool      @[json: 'isAllowed'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PerformanceEnableParams {
pub:
	time_domain ?string   @[json: 'timeDomain']
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PerformanceSetTimeDomainParams {
pub:
	time_domain string    @[json: 'timeDomain'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PerformanceTimelineEnableParams {
pub:
	event_types []json.Any @[json: 'eventTypes'; required]
	cb          EventFunc = unsafe { nil }  @[json: '-']
	wait        bool      = true       @[json: '-']
	ref         voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct SecuritySetIgnoreCertificateErrorsParams {
pub:
	ignore bool      @[json: 'ignore'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct SecurityHandleCertificateErrorParams {
pub:
	event_id int       @[json: 'eventId'; required]
	action   string    @[json: 'action'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct SecuritySetOverrideCertificateErrorsParams {
pub:
	override bool      @[json: 'override'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ServiceWorkerDeliverPushMessageParams {
pub:
	origin          string    @[json: 'origin'; required]
	registration_id string    @[json: 'registrationId'; required]
	data            string    @[json: 'data'; required]
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ServiceWorkerDispatchSyncEventParams {
pub:
	origin          string    @[json: 'origin'; required]
	registration_id string    @[json: 'registrationId'; required]
	tag             string    @[json: 'tag'; required]
	last_chance     bool      @[json: 'lastChance'; required]
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ServiceWorkerDispatchPeriodicSyncEventParams {
pub:
	origin          string    @[json: 'origin'; required]
	registration_id string    @[json: 'registrationId'; required]
	tag             string    @[json: 'tag'; required]
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ServiceWorkerInspectWorkerParams {
pub:
	version_id string    @[json: 'versionId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ServiceWorkerSetForceUpdateOnPageLoadParams {
pub:
	force_update_on_page_load bool      @[json: 'forceUpdateOnPageLoad'; required]
	cb                        EventFunc = unsafe { nil } @[json: '-']
	wait                      bool      = true      @[json: '-']
	ref                       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ServiceWorkerSkipWaitingParams {
pub:
	scope_url string    @[json: 'scopeURL'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ServiceWorkerStartWorkerParams {
pub:
	scope_url string    @[json: 'scopeURL'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ServiceWorkerStopWorkerParams {
pub:
	version_id string    @[json: 'versionId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ServiceWorkerUnregisterParams {
pub:
	scope_url string    @[json: 'scopeURL'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ServiceWorkerUpdateRegistrationParams {
pub:
	scope_url string    @[json: 'scopeURL'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageGetStorageKeyForFrameParams {
pub:
	frame_id string    @[json: 'frameId'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageClearDataForOriginParams {
pub:
	origin        string    @[json: 'origin'; required]
	storage_types string    @[json: 'storageTypes'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageClearDataForStorageKeyParams {
pub:
	storage_key   string    @[json: 'storageKey'; required]
	storage_types string    @[json: 'storageTypes'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageGetCookiesParams {
pub:
	browser_context_id ?string   @[json: 'browserContextId']
	cb                 EventFunc = unsafe { nil } @[json: '-']
	wait               bool      = true      @[json: '-']
	ref                voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageSetCookiesParams {
pub:
	cookies            []json.Any @[json: 'cookies'; required]
	browser_context_id ?string    @[json: 'browserContextId']
	cb                 EventFunc = unsafe { nil }  @[json: '-']
	wait               bool      = true       @[json: '-']
	ref                voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct StorageClearCookiesParams {
pub:
	browser_context_id ?string   @[json: 'browserContextId']
	cb                 EventFunc = unsafe { nil } @[json: '-']
	wait               bool      = true      @[json: '-']
	ref                voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageGetUsageAndQuotaParams {
pub:
	origin string    @[json: 'origin'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageOverrideQuotaForOriginParams {
pub:
	origin     string    @[json: 'origin'; required]
	quota_size ?f64      @[json: 'quotaSize']
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageTrackCacheStorageForOriginParams {
pub:
	origin string    @[json: 'origin'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageTrackCacheStorageForStorageKeyParams {
pub:
	storage_key string    @[json: 'storageKey'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageTrackIndexedDBForOriginParams {
pub:
	origin string    @[json: 'origin'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageTrackIndexedDBForStorageKeyParams {
pub:
	storage_key string    @[json: 'storageKey'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageUntrackCacheStorageForOriginParams {
pub:
	origin string    @[json: 'origin'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageUntrackCacheStorageForStorageKeyParams {
pub:
	storage_key string    @[json: 'storageKey'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageUntrackIndexedDBForOriginParams {
pub:
	origin string    @[json: 'origin'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageUntrackIndexedDBForStorageKeyParams {
pub:
	storage_key string    @[json: 'storageKey'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageClearTrustTokensParams {
pub:
	issuer_origin string    @[json: 'issuerOrigin'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageGetInterestGroupDetailsParams {
pub:
	owner_origin string    @[json: 'ownerOrigin'; required]
	name         string    @[json: 'name'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageSetInterestGroupTrackingParams {
pub:
	enable bool      @[json: 'enable'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageSetInterestGroupAuctionTrackingParams {
pub:
	enable bool      @[json: 'enable'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageGetSharedStorageMetadataParams {
pub:
	owner_origin string    @[json: 'ownerOrigin'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageGetSharedStorageEntriesParams {
pub:
	owner_origin string    @[json: 'ownerOrigin'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageSetSharedStorageEntryParams {
pub:
	owner_origin      string    @[json: 'ownerOrigin'; required]
	key               string    @[json: 'key'; required]
	value             string    @[json: 'value'; required]
	ignore_if_present ?bool     @[json: 'ignoreIfPresent']
	cb                EventFunc = unsafe { nil } @[json: '-']
	wait              bool      = true      @[json: '-']
	ref               voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageDeleteSharedStorageEntryParams {
pub:
	owner_origin string    @[json: 'ownerOrigin'; required]
	key          string    @[json: 'key'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageClearSharedStorageEntriesParams {
pub:
	owner_origin string    @[json: 'ownerOrigin'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageResetSharedStorageBudgetParams {
pub:
	owner_origin string    @[json: 'ownerOrigin'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageSetSharedStorageTrackingParams {
pub:
	enable bool      @[json: 'enable'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageSetStorageBucketTrackingParams {
pub:
	storage_key string    @[json: 'storageKey'; required]
	enable      bool      @[json: 'enable'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageDeleteStorageBucketParams {
pub:
	bucket map[string]json.Any @[json: 'bucket'; required]
	cb     EventFunc = unsafe { nil }           @[json: '-']
	wait   bool      = true                @[json: '-']
	ref    voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct StorageSetAttributionReportingLocalTestingModeParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct StorageSetAttributionReportingTrackingParams {
pub:
	enable bool      @[json: 'enable'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct SystemInfoGetFeatureStateParams {
pub:
	feature_state string    @[json: 'featureState'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TargetActivateTargetParams {
pub:
	target_id string    @[json: 'targetId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TargetAttachToTargetParams {
pub:
	target_id string    @[json: 'targetId'; required]
	flatten   ?bool     @[json: 'flatten']
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TargetCloseTargetParams {
pub:
	target_id string    @[json: 'targetId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TargetExposeDevToolsProtocolParams {
pub:
	target_id    string    @[json: 'targetId'; required]
	binding_name ?string   @[json: 'bindingName']
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TargetCreateBrowserContextParams {
pub:
	dispose_on_detach                     ?bool       @[json: 'disposeOnDetach']
	proxy_server                          ?string     @[json: 'proxyServer']
	proxy_bypass_list                     ?string     @[json: 'proxyBypassList']
	origins_with_universal_network_access ?[]json.Any @[json: 'originsWithUniversalNetworkAccess']
	cb                                    EventFunc = unsafe { nil }   @[json: '-']
	wait                                  bool      = true        @[json: '-']
	ref                                   voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct TargetCreateTargetParams {
pub:
	url                        string    @[json: 'url'; required]
	width                      ?int      @[json: 'width']
	height                     ?int      @[json: 'height']
	browser_context_id         ?string   @[json: 'browserContextId']
	enable_begin_frame_control ?bool     @[json: 'enableBeginFrameControl']
	new_window                 ?bool     @[json: 'newWindow']
	background                 ?bool     @[json: 'background']
	for_tab                    ?bool     @[json: 'forTab']
	cb                         EventFunc = unsafe { nil } @[json: '-']
	wait                       bool      = true      @[json: '-']
	ref                        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TargetDetachFromTargetParams {
pub:
	session_id ?string   @[json: 'sessionId']
	target_id  ?string   @[json: 'targetId']
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TargetDisposeBrowserContextParams {
pub:
	browser_context_id string    @[json: 'browserContextId'; required]
	cb                 EventFunc = unsafe { nil } @[json: '-']
	wait               bool      = true      @[json: '-']
	ref                voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TargetGetTargetInfoParams {
pub:
	target_id ?string   @[json: 'targetId']
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TargetGetTargetsParams {
pub:
	filter ?[]json.Any @[json: 'filter']
	cb     EventFunc = unsafe { nil }   @[json: '-']
	wait   bool      = true        @[json: '-']
	ref    voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct TargetSendMessageToTargetParams {
pub:
	message    string    @[json: 'message'; required]
	session_id ?string   @[json: 'sessionId']
	target_id  ?string   @[json: 'targetId']
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TargetSetAutoAttachParams {
pub:
	auto_attach                bool        @[json: 'autoAttach'; required]
	wait_for_debugger_on_start bool        @[json: 'waitForDebuggerOnStart'; required]
	flatten                    ?bool       @[json: 'flatten']
	filter                     ?[]json.Any @[json: 'filter']
	cb                         EventFunc = unsafe { nil }   @[json: '-']
	wait                       bool      = true        @[json: '-']
	ref                        voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct TargetAutoAttachRelatedParams {
pub:
	target_id                  string      @[json: 'targetId'; required]
	wait_for_debugger_on_start bool        @[json: 'waitForDebuggerOnStart'; required]
	filter                     ?[]json.Any @[json: 'filter']
	cb                         EventFunc = unsafe { nil }   @[json: '-']
	wait                       bool      = true        @[json: '-']
	ref                        voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct TargetSetDiscoverTargetsParams {
pub:
	discover bool        @[json: 'discover'; required]
	filter   ?[]json.Any @[json: 'filter']
	cb       EventFunc = unsafe { nil }   @[json: '-']
	wait     bool      = true        @[json: '-']
	ref      voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct TargetSetRemoteLocationsParams {
pub:
	locations []json.Any @[json: 'locations'; required]
	cb        EventFunc = unsafe { nil }  @[json: '-']
	wait      bool      = true       @[json: '-']
	ref       voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct TetheringBindParams {
pub:
	port int       @[json: 'port'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TetheringUnbindParams {
pub:
	port int       @[json: 'port'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TracingRecordClockSyncMarkerParams {
pub:
	sync_id string    @[json: 'syncId'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TracingRequestMemoryDumpParams {
pub:
	deterministic   ?bool     @[json: 'deterministic']
	level_of_detail ?string   @[json: 'levelOfDetail']
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct TracingStartParams {
pub:
	categories                      ?string              @[json: 'categories']
	options                         ?string              @[json: 'options']
	buffer_usage_reporting_interval ?f64                 @[json: 'bufferUsageReportingInterval']
	transfer_mode                   ?string              @[json: 'transferMode']
	stream_format                   ?string              @[json: 'streamFormat']
	stream_compression              ?string              @[json: 'streamCompression']
	trace_config                    ?map[string]json.Any @[json: 'traceConfig']
	perfetto_config                 ?string              @[json: 'perfettoConfig']
	tracing_backend                 ?string              @[json: 'tracingBackend']
	cb                              EventFunc = unsafe { nil }            @[json: '-']
	wait                            bool      = true                 @[json: '-']
	ref                             voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct FetchEnableParams {
pub:
	patterns             ?[]json.Any @[json: 'patterns']
	handle_auth_requests ?bool       @[json: 'handleAuthRequests']
	cb                   EventFunc = unsafe { nil }   @[json: '-']
	wait                 bool      = true        @[json: '-']
	ref                  voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct FetchFailRequestParams {
pub:
	request_id   string    @[json: 'requestId'; required]
	error_reason string    @[json: 'errorReason'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct FetchFulfillRequestParams {
pub:
	request_id              string      @[json: 'requestId'; required]
	response_code           int         @[json: 'responseCode'; required]
	response_headers        ?[]json.Any @[json: 'responseHeaders']
	binary_response_headers ?string     @[json: 'binaryResponseHeaders']
	body                    ?string     @[json: 'body']
	response_phrase         ?string     @[json: 'responsePhrase']
	cb                      EventFunc = unsafe { nil }   @[json: '-']
	wait                    bool      = true        @[json: '-']
	ref                     voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct FetchContinueRequestParams {
pub:
	request_id         string      @[json: 'requestId'; required]
	url                ?string     @[json: 'url']
	method             ?string     @[json: 'method']
	post_data          ?string     @[json: 'postData']
	headers            ?[]json.Any @[json: 'headers']
	intercept_response ?bool       @[json: 'interceptResponse']
	cb                 EventFunc = unsafe { nil }   @[json: '-']
	wait               bool      = true        @[json: '-']
	ref                voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct FetchContinueWithAuthParams {
pub:
	request_id              string              @[json: 'requestId'; required]
	auth_challenge_response map[string]json.Any @[json: 'authChallengeResponse'; required]
	cb                      EventFunc = unsafe { nil }           @[json: '-']
	wait                    bool      = true                @[json: '-']
	ref                     voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct FetchContinueResponseParams {
pub:
	request_id              string      @[json: 'requestId'; required]
	response_code           ?int        @[json: 'responseCode']
	response_phrase         ?string     @[json: 'responsePhrase']
	response_headers        ?[]json.Any @[json: 'responseHeaders']
	binary_response_headers ?string     @[json: 'binaryResponseHeaders']
	cb                      EventFunc = unsafe { nil }   @[json: '-']
	wait                    bool      = true        @[json: '-']
	ref                     voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct FetchGetResponseBodyParams {
pub:
	request_id string    @[json: 'requestId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct FetchTakeResponseBodyAsStreamParams {
pub:
	request_id string    @[json: 'requestId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAudioGetRealtimeDataParams {
pub:
	context_id string    @[json: 'contextId'; required]
	cb         EventFunc = unsafe { nil } @[json: '-']
	wait       bool      = true      @[json: '-']
	ref        voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAuthnEnableParams {
pub:
	enableui ?bool     @[json: 'enableUI']
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAuthnAddVirtualAuthenticatorParams {
pub:
	options map[string]json.Any @[json: 'options'; required]
	cb      EventFunc = unsafe { nil }           @[json: '-']
	wait    bool      = true                @[json: '-']
	ref     voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct WebAuthnSetResponseOverrideBitsParams {
pub:
	authenticator_id   string    @[json: 'authenticatorId'; required]
	is_bogus_signature ?bool     @[json: 'isBogusSignature']
	is_baduv           ?bool     @[json: 'isBadUV']
	is_badup           ?bool     @[json: 'isBadUP']
	cb                 EventFunc = unsafe { nil } @[json: '-']
	wait               bool      = true      @[json: '-']
	ref                voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAuthnRemoveVirtualAuthenticatorParams {
pub:
	authenticator_id string    @[json: 'authenticatorId'; required]
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAuthnAddCredentialParams {
pub:
	authenticator_id string              @[json: 'authenticatorId'; required]
	credential       map[string]json.Any @[json: 'credential'; required]
	cb               EventFunc = unsafe { nil }           @[json: '-']
	wait             bool      = true                @[json: '-']
	ref              voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct WebAuthnGetCredentialParams {
pub:
	authenticator_id string    @[json: 'authenticatorId'; required]
	credential_id    string    @[json: 'credentialId'; required]
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAuthnGetCredentialsParams {
pub:
	authenticator_id string    @[json: 'authenticatorId'; required]
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAuthnRemoveCredentialParams {
pub:
	authenticator_id string    @[json: 'authenticatorId'; required]
	credential_id    string    @[json: 'credentialId'; required]
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAuthnClearCredentialsParams {
pub:
	authenticator_id string    @[json: 'authenticatorId'; required]
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAuthnSetUserVerifiedParams {
pub:
	authenticator_id string    @[json: 'authenticatorId'; required]
	is_user_verified bool      @[json: 'isUserVerified'; required]
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAuthnSetAutomaticPresenceSimulationParams {
pub:
	authenticator_id string    @[json: 'authenticatorId'; required]
	enabled          bool      @[json: 'enabled'; required]
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct WebAuthnSetCredentialPropertiesParams {
pub:
	authenticator_id   string    @[json: 'authenticatorId'; required]
	credential_id      string    @[json: 'credentialId'; required]
	backup_eligibility ?bool     @[json: 'backupEligibility']
	backup_state       ?bool     @[json: 'backupState']
	cb                 EventFunc = unsafe { nil } @[json: '-']
	wait               bool      = true      @[json: '-']
	ref                voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DeviceAccessSelectPromptParams {
pub:
	id        string    @[json: 'id'; required]
	device_id string    @[json: 'deviceId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DeviceAccessCancelPromptParams {
pub:
	id   string    @[json: 'id'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct FedCmEnableParams {
pub:
	disable_rejection_delay ?bool     @[json: 'disableRejectionDelay']
	cb                      EventFunc = unsafe { nil } @[json: '-']
	wait                    bool      = true      @[json: '-']
	ref                     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct FedCmSelectAccountParams {
pub:
	dialog_id     string    @[json: 'dialogId'; required]
	account_index int       @[json: 'accountIndex'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct FedCmClickDialogButtonParams {
pub:
	dialog_id     string    @[json: 'dialogId'; required]
	dialog_button string    @[json: 'dialogButton'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct FedCmOpenUrlParams {
pub:
	dialog_id        string    @[json: 'dialogId'; required]
	account_index    int       @[json: 'accountIndex'; required]
	account_url_type string    @[json: 'accountUrlType'; required]
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct FedCmDismissDialogParams {
pub:
	dialog_id        string    @[json: 'dialogId'; required]
	trigger_cooldown ?bool     @[json: 'triggerCooldown']
	cb               EventFunc = unsafe { nil } @[json: '-']
	wait             bool      = true      @[json: '-']
	ref              voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PWAGetOsAppStateParams {
pub:
	manifest_id string    @[json: 'manifestId'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PWAInstallParams {
pub:
	manifest_id               string    @[json: 'manifestId'; required]
	install_url_or_bundle_url ?string   @[json: 'installUrlOrBundleUrl']
	cb                        EventFunc = unsafe { nil } @[json: '-']
	wait                      bool      = true      @[json: '-']
	ref                       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PWAUninstallParams {
pub:
	manifest_id string    @[json: 'manifestId'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PWALaunchParams {
pub:
	manifest_id string    @[json: 'manifestId'; required]
	url         ?string   @[json: 'url']
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PWALaunchFilesInAppParams {
pub:
	manifest_id string     @[json: 'manifestId'; required]
	files       []json.Any @[json: 'files'; required]
	cb          EventFunc = unsafe { nil }  @[json: '-']
	wait        bool      = true       @[json: '-']
	ref         voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct PWAOpenCurrentPageInAppParams {
pub:
	manifest_id string    @[json: 'manifestId'; required]
	cb          EventFunc = unsafe { nil } @[json: '-']
	wait        bool      = true      @[json: '-']
	ref         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct PWAChangeAppUserSettingsParams {
pub:
	manifest_id    string    @[json: 'manifestId'; required]
	link_capturing ?bool     @[json: 'linkCapturing']
	display_mode   ?string   @[json: 'displayMode']
	cb             EventFunc = unsafe { nil } @[json: '-']
	wait           bool      = true      @[json: '-']
	ref            voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BluetoothEmulationEnableParams {
pub:
	state string    @[json: 'state'; required]
	cb    EventFunc = unsafe { nil } @[json: '-']
	wait  bool      = true      @[json: '-']
	ref   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct BluetoothEmulationSimulatePreconnectedPeripheralParams {
pub:
	address             string     @[json: 'address'; required]
	name                string     @[json: 'name'; required]
	manufacturer_data   []json.Any @[json: 'manufacturerData'; required]
	known_service_uuids []json.Any @[json: 'knownServiceUuids'; required]
	cb                  EventFunc = unsafe { nil }  @[json: '-']
	wait                bool      = true       @[json: '-']
	ref                 voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct BluetoothEmulationSimulateAdvertisementParams {
pub:
	entry map[string]json.Any @[json: 'entry'; required]
	cb    EventFunc = unsafe { nil }           @[json: '-']
	wait  bool      = true                @[json: '-']
	ref   voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DebuggerContinueToLocationParams {
pub:
	location           map[string]json.Any @[json: 'location'; required]
	target_call_frames ?string             @[json: 'targetCallFrames']
	cb                 EventFunc = unsafe { nil }           @[json: '-']
	wait               bool      = true                @[json: '-']
	ref                voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DebuggerEnableParams {
pub:
	max_scripts_cache_size ?f64      @[json: 'maxScriptsCacheSize']
	cb                     EventFunc = unsafe { nil } @[json: '-']
	wait                   bool      = true      @[json: '-']
	ref                    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerEvaluateOnCallFrameParams {
pub:
	call_frame_id            string    @[json: 'callFrameId'; required]
	expression               string    @[json: 'expression'; required]
	object_group             ?string   @[json: 'objectGroup']
	include_command_line_api ?bool     @[json: 'includeCommandLineAPI']
	silent                   ?bool     @[json: 'silent']
	return_by_value          ?bool     @[json: 'returnByValue']
	generate_preview         ?bool     @[json: 'generatePreview']
	throw_on_side_effect     ?bool     @[json: 'throwOnSideEffect']
	timeout                  ?f64      @[json: 'timeout']
	cb                       EventFunc = unsafe { nil } @[json: '-']
	wait                     bool      = true      @[json: '-']
	ref                      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerGetPossibleBreakpointsParams {
pub:
	start                map[string]json.Any  @[json: 'start'; required]
	end                  ?map[string]json.Any @[json: 'end']
	restrict_to_function ?bool                @[json: 'restrictToFunction']
	cb                   EventFunc = unsafe { nil }            @[json: '-']
	wait                 bool      = true                 @[json: '-']
	ref                  voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct DebuggerGetScriptSourceParams {
pub:
	script_id string    @[json: 'scriptId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerDisassembleWasmModuleParams {
pub:
	script_id string    @[json: 'scriptId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerNextWasmDisassemblyChunkParams {
pub:
	stream_id string    @[json: 'streamId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerGetWasmBytecodeParams {
pub:
	script_id string    @[json: 'scriptId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerGetStackTraceParams {
pub:
	stack_trace_id map[string]json.Any @[json: 'stackTraceId'; required]
	cb             EventFunc = unsafe { nil }           @[json: '-']
	wait           bool      = true                @[json: '-']
	ref            voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DebuggerPauseOnAsyncCallParams {
pub:
	parent_stack_trace_id map[string]json.Any @[json: 'parentStackTraceId'; required]
	cb                    EventFunc = unsafe { nil }           @[json: '-']
	wait                  bool      = true                @[json: '-']
	ref                   voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DebuggerRemoveBreakpointParams {
pub:
	breakpoint_id string    @[json: 'breakpointId'; required]
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerRestartFrameParams {
pub:
	call_frame_id string    @[json: 'callFrameId'; required]
	mode          ?string   @[json: 'mode']
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerResumeParams {
pub:
	terminate_on_resume ?bool     @[json: 'terminateOnResume']
	cb                  EventFunc = unsafe { nil } @[json: '-']
	wait                bool      = true      @[json: '-']
	ref                 voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerSearchInContentParams {
pub:
	script_id      string    @[json: 'scriptId'; required]
	query          string    @[json: 'query'; required]
	case_sensitive ?bool     @[json: 'caseSensitive']
	is_regex       ?bool     @[json: 'isRegex']
	cb             EventFunc = unsafe { nil } @[json: '-']
	wait           bool      = true      @[json: '-']
	ref            voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerSetAsyncCallStackDepthParams {
pub:
	max_depth int       @[json: 'maxDepth'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerSetBlackboxExecutionContextsParams {
pub:
	unique_ids []json.Any @[json: 'uniqueIds'; required]
	cb         EventFunc = unsafe { nil }  @[json: '-']
	wait       bool      = true       @[json: '-']
	ref        voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct DebuggerSetBlackboxPatternsParams {
pub:
	patterns       []json.Any @[json: 'patterns'; required]
	skip_anonymous ?bool      @[json: 'skipAnonymous']
	cb             EventFunc = unsafe { nil }  @[json: '-']
	wait           bool      = true       @[json: '-']
	ref            voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct DebuggerSetBlackboxedRangesParams {
pub:
	script_id string     @[json: 'scriptId'; required]
	positions []json.Any @[json: 'positions'; required]
	cb        EventFunc = unsafe { nil }  @[json: '-']
	wait      bool      = true       @[json: '-']
	ref       voidptr   = unsafe { nil }    @[json: '-']
}

@[params]
pub struct DebuggerSetBreakpointParams {
pub:
	location  map[string]json.Any @[json: 'location'; required]
	condition ?string             @[json: 'condition']
	cb        EventFunc = unsafe { nil }           @[json: '-']
	wait      bool      = true                @[json: '-']
	ref       voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DebuggerSetInstrumentationBreakpointParams {
pub:
	instrumentation string    @[json: 'instrumentation'; required]
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerSetBreakpointByUrlParams {
pub:
	line_number   int       @[json: 'lineNumber'; required]
	url           ?string   @[json: 'url']
	url_regex     ?string   @[json: 'urlRegex']
	script_hash   ?string   @[json: 'scriptHash']
	column_number ?int      @[json: 'columnNumber']
	condition     ?string   @[json: 'condition']
	cb            EventFunc = unsafe { nil } @[json: '-']
	wait          bool      = true      @[json: '-']
	ref           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerSetBreakpointOnFunctionCallParams {
pub:
	object_id string    @[json: 'objectId'; required]
	condition ?string   @[json: 'condition']
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerSetBreakpointsActiveParams {
pub:
	active bool      @[json: 'active'; required]
	cb     EventFunc = unsafe { nil } @[json: '-']
	wait   bool      = true      @[json: '-']
	ref    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerSetPauseOnExceptionsParams {
pub:
	state string    @[json: 'state'; required]
	cb    EventFunc = unsafe { nil } @[json: '-']
	wait  bool      = true      @[json: '-']
	ref   voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerSetReturnValueParams {
pub:
	new_value map[string]json.Any @[json: 'newValue'; required]
	cb        EventFunc = unsafe { nil }           @[json: '-']
	wait      bool      = true                @[json: '-']
	ref       voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DebuggerSetScriptSourceParams {
pub:
	script_id               string    @[json: 'scriptId'; required]
	script_source           string    @[json: 'scriptSource'; required]
	dry_run                 ?bool     @[json: 'dryRun']
	allow_top_frame_editing ?bool     @[json: 'allowTopFrameEditing']
	cb                      EventFunc = unsafe { nil } @[json: '-']
	wait                    bool      = true      @[json: '-']
	ref                     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerSetSkipAllPausesParams {
pub:
	skip bool      @[json: 'skip'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct DebuggerSetVariableValueParams {
pub:
	scope_number  int                 @[json: 'scopeNumber'; required]
	variable_name string              @[json: 'variableName'; required]
	new_value     map[string]json.Any @[json: 'newValue'; required]
	call_frame_id string              @[json: 'callFrameId'; required]
	cb            EventFunc = unsafe { nil }           @[json: '-']
	wait          bool      = true                @[json: '-']
	ref           voidptr   = unsafe { nil }             @[json: '-']
}

@[params]
pub struct DebuggerStepIntoParams {
pub:
	break_on_async_call ?bool       @[json: 'breakOnAsyncCall']
	skip_list           ?[]json.Any @[json: 'skipList']
	cb                  EventFunc = unsafe { nil }   @[json: '-']
	wait                bool      = true        @[json: '-']
	ref                 voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct DebuggerStepOverParams {
pub:
	skip_list ?[]json.Any @[json: 'skipList']
	cb        EventFunc = unsafe { nil }   @[json: '-']
	wait      bool      = true        @[json: '-']
	ref       voidptr   = unsafe { nil }     @[json: '-']
}

@[params]
pub struct HeapProfilerAddInspectedHeapObjectParams {
pub:
	heap_object_id string    @[json: 'heapObjectId'; required]
	cb             EventFunc = unsafe { nil } @[json: '-']
	wait           bool      = true      @[json: '-']
	ref            voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct HeapProfilerGetHeapObjectIdParams {
pub:
	object_id string    @[json: 'objectId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct HeapProfilerGetObjectByHeapObjectIdParams {
pub:
	object_id    string    @[json: 'objectId'; required]
	object_group ?string   @[json: 'objectGroup']
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct HeapProfilerStartSamplingParams {
pub:
	sampling_interval                    ?f64      @[json: 'samplingInterval']
	include_objects_collected_by_majorgc ?bool     @[json: 'includeObjectsCollectedByMajorGC']
	include_objects_collected_by_minorgc ?bool     @[json: 'includeObjectsCollectedByMinorGC']
	cb                                   EventFunc = unsafe { nil } @[json: '-']
	wait                                 bool      = true      @[json: '-']
	ref                                  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct HeapProfilerStartTrackingHeapObjectsParams {
pub:
	track_allocations ?bool     @[json: 'trackAllocations']
	cb                EventFunc = unsafe { nil } @[json: '-']
	wait              bool      = true      @[json: '-']
	ref               voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct HeapProfilerStopTrackingHeapObjectsParams {
pub:
	report_progress               ?bool     @[json: 'reportProgress']
	treat_global_objects_as_roots ?bool     @[json: 'treatGlobalObjectsAsRoots']
	capture_numeric_value         ?bool     @[json: 'captureNumericValue']
	expose_internals              ?bool     @[json: 'exposeInternals']
	cb                            EventFunc = unsafe { nil } @[json: '-']
	wait                          bool      = true      @[json: '-']
	ref                           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct HeapProfilerTakeHeapSnapshotParams {
pub:
	report_progress               ?bool     @[json: 'reportProgress']
	treat_global_objects_as_roots ?bool     @[json: 'treatGlobalObjectsAsRoots']
	capture_numeric_value         ?bool     @[json: 'captureNumericValue']
	expose_internals              ?bool     @[json: 'exposeInternals']
	cb                            EventFunc = unsafe { nil } @[json: '-']
	wait                          bool      = true      @[json: '-']
	ref                           voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ProfilerSetSamplingIntervalParams {
pub:
	interval int       @[json: 'interval'; required]
	cb       EventFunc = unsafe { nil } @[json: '-']
	wait     bool      = true      @[json: '-']
	ref      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ProfilerStartPreciseCoverageParams {
pub:
	call_count              ?bool     @[json: 'callCount']
	detailed                ?bool     @[json: 'detailed']
	allow_triggered_updates ?bool     @[json: 'allowTriggeredUpdates']
	cb                      EventFunc = unsafe { nil } @[json: '-']
	wait                    bool      = true      @[json: '-']
	ref                     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeAwaitPromiseParams {
pub:
	promise_object_id string    @[json: 'promiseObjectId'; required]
	return_by_value   ?bool     @[json: 'returnByValue']
	generate_preview  ?bool     @[json: 'generatePreview']
	cb                EventFunc = unsafe { nil } @[json: '-']
	wait              bool      = true      @[json: '-']
	ref               voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeCallFunctionOnParams {
pub:
	function_declaration  string               @[json: 'functionDeclaration'; required]
	object_id             ?string              @[json: 'objectId']
	arguments             ?[]json.Any          @[json: 'arguments']
	silent                ?bool                @[json: 'silent']
	return_by_value       ?bool                @[json: 'returnByValue']
	generate_preview      ?bool                @[json: 'generatePreview']
	user_gesture          ?bool                @[json: 'userGesture']
	await_promise         ?bool                @[json: 'awaitPromise']
	execution_context_id  ?int                 @[json: 'executionContextId']
	object_group          ?string              @[json: 'objectGroup']
	throw_on_side_effect  ?bool                @[json: 'throwOnSideEffect']
	unique_context_id     ?string              @[json: 'uniqueContextId']
	serialization_options ?map[string]json.Any @[json: 'serializationOptions']
	cb                    EventFunc = unsafe { nil }            @[json: '-']
	wait                  bool      = true                 @[json: '-']
	ref                   voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct RuntimeCompileScriptParams {
pub:
	expression           string    @[json: 'expression'; required]
	source_url           string    @[json: 'sourceURL'; required]
	persist_script       bool      @[json: 'persistScript'; required]
	execution_context_id ?int      @[json: 'executionContextId']
	cb                   EventFunc = unsafe { nil } @[json: '-']
	wait                 bool      = true      @[json: '-']
	ref                  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeEvaluateParams {
pub:
	expression                       string               @[json: 'expression'; required]
	object_group                     ?string              @[json: 'objectGroup']
	include_command_line_api         ?bool                @[json: 'includeCommandLineAPI']
	silent                           ?bool                @[json: 'silent']
	context_id                       ?int                 @[json: 'contextId']
	return_by_value                  ?bool                @[json: 'returnByValue']
	generate_preview                 ?bool                @[json: 'generatePreview']
	user_gesture                     ?bool                @[json: 'userGesture']
	await_promise                    ?bool                @[json: 'awaitPromise']
	throw_on_side_effect             ?bool                @[json: 'throwOnSideEffect']
	timeout                          ?f64                 @[json: 'timeout']
	disable_breaks                   ?bool                @[json: 'disableBreaks']
	repl_mode                        ?bool                @[json: 'replMode']
	allow_unsafe_eval_blocked_by_csp ?bool                @[json: 'allowUnsafeEvalBlockedByCSP']
	unique_context_id                ?string              @[json: 'uniqueContextId']
	serialization_options            ?map[string]json.Any @[json: 'serializationOptions']
	cb                               EventFunc = unsafe { nil }            @[json: '-']
	wait                             bool      = true                 @[json: '-']
	ref                              voidptr   = unsafe { nil }              @[json: '-']
}

@[params]
pub struct RuntimeGetPropertiesParams {
pub:
	object_id                   string    @[json: 'objectId'; required]
	own_properties              ?bool     @[json: 'ownProperties']
	accessor_properties_only    ?bool     @[json: 'accessorPropertiesOnly']
	generate_preview            ?bool     @[json: 'generatePreview']
	non_indexed_properties_only ?bool     @[json: 'nonIndexedPropertiesOnly']
	cb                          EventFunc = unsafe { nil } @[json: '-']
	wait                        bool      = true      @[json: '-']
	ref                         voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeGlobalLexicalScopeNamesParams {
pub:
	execution_context_id ?int      @[json: 'executionContextId']
	cb                   EventFunc = unsafe { nil } @[json: '-']
	wait                 bool      = true      @[json: '-']
	ref                  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeQueryObjectsParams {
pub:
	prototype_object_id string    @[json: 'prototypeObjectId'; required]
	object_group        ?string   @[json: 'objectGroup']
	cb                  EventFunc = unsafe { nil } @[json: '-']
	wait                bool      = true      @[json: '-']
	ref                 voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeReleaseObjectParams {
pub:
	object_id string    @[json: 'objectId'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeReleaseObjectGroupParams {
pub:
	object_group string    @[json: 'objectGroup'; required]
	cb           EventFunc = unsafe { nil } @[json: '-']
	wait         bool      = true      @[json: '-']
	ref          voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeRunScriptParams {
pub:
	script_id                string    @[json: 'scriptId'; required]
	execution_context_id     ?int      @[json: 'executionContextId']
	object_group             ?string   @[json: 'objectGroup']
	silent                   ?bool     @[json: 'silent']
	include_command_line_api ?bool     @[json: 'includeCommandLineAPI']
	return_by_value          ?bool     @[json: 'returnByValue']
	generate_preview         ?bool     @[json: 'generatePreview']
	await_promise            ?bool     @[json: 'awaitPromise']
	cb                       EventFunc = unsafe { nil } @[json: '-']
	wait                     bool      = true      @[json: '-']
	ref                      voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeSetAsyncCallStackDepthParams {
pub:
	max_depth int       @[json: 'maxDepth'; required]
	cb        EventFunc = unsafe { nil } @[json: '-']
	wait      bool      = true      @[json: '-']
	ref       voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeSetCustomObjectFormatterEnabledParams {
pub:
	enabled bool      @[json: 'enabled'; required]
	cb      EventFunc = unsafe { nil } @[json: '-']
	wait    bool      = true      @[json: '-']
	ref     voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeSetMaxCallStackSizeToCaptureParams {
pub:
	size int       @[json: 'size'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeAddBindingParams {
pub:
	name                   string    @[json: 'name'; required]
	execution_context_id   ?int      @[json: 'executionContextId']
	execution_context_name ?string   @[json: 'executionContextName']
	cb                     EventFunc = unsafe { nil } @[json: '-']
	wait                   bool      = true      @[json: '-']
	ref                    voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeRemoveBindingParams {
pub:
	name string    @[json: 'name'; required]
	cb   EventFunc = unsafe { nil } @[json: '-']
	wait bool      = true      @[json: '-']
	ref  voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct RuntimeGetExceptionDetailsParams {
pub:
	error_object_id string    @[json: 'errorObjectId'; required]
	cb              EventFunc = unsafe { nil } @[json: '-']
	wait            bool      = true      @[json: '-']
	ref             voidptr   = unsafe { nil }   @[json: '-']
}

@[params]
pub struct ConfigCDVDomain {
pub:
	enable      bool = true
	deps        []string
	enable_deps bool = true
}

pub struct AccessibilityDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Accessibility domains.
pub fn (mut tab Tab) use_accessibility(opts ConfigCDVDomain) !&AccessibilityDomain {
	if opts.enable && tab.is_inactive_deps('Accessibility') {
		tab.send('Accessibility.enable')!
		tab.deps << 'Accessibility'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['DOM'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &AccessibilityDomain{tab}
}

// Disables the accessibility domain. see https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-disable.
pub fn (mut p AccessibilityDomain) disable(msg Message) !Result {
	return p.tab.send('Accessibility.disable', msg)!
}

// Enables the accessibility domain which causes `AXNodeId`s to remain consistent between method calls.
// This turns on accessibility for the page, which can impact performance until accessibility is disabled. see https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-enable.
pub fn (mut p AccessibilityDomain) enable(msg Message) !Result {
	return p.tab.send('Accessibility.enable', msg)!
}

// Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists. see https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getPartialAXTree.
pub fn (mut p AccessibilityDomain) get_partial_ax_tree(par AccessibilityGetPartialAXTreeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Accessibility.getPartialAXTree',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fetches the entire accessibility tree for the root Document see https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getFullAXTree.
pub fn (mut p AccessibilityDomain) get_full_ax_tree(par AccessibilityGetFullAXTreeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Accessibility.getFullAXTree',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fetches the root node.
// Requires `enable()` to have been called previously. see https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getRootAXNode.
pub fn (mut p AccessibilityDomain) get_root_ax_node(par AccessibilityGetRootAXNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Accessibility.getRootAXNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fetches a node and all ancestors up to and including the root.
// Requires `enable()` to have been called previously. see https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getAXNodeAndAncestors.
pub fn (mut p AccessibilityDomain) get_ax_node_and_ancestors(par AccessibilityGetAXNodeAndAncestorsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Accessibility.getAXNodeAndAncestors',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fetches a particular accessibility node by AXNodeId.
// Requires `enable()` to have been called previously. see https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-getChildAXNodes.
pub fn (mut p AccessibilityDomain) get_child_ax_nodes(par AccessibilityGetChildAXNodesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Accessibility.getChildAXNodes',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Query a DOM node's accessibility subtree for accessible name and role.
// This command computes the name and role for all nodes in the subtree, including those that are
// ignored for accessibility, and returns those that match the specified name and role. If no DOM
// node is specified, or the DOM node does not exist, the command returns an error. If neither
//`accessibleName` or `role` is specified, it returns all the accessibility nodes in the subtree. see https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#method-queryAXTree.
pub fn (mut p AccessibilityDomain) query_ax_tree(par AccessibilityQueryAXTreeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Accessibility.queryAXTree',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// The loadComplete event mirrors the load complete event sent by the browser to assistive
// technology when the web page has finished loading. see https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#event-loadComplete.
pub fn (mut p AccessibilityDomain) load_complete(msg Message) !Result {
	return p.tab.send('Accessibility.loadComplete', msg)!
}

// The nodesUpdated event is sent every time a previously requested node has changed the in tree. see https://chromedevtools.github.io/devtools-protocol/tot/Accessibility/#event-nodesUpdated.
pub fn (mut p AccessibilityDomain) nodes_updated(msg Message) !Result {
	return p.tab.send('Accessibility.nodesUpdated', msg)!
}

pub struct AnimationDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Animation domains.
pub fn (mut tab Tab) use_animation(opts ConfigCDVDomain) !&AnimationDomain {
	if opts.enable && tab.is_inactive_deps('Animation') {
		tab.send('Animation.enable')!
		tab.deps << 'Animation'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Runtime', 'DOM'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &AnimationDomain{tab}
}

// Disables animation domain notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-disable.
pub fn (mut p AnimationDomain) disable(msg Message) !Result {
	return p.tab.send('Animation.disable', msg)!
}

// Enables animation domain notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-enable.
pub fn (mut p AnimationDomain) enable(msg Message) !Result {
	return p.tab.send('Animation.enable', msg)!
}

// Returns the current time of the an animation. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-getCurrentTime.
pub fn (mut p AnimationDomain) get_current_time(par AnimationGetCurrentTimeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Animation.getCurrentTime',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Gets the playback rate of the document timeline. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-getPlaybackRate.
pub fn (mut p AnimationDomain) get_playback_rate(msg Message) !Result {
	return p.tab.send('Animation.getPlaybackRate', msg)!
}

// Releases a set of animations to no longer be manipulated. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-releaseAnimations.
pub fn (mut p AnimationDomain) release_animations(par AnimationReleaseAnimationsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Animation.releaseAnimations',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Gets the remote object of the Animation. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-resolveAnimation.
pub fn (mut p AnimationDomain) resolve_animation(par AnimationResolveAnimationParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Animation.resolveAnimation',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Seek a set of animations to a particular time within each animation. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-seekAnimations.
pub fn (mut p AnimationDomain) seek_animations(par AnimationSeekAnimationsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Animation.seekAnimations',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets the paused state of a set of animations. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-setPaused.
pub fn (mut p AnimationDomain) set_paused(par AnimationSetPausedParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Animation.setPaused',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets the playback rate of the document timeline. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-setPlaybackRate.
pub fn (mut p AnimationDomain) set_playback_rate(par AnimationSetPlaybackRateParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Animation.setPlaybackRate',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets the timing of an animation node. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#method-setTiming.
pub fn (mut p AnimationDomain) set_timing(par AnimationSetTimingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Animation.setTiming',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Event for when an animation has been cancelled. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#event-animationCanceled.
pub fn (mut p AnimationDomain) animation_canceled(msg Message) !Result {
	return p.tab.send('Animation.animationCanceled', msg)!
}

// Event for each animation that has been created. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#event-animationCreated.
pub fn (mut p AnimationDomain) animation_created(msg Message) !Result {
	return p.tab.send('Animation.animationCreated', msg)!
}

// Event for animation that has been started. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#event-animationStarted.
pub fn (mut p AnimationDomain) animation_started(msg Message) !Result {
	return p.tab.send('Animation.animationStarted', msg)!
}

// Event for animation that has been updated. see https://chromedevtools.github.io/devtools-protocol/tot/Animation/#event-animationUpdated.
pub fn (mut p AnimationDomain) animation_updated(msg Message) !Result {
	return p.tab.send('Animation.animationUpdated', msg)!
}

// Audits domain allows investigation of page violations and possible improvements. see https://chromedevtools.github.io/devtools-protocol/tot/Audits.
pub struct AuditsDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Audits domains.
pub fn (mut tab Tab) use_audits(opts ConfigCDVDomain) !&AuditsDomain {
	if opts.enable && tab.is_inactive_deps('Audits') {
		tab.send('Audits.enable')!
		tab.deps << 'Audits'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Network'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &AuditsDomain{tab}
}

// Returns the response body and size if it were re-encoded with the specified settings. Only
// applies to images. see https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-getEncodedResponse.
pub fn (mut p AuditsDomain) get_encoded_response(par AuditsGetEncodedResponseParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Audits.getEncodedResponse',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables issues domain, prevents further issues from being reported to the client. see https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-disable.
pub fn (mut p AuditsDomain) disable(msg Message) !Result {
	return p.tab.send('Audits.disable', msg)!
}

// Enables issues domain, sends the issues collected so far to the client by means of the
//`issueAdded` event. see https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-enable.
pub fn (mut p AuditsDomain) enable(msg Message) !Result {
	return p.tab.send('Audits.enable', msg)!
}

// Runs the contrast check for the target page. Found issues are reported
// using Audits.issueAdded event. see https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-checkContrast.
pub fn (mut p AuditsDomain) check_contrast(par AuditsCheckContrastParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Audits.checkContrast',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Runs the form issues check for the target page. Found issues are reported
// using Audits.issueAdded event. see https://chromedevtools.github.io/devtools-protocol/tot/Audits/#method-checkFormsIssues.
pub fn (mut p AuditsDomain) check_forms_issues(msg Message) !Result {
	return p.tab.send('Audits.checkFormsIssues', msg)!
}

pub fn (mut p AuditsDomain) issue_added(msg Message) !Result {
	return p.tab.send('Audits.issueAdded', msg)!
}

// Defines commands and events for browser extensions. see https://chromedevtools.github.io/devtools-protocol/tot/Extensions.
pub struct ExtensionsDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Extensions domains.
pub fn (mut tab Tab) use_extensions(opts ConfigCDVDomain) !&ExtensionsDomain {
	if opts.enable && tab.is_inactive_deps('Extensions') {
		tab.send('Extensions.enable')!
		tab.deps << 'Extensions'
	}

	return &ExtensionsDomain{tab}
}

// Installs an unpacked extension from the filesystem similar to
//--load-extension CLI flags. Returns extension ID once the extension
// has been installed. Available if the client is connected using the
//--remote-debugging-pipe flag and the --enable-unsafe-extension-debugging
// flag is set. see https://chromedevtools.github.io/devtools-protocol/tot/Extensions/#method-loadUnpacked.
pub fn (mut p ExtensionsDomain) load_unpacked(par ExtensionsLoadUnpackedParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Extensions.loadUnpacked',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Gets data from extension storage in the given `storageArea`. If `keys` is
// specified, these are used to filter the result. see https://chromedevtools.github.io/devtools-protocol/tot/Extensions/#method-getStorageItems.
pub fn (mut p ExtensionsDomain) get_storage_items(par ExtensionsGetStorageItemsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Extensions.getStorageItems',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes `keys` from extension storage in the given `storageArea`. see https://chromedevtools.github.io/devtools-protocol/tot/Extensions/#method-removeStorageItems.
pub fn (mut p ExtensionsDomain) remove_storage_items(par ExtensionsRemoveStorageItemsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Extensions.removeStorageItems',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears extension storage in the given `storageArea`. see https://chromedevtools.github.io/devtools-protocol/tot/Extensions/#method-clearStorageItems.
pub fn (mut p ExtensionsDomain) clear_storage_items(par ExtensionsClearStorageItemsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Extensions.clearStorageItems',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets `values` in extension storage in the given `storageArea`. The provided `values`
// will be merged with existing values in the storage area. see https://chromedevtools.github.io/devtools-protocol/tot/Extensions/#method-setStorageItems.
pub fn (mut p ExtensionsDomain) set_storage_items(par ExtensionsSetStorageItemsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Extensions.setStorageItems',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Defines commands and events for Autofill. see https://chromedevtools.github.io/devtools-protocol/tot/Autofill.
pub struct AutofillDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Autofill domains.
pub fn (mut tab Tab) use_autofill(opts ConfigCDVDomain) !&AutofillDomain {
	if opts.enable && tab.is_inactive_deps('Autofill') {
		tab.send('Autofill.enable')!
		tab.deps << 'Autofill'
	}

	return &AutofillDomain{tab}
}

// Trigger autofill on a form identified by the fieldId.
// If the field and related form cannot be autofilled, returns an error. see https://chromedevtools.github.io/devtools-protocol/tot/Autofill/#method-trigger.
pub fn (mut p AutofillDomain) trigger(par AutofillTriggerParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Autofill.trigger',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Set addresses so that developers can verify their forms implementation. see https://chromedevtools.github.io/devtools-protocol/tot/Autofill/#method-setAddresses.
pub fn (mut p AutofillDomain) set_addresses(par AutofillSetAddressesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Autofill.setAddresses',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables autofill domain notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Autofill/#method-disable.
pub fn (mut p AutofillDomain) disable(msg Message) !Result {
	return p.tab.send('Autofill.disable', msg)!
}

// Enables autofill domain notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Autofill/#method-enable.
pub fn (mut p AutofillDomain) enable(msg Message) !Result {
	return p.tab.send('Autofill.enable', msg)!
}

// Emitted when an address form is filled. see https://chromedevtools.github.io/devtools-protocol/tot/Autofill/#event-addressFormFilled.
pub fn (mut p AutofillDomain) address_form_filled(msg Message) !Result {
	return p.tab.send('Autofill.addressFormFilled', msg)!
}

// Defines events for background web platform features. see https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService.
pub struct BackgroundServiceDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use BackgroundService domains.
pub fn (mut tab Tab) use_background_service(opts ConfigCDVDomain) !&BackgroundServiceDomain {
	if opts.enable && tab.is_inactive_deps('BackgroundService') {
		tab.send('BackgroundService.enable')!
		tab.deps << 'BackgroundService'
	}

	return &BackgroundServiceDomain{tab}
}

// Enables event updates for the service. see https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-startObserving.
pub fn (mut p BackgroundServiceDomain) start_observing(par BackgroundServiceStartObservingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('BackgroundService.startObserving',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables event updates for the service. see https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-stopObserving.
pub fn (mut p BackgroundServiceDomain) stop_observing(par BackgroundServiceStopObservingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('BackgroundService.stopObserving',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Set the recording state for the service. see https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-setRecording.
pub fn (mut p BackgroundServiceDomain) set_recording(par BackgroundServiceSetRecordingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('BackgroundService.setRecording',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears all stored data for the service. see https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#method-clearEvents.
pub fn (mut p BackgroundServiceDomain) clear_events(par BackgroundServiceClearEventsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('BackgroundService.clearEvents',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Called when the recording state for the service has been updated. see https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#event-recordingStateChanged.
pub fn (mut p BackgroundServiceDomain) recording_state_changed(msg Message) !Result {
	return p.tab.send('BackgroundService.recordingStateChanged', msg)!
}

// Called with all existing backgroundServiceEvents when enabled, and all new
// events afterwards if enabled and recording. see https://chromedevtools.github.io/devtools-protocol/tot/BackgroundService/#event-backgroundServiceEventReceived.
pub fn (mut p BackgroundServiceDomain) background_service_event_received(msg Message) !Result {
	return p.tab.send('BackgroundService.backgroundServiceEventReceived', msg)!
}

// The Browser domain defines methods and events for browser managing. see https://chromedevtools.github.io/devtools-protocol/tot/Browser.
pub struct BrowserDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Browser domains.
pub fn (mut tab Tab) use_browser(opts ConfigCDVDomain) !&BrowserDomain {
	if opts.enable && tab.is_inactive_deps('Browser') {
		tab.send('Browser.enable')!
		tab.deps << 'Browser'
	}

	return &BrowserDomain{tab}
}

// Set permission settings for given origin. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setPermission.
pub fn (mut p BrowserDomain) set_permission(par BrowserSetPermissionParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.setPermission',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Grant specific permissions to the given origin and reject all others. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-grantPermissions.
pub fn (mut p BrowserDomain) grant_permissions(par BrowserGrantPermissionsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.grantPermissions',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Reset all permission management for all origins. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-resetPermissions.
pub fn (mut p BrowserDomain) reset_permissions(par BrowserResetPermissionsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.resetPermissions',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Set the behavior when downloading a file. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setDownloadBehavior.
pub fn (mut p BrowserDomain) set_download_behavior(par BrowserSetDownloadBehaviorParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.setDownloadBehavior',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Cancel a download if in progress see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-cancelDownload.
pub fn (mut p BrowserDomain) cancel_download(par BrowserCancelDownloadParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.cancelDownload',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Close browser gracefully. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-close.
pub fn (mut p BrowserDomain) close(msg Message) !Result {
	return p.tab.send('Browser.close', msg)!
}

// Crashes browser on the main thread. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-crash.
pub fn (mut p BrowserDomain) crash(msg Message) !Result {
	return p.tab.send('Browser.crash', msg)!
}

// Crashes GPU process. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-crashGpuProcess.
pub fn (mut p BrowserDomain) crash_gpu_process(msg Message) !Result {
	return p.tab.send('Browser.crashGpuProcess', msg)!
}

// Returns version information. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getVersion.
pub fn (mut p BrowserDomain) get_version(msg Message) !Result {
	return p.tab.send('Browser.getVersion', msg)!
}

// Returns the command line switches for the browser process if, and only if
//--enable-automation is on the commandline. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getBrowserCommandLine.
pub fn (mut p BrowserDomain) get_browser_command_line(msg Message) !Result {
	return p.tab.send('Browser.getBrowserCommandLine', msg)!
}

// Get Chrome histograms. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getHistograms.
pub fn (mut p BrowserDomain) get_histograms(par BrowserGetHistogramsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.getHistograms',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Get a Chrome histogram by name. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getHistogram.
pub fn (mut p BrowserDomain) get_histogram(par BrowserGetHistogramParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.getHistogram',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Get position and size of the browser window. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getWindowBounds.
pub fn (mut p BrowserDomain) get_window_bounds(par BrowserGetWindowBoundsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.getWindowBounds',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Get the browser window that contains the devtools target. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-getWindowForTarget.
pub fn (mut p BrowserDomain) get_window_for_target(par BrowserGetWindowForTargetParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.getWindowForTarget',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Set position and/or size of the browser window. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setWindowBounds.
pub fn (mut p BrowserDomain) set_window_bounds(par BrowserSetWindowBoundsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.setWindowBounds',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Set dock tile details, platform-specific. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-setDockTile.
pub fn (mut p BrowserDomain) set_dock_tile(par BrowserSetDockTileParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.setDockTile',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Invoke custom browser commands used by telemetry. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-executeBrowserCommand.
pub fn (mut p BrowserDomain) execute_browser_command(par BrowserExecuteBrowserCommandParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.executeBrowserCommand',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Allows a site to use privacy sandbox features that require enrollment
// without the site actually being enrolled. Only supported on page targets. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#method-addPrivacySandboxEnrollmentOverride.
pub fn (mut p BrowserDomain) add_privacy_sandbox_enrollment_override(par BrowserAddPrivacySandboxEnrollmentOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Browser.addPrivacySandboxEnrollmentOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fired when page is about to start a download. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#event-downloadWillBegin.
pub fn (mut p BrowserDomain) download_will_begin(msg Message) !Result {
	return p.tab.send('Browser.downloadWillBegin', msg)!
}

// Fired when download makes progress. Last call has |done| == true. see https://chromedevtools.github.io/devtools-protocol/tot/Browser/#event-downloadProgress.
pub fn (mut p BrowserDomain) download_progress(msg Message) !Result {
	return p.tab.send('Browser.downloadProgress', msg)!
}

// This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles)
// have an associated `id` used in subsequent operations on the related object. Each object type has
// a specific `id` structure, and those are not interchangeable between objects of different kinds.
// CSS objects can be loaded using the `get*ForNode()` calls (which accept a DOM node id). A client
// can also keep track of stylesheets via the `styleSheetAdded`/`styleSheetRemoved` events and
// subsequently load the required stylesheet contents using the `getStyleSheet[Text]()` methods. see https://chromedevtools.github.io/devtools-protocol/tot/CSS.
pub struct CSSDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use CSS domains.
pub fn (mut tab Tab) use_css(opts ConfigCDVDomain) !&CSSDomain {
	if opts.enable && tab.is_inactive_deps('CSS') {
		tab.send('CSS.enable')!
		tab.deps << 'CSS'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['DOM', 'Page'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &CSSDomain{tab}
}

// Inserts a new rule with the given `ruleText` in a stylesheet with given `styleSheetId`, at the
// position specified by `location`. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-addRule.
pub fn (mut p CSSDomain) add_rule(par CSSAddRuleParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.addRule',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns all class names from specified stylesheet. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-collectClassNames.
pub fn (mut p CSSDomain) collect_class_names(par CSSCollectClassNamesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.collectClassNames',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Creates a new special "via-inspector" stylesheet in the frame with given `frameId`. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-createStyleSheet.
pub fn (mut p CSSDomain) create_style_sheet(par CSSCreateStyleSheetParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.createStyleSheet',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables the CSS agent for the given page. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-disable.
pub fn (mut p CSSDomain) disable(msg Message) !Result {
	return p.tab.send('CSS.disable', msg)!
}

// Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been
// enabled until the result of this command is received. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-enable.
pub fn (mut p CSSDomain) enable(msg Message) !Result {
	return p.tab.send('CSS.enable', msg)!
}

// Ensures that the given node will have specified pseudo-classes whenever its style is computed by
// the browser. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-forcePseudoState.
pub fn (mut p CSSDomain) force_pseudo_state(par CSSForcePseudoStateParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.forcePseudoState',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Ensures that the given node is in its starting-style state. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-forceStartingStyle.
pub fn (mut p CSSDomain) force_starting_style(par CSSForceStartingStyleParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.forceStartingStyle',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p CSSDomain) get_background_colors(par CSSGetBackgroundColorsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.getBackgroundColors',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the computed style for a DOM node identified by `nodeId`. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getComputedStyleForNode.
pub fn (mut p CSSDomain) get_computed_style_for_node(par CSSGetComputedStyleForNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.getComputedStyleForNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Resolve the specified values in the context of the provided element.
// For example, a value of '1em' is evaluated according to the computed
//'font-size' of the element and a value 'calc(1px + 2px)' will be
// resolved to '3px'. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-resolveValues.
pub fn (mut p CSSDomain) resolve_values(par CSSResolveValuesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.resolveValues',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM
// attributes) for a DOM node identified by `nodeId`. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getInlineStylesForNode.
pub fn (mut p CSSDomain) get_inline_styles_for_node(par CSSGetInlineStylesForNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.getInlineStylesForNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the styles coming from animations & transitions
// including the animation & transition styles coming from inheritance chain. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getAnimatedStylesForNode.
pub fn (mut p CSSDomain) get_animated_styles_for_node(par CSSGetAnimatedStylesForNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.getAnimatedStylesForNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns requested styles for a DOM node identified by `nodeId`. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getMatchedStylesForNode.
pub fn (mut p CSSDomain) get_matched_styles_for_node(par CSSGetMatchedStylesForNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.getMatchedStylesForNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns all media queries parsed by the rendering engine. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getMediaQueries.
pub fn (mut p CSSDomain) get_media_queries(msg Message) !Result {
	return p.tab.send('CSS.getMediaQueries', msg)!
}

// Requests information about platform fonts which we used to render child TextNodes in the given
// node. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getPlatformFontsForNode.
pub fn (mut p CSSDomain) get_platform_fonts_for_node(par CSSGetPlatformFontsForNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.getPlatformFontsForNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the current textual content for a stylesheet. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getStyleSheetText.
pub fn (mut p CSSDomain) get_style_sheet_text(par CSSGetStyleSheetTextParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.getStyleSheetText',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns all layers parsed by the rendering engine for the tree scope of a node.
// Given a DOM element identified by nodeId, getLayersForNode returns the root
// layer for the nearest ancestor document or shadow root. The layer root contains
// the full layer tree for the tree scope and their ordering. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getLayersForNode.
pub fn (mut p CSSDomain) get_layers_for_node(par CSSGetLayersForNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.getLayersForNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Given a CSS selector text and a style sheet ID, getLocationForSelector
// returns an array of locations of the CSS selector in the style sheet. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-getLocationForSelector.
pub fn (mut p CSSDomain) get_location_for_selector(par CSSGetLocationForSelectorParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.getLocationForSelector',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Starts tracking the given node for the computed style updates
// and whenever the computed style is updated for node, it queues
// a `computedStyleUpdated` event with throttling.
// There can only be 1 node tracked for computed style updates
// so passing a new node id removes tracking from the previous node.
// Pass `undefined` to disable tracking. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-trackComputedStyleUpdatesForNode.
pub fn (mut p CSSDomain) track_computed_style_updates_for_node(par CSSTrackComputedStyleUpdatesForNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.trackComputedStyleUpdatesForNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Starts tracking the given computed styles for updates. The specified array of properties
// replaces the one previously specified. Pass empty array to disable tracking.
// Use takeComputedStyleUpdates to retrieve the list of nodes that had properties modified.
// The changes to computed style properties are only tracked for nodes pushed to the front-end
// by the DOM agent. If no changes to the tracked properties occur after the node has been pushed
// to the front-end, no updates will be issued for the node. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-trackComputedStyleUpdates.
pub fn (mut p CSSDomain) track_computed_style_updates(par CSSTrackComputedStyleUpdatesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.trackComputedStyleUpdates',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Polls the next batch of computed style updates. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-takeComputedStyleUpdates.
pub fn (mut p CSSDomain) take_computed_style_updates(msg Message) !Result {
	return p.tab.send('CSS.takeComputedStyleUpdates', msg)!
}

// Find a rule with the given active property for the given node and set the new value for this
// property see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setEffectivePropertyValueForNode.
pub fn (mut p CSSDomain) set_effective_property_value_for_node(par CSSSetEffectivePropertyValueForNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setEffectivePropertyValueForNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Modifies the property rule property name. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setPropertyRulePropertyName.
pub fn (mut p CSSDomain) set_property_rule_property_name(par CSSSetPropertyRulePropertyNameParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setPropertyRulePropertyName',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Modifies the keyframe rule key text. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setKeyframeKey.
pub fn (mut p CSSDomain) set_keyframe_key(par CSSSetKeyframeKeyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setKeyframeKey',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Modifies the rule selector. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setMediaText.
pub fn (mut p CSSDomain) set_media_text(par CSSSetMediaTextParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setMediaText',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Modifies the expression of a container query. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setContainerQueryText.
pub fn (mut p CSSDomain) set_container_query_text(par CSSSetContainerQueryTextParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setContainerQueryText',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Modifies the expression of a supports at-rule. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setSupportsText.
pub fn (mut p CSSDomain) set_supports_text(par CSSSetSupportsTextParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setSupportsText',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Modifies the expression of a scope at-rule. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setScopeText.
pub fn (mut p CSSDomain) set_scope_text(par CSSSetScopeTextParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setScopeText',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Modifies the rule selector. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setRuleSelector.
pub fn (mut p CSSDomain) set_rule_selector(par CSSSetRuleSelectorParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setRuleSelector',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets the new stylesheet text. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setStyleSheetText.
pub fn (mut p CSSDomain) set_style_sheet_text(par CSSSetStyleSheetTextParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setStyleSheetText',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Applies specified style edits one after another in the given order. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setStyleTexts.
pub fn (mut p CSSDomain) set_style_texts(par CSSSetStyleTextsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setStyleTexts',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables the selector recording. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-startRuleUsageTracking.
pub fn (mut p CSSDomain) start_rule_usage_tracking(msg Message) !Result {
	return p.tab.send('CSS.startRuleUsageTracking', msg)!
}

// Stop tracking rule usage and return the list of rules that were used since last call to
//`takeCoverageDelta` (or since start of coverage instrumentation). see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-stopRuleUsageTracking.
pub fn (mut p CSSDomain) stop_rule_usage_tracking(msg Message) !Result {
	return p.tab.send('CSS.stopRuleUsageTracking', msg)!
}

// Obtain list of rules that became used since last call to this method (or since start of coverage
// instrumentation). see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-takeCoverageDelta.
pub fn (mut p CSSDomain) take_coverage_delta(msg Message) !Result {
	return p.tab.send('CSS.takeCoverageDelta', msg)!
}

// Enables/disables rendering of local CSS fonts (enabled by default). see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#method-setLocalFontsEnabled.
pub fn (mut p CSSDomain) set_local_fonts_enabled(par CSSSetLocalFontsEnabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CSS.setLocalFontsEnabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fires whenever a web font is updated.  A non-empty font parameter indicates a successfully loaded
// web font. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#event-fontsUpdated.
pub fn (mut p CSSDomain) fonts_updated(msg Message) !Result {
	return p.tab.send('CSS.fontsUpdated', msg)!
}

// Fires whenever a MediaQuery result changes (for example, after a browser window has been
// resized.) The current implementation considers only viewport-dependent media features. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#event-mediaQueryResultChanged.
pub fn (mut p CSSDomain) media_query_result_changed(msg Message) !Result {
	return p.tab.send('CSS.mediaQueryResultChanged', msg)!
}

// Fired whenever an active document stylesheet is added. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#event-styleSheetAdded.
pub fn (mut p CSSDomain) style_sheet_added(msg Message) !Result {
	return p.tab.send('CSS.styleSheetAdded', msg)!
}

// Fired whenever a stylesheet is changed as a result of the client operation. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#event-styleSheetChanged.
pub fn (mut p CSSDomain) style_sheet_changed(msg Message) !Result {
	return p.tab.send('CSS.styleSheetChanged', msg)!
}

// Fired whenever an active document stylesheet is removed. see https://chromedevtools.github.io/devtools-protocol/tot/CSS/#event-styleSheetRemoved.
pub fn (mut p CSSDomain) style_sheet_removed(msg Message) !Result {
	return p.tab.send('CSS.styleSheetRemoved', msg)!
}

pub fn (mut p CSSDomain) computed_style_updated(msg Message) !Result {
	return p.tab.send('CSS.computedStyleUpdated', msg)!
}

pub struct CacheStorageDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use CacheStorage domains.
pub fn (mut tab Tab) use_cache_storage(opts ConfigCDVDomain) !&CacheStorageDomain {
	if opts.enable && tab.is_inactive_deps('CacheStorage') {
		tab.send('CacheStorage.enable')!
		tab.deps << 'CacheStorage'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Storage'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &CacheStorageDomain{tab}
}

// Deletes a cache. see https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-deleteCache.
pub fn (mut p CacheStorageDomain) delete_cache(par CacheStorageDeleteCacheParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CacheStorage.deleteCache',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deletes a cache entry. see https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-deleteEntry.
pub fn (mut p CacheStorageDomain) delete_entry(par CacheStorageDeleteEntryParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CacheStorage.deleteEntry',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests cache names. see https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-requestCacheNames.
pub fn (mut p CacheStorageDomain) request_cache_names(par CacheStorageRequestCacheNamesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CacheStorage.requestCacheNames',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fetches cache entry. see https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-requestCachedResponse.
pub fn (mut p CacheStorageDomain) request_cached_response(par CacheStorageRequestCachedResponseParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CacheStorage.requestCachedResponse',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests data from cache. see https://chromedevtools.github.io/devtools-protocol/tot/CacheStorage/#method-requestEntries.
pub fn (mut p CacheStorageDomain) request_entries(par CacheStorageRequestEntriesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('CacheStorage.requestEntries',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// A domain for interacting with Cast, Presentation API, and Remote Playback API
// functionalities. see https://chromedevtools.github.io/devtools-protocol/tot/Cast.
pub struct CastDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Cast domains.
pub fn (mut tab Tab) use_cast(opts ConfigCDVDomain) !&CastDomain {
	if opts.enable && tab.is_inactive_deps('Cast') {
		tab.send('Cast.enable')!
		tab.deps << 'Cast'
	}

	return &CastDomain{tab}
}

// Starts observing for sinks that can be used for tab mirroring, and if set,
// sinks compatible with |presentationUrl| as well. When sinks are found, a
//|sinksUpdated| event is fired.
// Also starts observing for issue messages. When an issue is added or removed,
// an |issueUpdated| event is fired. see https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-enable.
pub fn (mut p CastDomain) enable(par CastEnableParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Cast.enable',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Stops observing for sinks and issues. see https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-disable.
pub fn (mut p CastDomain) disable(msg Message) !Result {
	return p.tab.send('Cast.disable', msg)!
}

// Sets a sink to be used when the web page requests the browser to choose a
// sink via Presentation API, Remote Playback API, or Cast SDK. see https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-setSinkToUse.
pub fn (mut p CastDomain) set_sink_to_use(par CastSetSinkToUseParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Cast.setSinkToUse',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Starts mirroring the desktop to the sink. see https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-startDesktopMirroring.
pub fn (mut p CastDomain) start_desktop_mirroring(par CastStartDesktopMirroringParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Cast.startDesktopMirroring',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Starts mirroring the tab to the sink. see https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-startTabMirroring.
pub fn (mut p CastDomain) start_tab_mirroring(par CastStartTabMirroringParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Cast.startTabMirroring',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Stops the active Cast session on the sink. see https://chromedevtools.github.io/devtools-protocol/tot/Cast/#method-stopCasting.
pub fn (mut p CastDomain) stop_casting(par CastStopCastingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Cast.stopCasting',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// This is fired whenever the list of available sinks changes. A sink is a
// device or a software surface that you can cast to. see https://chromedevtools.github.io/devtools-protocol/tot/Cast/#event-sinksUpdated.
pub fn (mut p CastDomain) sinks_updated(msg Message) !Result {
	return p.tab.send('Cast.sinksUpdated', msg)!
}

// This is fired whenever the outstanding issue/error message changes.
//|issueMessage| is empty if there is no issue. see https://chromedevtools.github.io/devtools-protocol/tot/Cast/#event-issueUpdated.
pub fn (mut p CastDomain) issue_updated(msg Message) !Result {
	return p.tab.send('Cast.issueUpdated', msg)!
}

// This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object
// that has an `id`. This `id` can be used to get additional information on the Node, resolve it into
// the JavaScript object wrapper, etc. It is important that client receives DOM events only for the
// nodes that are known to the client. Backend keeps track of the nodes that were sent to the client
// and never sends the same node twice. It is client's responsibility to collect information about
// the nodes that were sent to the client. Note that `iframe` owner elements will return
// corresponding document elements as their child nodes. see https://chromedevtools.github.io/devtools-protocol/tot/DOM.
pub struct DOMDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use DOM domains.
pub fn (mut tab Tab) use_dom(opts ConfigCDVDomain) !&DOMDomain {
	if opts.enable && tab.is_inactive_deps('DOM') {
		tab.send('DOM.enable')!
		tab.deps << 'DOM'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Runtime'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &DOMDomain{tab}
}

// Collects class names for the node with given id and all of it's child nodes. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-collectClassNamesFromSubtree.
pub fn (mut p DOMDomain) collect_class_names_from_subtree(par DOMCollectClassNamesFromSubtreeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.collectClassNamesFromSubtree',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Creates a deep copy of the specified node and places it into the target container before the
// given anchor. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-copyTo.
pub fn (mut p DOMDomain) copy_to(par DOMCopyToParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.copyTo',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Describes node given its id, does not require domain to be enabled. Does not start tracking any
// objects, can be used for automation. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-describeNode.
pub fn (mut p DOMDomain) describe_node(par DOMDescribeNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.describeNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Scrolls the specified rect of the given node into view if not already visible.
// Note: exactly one between nodeId, backendNodeId and objectId should be passed
// to identify the node. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-scrollIntoViewIfNeeded.
pub fn (mut p DOMDomain) scroll_into_view_if_needed(par DOMScrollIntoViewIfNeededParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.scrollIntoViewIfNeeded',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables DOM agent for the given page. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-disable.
pub fn (mut p DOMDomain) disable(msg Message) !Result {
	return p.tab.send('DOM.disable', msg)!
}

// Discards search results from the session with the given id. `getSearchResults` should no longer
// be called for that search. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-discardSearchResults.
pub fn (mut p DOMDomain) discard_search_results(par DOMDiscardSearchResultsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.discardSearchResults',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables DOM agent for the given page. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-enable.
pub fn (mut p DOMDomain) enable(par DOMEnableParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.enable',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Focuses the given element. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-focus.
pub fn (mut p DOMDomain) focus(par DOMFocusParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.focus',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns attributes for the specified node. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getAttributes.
pub fn (mut p DOMDomain) get_attributes(par DOMGetAttributesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getAttributes',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns boxes for the given node. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getBoxModel.
pub fn (mut p DOMDomain) get_box_model(par DOMGetBoxModelParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getBoxModel',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns quads that describe node position on the page. This method
// might return multiple quads for inline nodes. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getContentQuads.
pub fn (mut p DOMDomain) get_content_quads(par DOMGetContentQuadsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getContentQuads',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the root DOM node (and optionally the subtree) to the caller.
// Implicitly enables the DOM domain events for the current target. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getDocument.
pub fn (mut p DOMDomain) get_document(par DOMGetDocumentParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getDocument',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the root DOM node (and optionally the subtree) to the caller.
// Deprecated, as it is not designed to work well with the rest of the DOM agent.
// Use DOMSnapshot.captureSnapshot instead. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getFlattenedDocument.
pub fn (mut p DOMDomain) get_flattened_document(par DOMGetFlattenedDocumentParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getFlattenedDocument',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Finds nodes with a given computed style in a subtree. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getNodesForSubtreeByStyle.
pub fn (mut p DOMDomain) get_nodes_for_subtree_by_style(par DOMGetNodesForSubtreeByStyleParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getNodesForSubtreeByStyle',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns node id at given location. Depending on whether DOM domain is enabled, nodeId is
// either returned or not. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getNodeForLocation.
pub fn (mut p DOMDomain) get_node_for_location(par DOMGetNodeForLocationParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getNodeForLocation',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns node's HTML markup. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getOuterHTML.
pub fn (mut p DOMDomain) get_outer_html(par DOMGetOuterHTMLParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getOuterHTML',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the id of the nearest ancestor that is a relayout boundary. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getRelayoutBoundary.
pub fn (mut p DOMDomain) get_relayout_boundary(par DOMGetRelayoutBoundaryParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getRelayoutBoundary',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns search results from given `fromIndex` to given `toIndex` from the search with the given
// identifier. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getSearchResults.
pub fn (mut p DOMDomain) get_search_results(par DOMGetSearchResultsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getSearchResults',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Hides any highlight. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-hideHighlight.
pub fn (mut p DOMDomain) hide_highlight(msg Message) !Result {
	return p.tab.send('DOM.hideHighlight', msg)!
}

// Highlights DOM node. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-highlightNode.
pub fn (mut p DOMDomain) highlight_node(msg Message) !Result {
	return p.tab.send('DOM.highlightNode', msg)!
}

// Highlights given rectangle. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-highlightRect.
pub fn (mut p DOMDomain) highlight_rect(msg Message) !Result {
	return p.tab.send('DOM.highlightRect', msg)!
}

// Marks last undoable state. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-markUndoableState.
pub fn (mut p DOMDomain) mark_undoable_state(msg Message) !Result {
	return p.tab.send('DOM.markUndoableState', msg)!
}

// Moves node into the new container, places it before the given anchor. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-moveTo.
pub fn (mut p DOMDomain) move_to(par DOMMoveToParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.moveTo',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Searches for a given string in the DOM tree. Use `getSearchResults` to access search results or
//`cancelSearch` to end this search session. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-performSearch.
pub fn (mut p DOMDomain) perform_search(par DOMPerformSearchParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.performSearch',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests that the node is sent to the caller given its path. // FIXME, use XPath see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-pushNodeByPathToFrontend.
pub fn (mut p DOMDomain) push_node_by_path_to_frontend(par DOMPushNodeByPathToFrontendParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.pushNodeByPathToFrontend',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests that a batch of nodes is sent to the caller given their backend node ids. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-pushNodesByBackendIdsToFrontend.
pub fn (mut p DOMDomain) push_nodes_by_backend_ids_to_frontend(par DOMPushNodesByBackendIdsToFrontendParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.pushNodesByBackendIdsToFrontend',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Executes `querySelector` on a given node. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-querySelector.
pub fn (mut p DOMDomain) query_selector(par DOMQuerySelectorParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.querySelector',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Executes `querySelectorAll` on a given node. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-querySelectorAll.
pub fn (mut p DOMDomain) query_selector_all(par DOMQuerySelectorAllParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.querySelectorAll',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns NodeIds of current top layer elements.
// Top layer is rendered closest to the user within a viewport, therefore its elements always
// appear on top of all other content. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getTopLayerElements.
pub fn (mut p DOMDomain) get_top_layer_elements(msg Message) !Result {
	return p.tab.send('DOM.getTopLayerElements', msg)!
}

// Returns the NodeId of the matched element according to certain relations. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getElementByRelation.
pub fn (mut p DOMDomain) get_element_by_relation(par DOMGetElementByRelationParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getElementByRelation',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Re-does the last undone action. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-redo.
pub fn (mut p DOMDomain) redo(msg Message) !Result {
	return p.tab.send('DOM.redo', msg)!
}

// Removes attribute with given name from an element with given id. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-removeAttribute.
pub fn (mut p DOMDomain) remove_attribute(par DOMRemoveAttributeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.removeAttribute',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes node with given id. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-removeNode.
pub fn (mut p DOMDomain) remove_node(par DOMRemoveNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.removeNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests that children of the node with given id are returned to the caller in form of
//`setChildNodes` events where not only immediate children are retrieved, but all children down to
// the specified depth. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-requestChildNodes.
pub fn (mut p DOMDomain) request_child_nodes(par DOMRequestChildNodesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.requestChildNodes',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests that the node is sent to the caller given the JavaScript node object reference. All
// nodes that form the path from the node to the root are also sent to the client as a series of
//`setChildNodes` notifications. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-requestNode.
pub fn (mut p DOMDomain) request_node(par DOMRequestNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.requestNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Resolves the JavaScript node object for a given NodeId or BackendNodeId. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-resolveNode.
pub fn (mut p DOMDomain) resolve_node(par DOMResolveNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.resolveNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets attribute for an element with given id. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setAttributeValue.
pub fn (mut p DOMDomain) set_attribute_value(par DOMSetAttributeValueParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.setAttributeValue',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets attributes on element with given id. This method is useful when user edits some existing
// attribute value and types in several attribute name/value pairs. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setAttributesAsText.
pub fn (mut p DOMDomain) set_attributes_as_text(par DOMSetAttributesAsTextParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.setAttributesAsText',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets files for the given file input element. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setFileInputFiles.
pub fn (mut p DOMDomain) set_file_input_files(par DOMSetFileInputFilesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.setFileInputFiles',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets if stack traces should be captured for Nodes. See `Node.getNodeStackTraces`. Default is disabled. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setNodeStackTracesEnabled.
pub fn (mut p DOMDomain) set_node_stack_traces_enabled(par DOMSetNodeStackTracesEnabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.setNodeStackTracesEnabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Gets stack traces associated with a Node. As of now, only provides stack trace for Node creation. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getNodeStackTraces.
pub fn (mut p DOMDomain) get_node_stack_traces(par DOMGetNodeStackTracesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getNodeStackTraces',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns file information for the given
// File wrapper. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getFileInfo.
pub fn (mut p DOMDomain) get_file_info(par DOMGetFileInfoParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getFileInfo',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns list of detached nodes see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getDetachedDomNodes.
pub fn (mut p DOMDomain) get_detached_dom_nodes(msg Message) !Result {
	return p.tab.send('DOM.getDetachedDomNodes', msg)!
}

// Enables console to refer to the node with given id via $x (see Command Line API for more details
//$x functions). see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setInspectedNode.
pub fn (mut p DOMDomain) set_inspected_node(par DOMSetInspectedNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.setInspectedNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets node name for a node with given id. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setNodeName.
pub fn (mut p DOMDomain) set_node_name(par DOMSetNodeNameParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.setNodeName',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets node value for a node with given id. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setNodeValue.
pub fn (mut p DOMDomain) set_node_value(par DOMSetNodeValueParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.setNodeValue',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets node HTML markup, returns new node id. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-setOuterHTML.
pub fn (mut p DOMDomain) set_outer_html(par DOMSetOuterHTMLParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.setOuterHTML',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Undoes the last performed action. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-undo.
pub fn (mut p DOMDomain) undo(msg Message) !Result {
	return p.tab.send('DOM.undo', msg)!
}

// Returns iframe node that owns iframe with the given domain. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getFrameOwner.
pub fn (mut p DOMDomain) get_frame_owner(par DOMGetFrameOwnerParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getFrameOwner',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the query container of the given node based on container query
// conditions: containerName, physical and logical axes, and whether it queries
// scroll-state. If no axes are provided and queriesScrollState is false, the
// style container is returned, which is the direct parent or the closest
// element with a matching container-name. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getContainerForNode.
pub fn (mut p DOMDomain) get_container_for_node(par DOMGetContainerForNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getContainerForNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the descendants of a container query container that have
// container queries against this container. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getQueryingDescendantsForContainer.
pub fn (mut p DOMDomain) get_querying_descendants_for_container(par DOMGetQueryingDescendantsForContainerParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getQueryingDescendantsForContainer',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the target anchor element of the given anchor query according to
// https://www.w3.org/TR/css-anchor-position-1/#target. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#method-getAnchorElement.
pub fn (mut p DOMDomain) get_anchor_element(par DOMGetAnchorElementParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOM.getAnchorElement',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fired when `Element`'s attribute is modified. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-attributeModified.
pub fn (mut p DOMDomain) attribute_modified(msg Message) !Result {
	return p.tab.send('DOM.attributeModified', msg)!
}

// Fired when `Element`'s attribute is removed. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-attributeRemoved.
pub fn (mut p DOMDomain) attribute_removed(msg Message) !Result {
	return p.tab.send('DOM.attributeRemoved', msg)!
}

// Mirrors `DOMCharacterDataModified` event. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-characterDataModified.
pub fn (mut p DOMDomain) character_data_modified(msg Message) !Result {
	return p.tab.send('DOM.characterDataModified', msg)!
}

// Fired when `Container`'s child node count has changed. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-childNodeCountUpdated.
pub fn (mut p DOMDomain) child_node_count_updated(msg Message) !Result {
	return p.tab.send('DOM.childNodeCountUpdated', msg)!
}

// Mirrors `DOMNodeInserted` event. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-childNodeInserted.
pub fn (mut p DOMDomain) child_node_inserted(msg Message) !Result {
	return p.tab.send('DOM.childNodeInserted', msg)!
}

// Mirrors `DOMNodeRemoved` event. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-childNodeRemoved.
pub fn (mut p DOMDomain) child_node_removed(msg Message) !Result {
	return p.tab.send('DOM.childNodeRemoved', msg)!
}

// Called when distribution is changed. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-distributedNodesUpdated.
pub fn (mut p DOMDomain) distributed_nodes_updated(msg Message) !Result {
	return p.tab.send('DOM.distributedNodesUpdated', msg)!
}

// Fired when `Document` has been totally updated. Node ids are no longer valid. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-documentUpdated.
pub fn (mut p DOMDomain) document_updated(msg Message) !Result {
	return p.tab.send('DOM.documentUpdated', msg)!
}

// Fired when `Element`'s inline style is modified via a CSS property modification. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-inlineStyleInvalidated.
pub fn (mut p DOMDomain) inline_style_invalidated(msg Message) !Result {
	return p.tab.send('DOM.inlineStyleInvalidated', msg)!
}

// Called when a pseudo element is added to an element. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-pseudoElementAdded.
pub fn (mut p DOMDomain) pseudo_element_added(msg Message) !Result {
	return p.tab.send('DOM.pseudoElementAdded', msg)!
}

// Called when top layer elements are changed. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-topLayerElementsUpdated.
pub fn (mut p DOMDomain) top_layer_elements_updated(msg Message) !Result {
	return p.tab.send('DOM.topLayerElementsUpdated', msg)!
}

// Fired when a node's scrollability state changes. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-scrollableFlagUpdated.
pub fn (mut p DOMDomain) scrollable_flag_updated(msg Message) !Result {
	return p.tab.send('DOM.scrollableFlagUpdated', msg)!
}

// Called when a pseudo element is removed from an element. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-pseudoElementRemoved.
pub fn (mut p DOMDomain) pseudo_element_removed(msg Message) !Result {
	return p.tab.send('DOM.pseudoElementRemoved', msg)!
}

// Fired when backend wants to provide client with the missing DOM structure. This happens upon
// most of the calls requesting node ids. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-setChildNodes.
pub fn (mut p DOMDomain) set_child_nodes(msg Message) !Result {
	return p.tab.send('DOM.setChildNodes', msg)!
}

// Called when shadow root is popped from the element. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-shadowRootPopped.
pub fn (mut p DOMDomain) shadow_root_popped(msg Message) !Result {
	return p.tab.send('DOM.shadowRootPopped', msg)!
}

// Called when shadow root is pushed into the element. see https://chromedevtools.github.io/devtools-protocol/tot/DOM/#event-shadowRootPushed.
pub fn (mut p DOMDomain) shadow_root_pushed(msg Message) !Result {
	return p.tab.send('DOM.shadowRootPushed', msg)!
}

// DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript
// execution will stop on these operations as if there was a regular breakpoint set. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger.
pub struct DOMDebuggerDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use DOMDebugger domains.
pub fn (mut tab Tab) use_dom_debugger(opts ConfigCDVDomain) !&DOMDebuggerDomain {
	if opts.enable && tab.is_inactive_deps('DOMDebugger') {
		tab.send('DOMDebugger.enable')!
		tab.deps << 'DOMDebugger'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['DOM', 'Runtime'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &DOMDebuggerDomain{tab}
}

// Returns event listeners of the given object. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-getEventListeners.
pub fn (mut p DOMDebuggerDomain) get_event_listeners(par DOMDebuggerGetEventListenersParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMDebugger.getEventListeners',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes DOM breakpoint that was set using `setDOMBreakpoint`. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeDOMBreakpoint.
pub fn (mut p DOMDebuggerDomain) remove_dom_breakpoint(par DOMDebuggerRemoveDOMBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMDebugger.removeDOMBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes breakpoint on particular DOM event. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeEventListenerBreakpoint.
pub fn (mut p DOMDebuggerDomain) remove_event_listener_breakpoint(par DOMDebuggerRemoveEventListenerBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMDebugger.removeEventListenerBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes breakpoint on particular native event. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeInstrumentationBreakpoint.
pub fn (mut p DOMDebuggerDomain) remove_instrumentation_breakpoint(par DOMDebuggerRemoveInstrumentationBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMDebugger.removeInstrumentationBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes breakpoint from XMLHttpRequest. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-removeXHRBreakpoint.
pub fn (mut p DOMDebuggerDomain) remove_xhr_breakpoint(par DOMDebuggerRemoveXHRBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMDebugger.removeXHRBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets breakpoint on particular CSP violations. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setBreakOnCSPViolation.
pub fn (mut p DOMDebuggerDomain) set_break_on_csp_violation(par DOMDebuggerSetBreakOnCSPViolationParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMDebugger.setBreakOnCSPViolation',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets breakpoint on particular operation with DOM. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setDOMBreakpoint.
pub fn (mut p DOMDebuggerDomain) set_dom_breakpoint(par DOMDebuggerSetDOMBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMDebugger.setDOMBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets breakpoint on particular DOM event. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setEventListenerBreakpoint.
pub fn (mut p DOMDebuggerDomain) set_event_listener_breakpoint(par DOMDebuggerSetEventListenerBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMDebugger.setEventListenerBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets breakpoint on particular native event. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setInstrumentationBreakpoint.
pub fn (mut p DOMDebuggerDomain) set_instrumentation_breakpoint(par DOMDebuggerSetInstrumentationBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMDebugger.setInstrumentationBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets breakpoint on XMLHttpRequest. see https://chromedevtools.github.io/devtools-protocol/tot/DOMDebugger/#method-setXHRBreakpoint.
pub fn (mut p DOMDebuggerDomain) set_xhr_breakpoint(par DOMDebuggerSetXHRBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMDebugger.setXHRBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// EventBreakpoints permits setting JavaScript breakpoints on operations and events
// occurring in native code invoked from JavaScript. Once breakpoint is hit, it is
// reported through Debugger domain, similarly to regular breakpoints being hit. see https://chromedevtools.github.io/devtools-protocol/tot/EventBreakpoints.
pub struct EventBreakpointsDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use EventBreakpoints domains.
pub fn (mut tab Tab) use_event_breakpoints(opts ConfigCDVDomain) !&EventBreakpointsDomain {
	if opts.enable && tab.is_inactive_deps('EventBreakpoints') {
		tab.send('EventBreakpoints.enable')!
		tab.deps << 'EventBreakpoints'
	}

	return &EventBreakpointsDomain{tab}
}

// Sets breakpoint on particular native event. see https://chromedevtools.github.io/devtools-protocol/tot/EventBreakpoints/#method-setInstrumentationBreakpoint.
pub fn (mut p EventBreakpointsDomain) set_instrumentation_breakpoint(par EventBreakpointsSetInstrumentationBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('EventBreakpoints.setInstrumentationBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes breakpoint on particular native event. see https://chromedevtools.github.io/devtools-protocol/tot/EventBreakpoints/#method-removeInstrumentationBreakpoint.
pub fn (mut p EventBreakpointsDomain) remove_instrumentation_breakpoint(par EventBreakpointsRemoveInstrumentationBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('EventBreakpoints.removeInstrumentationBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes all breakpoints see https://chromedevtools.github.io/devtools-protocol/tot/EventBreakpoints/#method-disable.
pub fn (mut p EventBreakpointsDomain) disable(msg Message) !Result {
	return p.tab.send('EventBreakpoints.disable', msg)!
}

// This domain facilitates obtaining document snapshots with DOM, layout, and style information. see https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot.
pub struct DOMSnapshotDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use DOMSnapshot domains.
pub fn (mut tab Tab) use_dom_snapshot(opts ConfigCDVDomain) !&DOMSnapshotDomain {
	if opts.enable && tab.is_inactive_deps('DOMSnapshot') {
		tab.send('DOMSnapshot.enable')!
		tab.deps << 'DOMSnapshot'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['CSS', 'DOM', 'DOMDebugger', 'Page'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &DOMSnapshotDomain{tab}
}

// Disables DOM snapshot agent for the given page. see https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#method-disable.
pub fn (mut p DOMSnapshotDomain) disable(msg Message) !Result {
	return p.tab.send('DOMSnapshot.disable', msg)!
}

// Enables DOM snapshot agent for the given page. see https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#method-enable.
pub fn (mut p DOMSnapshotDomain) enable(msg Message) !Result {
	return p.tab.send('DOMSnapshot.enable', msg)!
}

// Returns a document snapshot, including the full DOM tree of the root node (including iframes,
// template contents, and imported documents) in a flattened array, as well as layout and
// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
// flattened. see https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#method-getSnapshot.
pub fn (mut p DOMSnapshotDomain) get_snapshot(par DOMSnapshotGetSnapshotParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMSnapshot.getSnapshot',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns a document snapshot, including the full DOM tree of the root node (including iframes,
// template contents, and imported documents) in a flattened array, as well as layout and
// white-listed computed style information for the nodes. Shadow DOM in the returned DOM tree is
// flattened. see https://chromedevtools.github.io/devtools-protocol/tot/DOMSnapshot/#method-captureSnapshot.
pub fn (mut p DOMSnapshotDomain) capture_snapshot(par DOMSnapshotCaptureSnapshotParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMSnapshot.captureSnapshot',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Query and modify DOM storage. see https://chromedevtools.github.io/devtools-protocol/tot/DOMStorage.
pub struct DOMStorageDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use DOMStorage domains.
pub fn (mut tab Tab) use_dom_storage(opts ConfigCDVDomain) !&DOMStorageDomain {
	if opts.enable && tab.is_inactive_deps('DOMStorage') {
		tab.send('DOMStorage.enable')!
		tab.deps << 'DOMStorage'
	}

	return &DOMStorageDomain{tab}
}

pub fn (mut p DOMStorageDomain) clear(par DOMStorageClearParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMStorage.clear',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables storage tracking, prevents storage events from being sent to the client. see https://chromedevtools.github.io/devtools-protocol/tot/DOMStorage/#method-disable.
pub fn (mut p DOMStorageDomain) disable(msg Message) !Result {
	return p.tab.send('DOMStorage.disable', msg)!
}

// Enables storage tracking, storage events will now be delivered to the client. see https://chromedevtools.github.io/devtools-protocol/tot/DOMStorage/#method-enable.
pub fn (mut p DOMStorageDomain) enable(msg Message) !Result {
	return p.tab.send('DOMStorage.enable', msg)!
}

pub fn (mut p DOMStorageDomain) get_dom_storage_items(par DOMStorageGetDOMStorageItemsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMStorage.getDOMStorageItems',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p DOMStorageDomain) remove_dom_storage_item(par DOMStorageRemoveDOMStorageItemParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMStorage.removeDOMStorageItem',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p DOMStorageDomain) set_dom_storage_item(par DOMStorageSetDOMStorageItemParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DOMStorage.setDOMStorageItem',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p DOMStorageDomain) dom_storage_item_added(msg Message) !Result {
	return p.tab.send('DOMStorage.domStorageItemAdded', msg)!
}

pub fn (mut p DOMStorageDomain) dom_storage_item_removed(msg Message) !Result {
	return p.tab.send('DOMStorage.domStorageItemRemoved', msg)!
}

pub fn (mut p DOMStorageDomain) dom_storage_item_updated(msg Message) !Result {
	return p.tab.send('DOMStorage.domStorageItemUpdated', msg)!
}

pub fn (mut p DOMStorageDomain) dom_storage_items_cleared(msg Message) !Result {
	return p.tab.send('DOMStorage.domStorageItemsCleared', msg)!
}

pub struct DatabaseDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Database domains.
pub fn (mut tab Tab) use_database(opts ConfigCDVDomain) !&DatabaseDomain {
	if opts.enable && tab.is_inactive_deps('Database') {
		tab.send('Database.enable')!
		tab.deps << 'Database'
	}

	return &DatabaseDomain{tab}
}

// Disables database tracking, prevents database events from being sent to the client. see https://chromedevtools.github.io/devtools-protocol/tot/Database/#method-disable.
pub fn (mut p DatabaseDomain) disable(msg Message) !Result {
	return p.tab.send('Database.disable', msg)!
}

// Enables database tracking, database events will now be delivered to the client. see https://chromedevtools.github.io/devtools-protocol/tot/Database/#method-enable.
pub fn (mut p DatabaseDomain) enable(msg Message) !Result {
	return p.tab.send('Database.enable', msg)!
}

pub fn (mut p DatabaseDomain) execute_sql(par DatabaseExecuteSQLParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Database.executeSQL',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p DatabaseDomain) get_database_table_names(par DatabaseGetDatabaseTableNamesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Database.getDatabaseTableNames',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p DatabaseDomain) add_database(msg Message) !Result {
	return p.tab.send('Database.addDatabase', msg)!
}

pub struct DeviceOrientationDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use DeviceOrientation domains.
pub fn (mut tab Tab) use_device_orientation(opts ConfigCDVDomain) !&DeviceOrientationDomain {
	if opts.enable && tab.is_inactive_deps('DeviceOrientation') {
		tab.send('DeviceOrientation.enable')!
		tab.deps << 'DeviceOrientation'
	}

	return &DeviceOrientationDomain{tab}
}

// Clears the overridden Device Orientation. see https://chromedevtools.github.io/devtools-protocol/tot/DeviceOrientation/#method-clearDeviceOrientationOverride.
pub fn (mut p DeviceOrientationDomain) clear_device_orientation_override(msg Message) !Result {
	return p.tab.send('DeviceOrientation.clearDeviceOrientationOverride', msg)!
}

// Overrides the Device Orientation. see https://chromedevtools.github.io/devtools-protocol/tot/DeviceOrientation/#method-setDeviceOrientationOverride.
pub fn (mut p DeviceOrientationDomain) set_device_orientation_override(par DeviceOrientationSetDeviceOrientationOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DeviceOrientation.setDeviceOrientationOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// This domain emulates different environments for the page. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation.
pub struct EmulationDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Emulation domains.
pub fn (mut tab Tab) use_emulation(opts ConfigCDVDomain) !&EmulationDomain {
	if opts.enable && tab.is_inactive_deps('Emulation') {
		tab.send('Emulation.enable')!
		tab.deps << 'Emulation'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['DOM', 'Page', 'Runtime'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &EmulationDomain{tab}
}

// Tells whether emulation is supported. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-canEmulate.
pub fn (mut p EmulationDomain) can_emulate(msg Message) !Result {
	return p.tab.send('Emulation.canEmulate', msg)!
}

// Clears the overridden device metrics. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-clearDeviceMetricsOverride.
pub fn (mut p EmulationDomain) clear_device_metrics_override(msg Message) !Result {
	return p.tab.send('Emulation.clearDeviceMetricsOverride', msg)!
}

// Clears the overridden Geolocation Position and Error. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-clearGeolocationOverride.
pub fn (mut p EmulationDomain) clear_geolocation_override(msg Message) !Result {
	return p.tab.send('Emulation.clearGeolocationOverride', msg)!
}

// Requests that page scale factor is reset to initial values. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-resetPageScaleFactor.
pub fn (mut p EmulationDomain) reset_page_scale_factor(msg Message) !Result {
	return p.tab.send('Emulation.resetPageScaleFactor', msg)!
}

// Enables or disables simulating a focused and active page. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setFocusEmulationEnabled.
pub fn (mut p EmulationDomain) set_focus_emulation_enabled(par EmulationSetFocusEmulationEnabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setFocusEmulationEnabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Automatically render all web contents using a dark theme. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setAutoDarkModeOverride.
pub fn (mut p EmulationDomain) set_auto_dark_mode_override(par EmulationSetAutoDarkModeOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setAutoDarkModeOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables CPU throttling to emulate slow CPUs. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setCPUThrottlingRate.
pub fn (mut p EmulationDomain) set_cpu_throttling_rate(par EmulationSetCPUThrottlingRateParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setCPUThrottlingRate',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets or clears an override of the default background color of the frame. This override is used
// if the content does not specify one. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setDefaultBackgroundColorOverride.
pub fn (mut p EmulationDomain) set_default_background_color_override(par EmulationSetDefaultBackgroundColorOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setDefaultBackgroundColorOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
// window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
// query results). see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setDeviceMetricsOverride.
pub fn (mut p EmulationDomain) set_device_metrics_override(par EmulationSetDeviceMetricsOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setDeviceMetricsOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Start reporting the given posture value to the Device Posture API.
// This override can also be set in setDeviceMetricsOverride(). see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setDevicePostureOverride.
pub fn (mut p EmulationDomain) set_device_posture_override(par EmulationSetDevicePostureOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setDevicePostureOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears a device posture override set with either setDeviceMetricsOverride()
// or setDevicePostureOverride() and starts using posture information from the
// platform again.
// Does nothing if no override is set. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-clearDevicePostureOverride.
pub fn (mut p EmulationDomain) clear_device_posture_override(msg Message) !Result {
	return p.tab.send('Emulation.clearDevicePostureOverride', msg)!
}

pub fn (mut p EmulationDomain) set_scrollbars_hidden(par EmulationSetScrollbarsHiddenParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setScrollbarsHidden',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p EmulationDomain) set_document_cookie_disabled(par EmulationSetDocumentCookieDisabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setDocumentCookieDisabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p EmulationDomain) set_emit_touch_events_for_mouse(par EmulationSetEmitTouchEventsForMouseParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setEmitTouchEventsForMouse',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Emulates the given media type or media feature for CSS media queries. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setEmulatedMedia.
pub fn (mut p EmulationDomain) set_emulated_media(par EmulationSetEmulatedMediaParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setEmulatedMedia',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Emulates the given vision deficiency. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setEmulatedVisionDeficiency.
pub fn (mut p EmulationDomain) set_emulated_vision_deficiency(par EmulationSetEmulatedVisionDeficiencyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setEmulatedVisionDeficiency',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
// unavailable. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setGeolocationOverride.
pub fn (mut p EmulationDomain) set_geolocation_override(par EmulationSetGeolocationOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setGeolocationOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p EmulationDomain) get_overridden_sensor_information(par EmulationGetOverriddenSensorInformationParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.getOverriddenSensorInformation',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Overrides a platform sensor of a given type. If |enabled| is true, calls to
// Sensor.start() will use a virtual sensor as backend rather than fetching
// data from a real hardware sensor. Otherwise, existing virtual
// sensor-backend Sensor objects will fire an error event and new calls to
// Sensor.start() will attempt to use a real sensor instead. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setSensorOverrideEnabled.
pub fn (mut p EmulationDomain) set_sensor_override_enabled(par EmulationSetSensorOverrideEnabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setSensorOverrideEnabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Updates the sensor readings reported by a sensor type previously overridden
// by setSensorOverrideEnabled. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setSensorOverrideReadings.
pub fn (mut p EmulationDomain) set_sensor_override_readings(par EmulationSetSensorOverrideReadingsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setSensorOverrideReadings',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Overrides a pressure source of a given type, as used by the Compute
// Pressure API, so that updates to PressureObserver.observe() are provided
// via setPressureStateOverride instead of being retrieved from
// platform-provided telemetry data. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setPressureSourceOverrideEnabled.
pub fn (mut p EmulationDomain) set_pressure_source_override_enabled(par EmulationSetPressureSourceOverrideEnabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setPressureSourceOverrideEnabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Provides a given pressure state that will be processed and eventually be
// delivered to PressureObserver users. |source| must have been previously
// overridden by setPressureSourceOverrideEnabled. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setPressureStateOverride.
pub fn (mut p EmulationDomain) set_pressure_state_override(par EmulationSetPressureStateOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setPressureStateOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Overrides the Idle state. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setIdleOverride.
pub fn (mut p EmulationDomain) set_idle_override(par EmulationSetIdleOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setIdleOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears Idle state overrides. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-clearIdleOverride.
pub fn (mut p EmulationDomain) clear_idle_override(msg Message) !Result {
	return p.tab.send('Emulation.clearIdleOverride', msg)!
}

// Overrides value returned by the javascript navigator object. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setNavigatorOverrides.
pub fn (mut p EmulationDomain) set_navigator_overrides(par EmulationSetNavigatorOverridesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setNavigatorOverrides',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets a specified page scale factor. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setPageScaleFactor.
pub fn (mut p EmulationDomain) set_page_scale_factor(par EmulationSetPageScaleFactorParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setPageScaleFactor',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Switches script execution in the page. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setScriptExecutionDisabled.
pub fn (mut p EmulationDomain) set_script_execution_disabled(par EmulationSetScriptExecutionDisabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setScriptExecutionDisabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables touch on platforms which do not support them. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setTouchEmulationEnabled.
pub fn (mut p EmulationDomain) set_touch_emulation_enabled(par EmulationSetTouchEmulationEnabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setTouchEmulationEnabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets
// the current virtual time policy.  Note this supersedes any previous time budget. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setVirtualTimePolicy.
pub fn (mut p EmulationDomain) set_virtual_time_policy(par EmulationSetVirtualTimePolicyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setVirtualTimePolicy',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Overrides default host system locale with the specified one. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setLocaleOverride.
pub fn (mut p EmulationDomain) set_locale_override(par EmulationSetLocaleOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setLocaleOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Overrides default host system timezone with the specified one. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setTimezoneOverride.
pub fn (mut p EmulationDomain) set_timezone_override(par EmulationSetTimezoneOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setTimezoneOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Resizes the frame/viewport of the page. Note that this does not affect the frame's container
//(e.g. browser window). Can be used to produce screenshots of the specified size. Not supported
// on Android. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setVisibleSize.
pub fn (mut p EmulationDomain) set_visible_size(par EmulationSetVisibleSizeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setVisibleSize',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p EmulationDomain) set_disabled_image_types(par EmulationSetDisabledImageTypesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setDisabledImageTypes',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p EmulationDomain) set_hardware_concurrency_override(par EmulationSetHardwareConcurrencyOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setHardwareConcurrencyOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Allows overriding user agent with the given string.
//`userAgentMetadata` must be set for Client Hint headers to be sent. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setUserAgentOverride.
pub fn (mut p EmulationDomain) set_user_agent_override(par EmulationSetUserAgentOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setUserAgentOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Allows overriding the automation flag. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#method-setAutomationOverride.
pub fn (mut p EmulationDomain) set_automation_override(par EmulationSetAutomationOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Emulation.setAutomationOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Notification sent after the virtual time budget for the current VirtualTimePolicy has run out. see https://chromedevtools.github.io/devtools-protocol/tot/Emulation/#event-virtualTimeBudgetExpired.
pub fn (mut p EmulationDomain) virtual_time_budget_expired(msg Message) !Result {
	return p.tab.send('Emulation.virtualTimeBudgetExpired', msg)!
}

// This domain provides experimental commands only supported in headless mode. see https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental.
pub struct HeadlessExperimentalDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use HeadlessExperimental domains.
pub fn (mut tab Tab) use_headless_experimental(opts ConfigCDVDomain) !&HeadlessExperimentalDomain {
	if opts.enable && tab.is_inactive_deps('HeadlessExperimental') {
		tab.send('HeadlessExperimental.enable')!
		tab.deps << 'HeadlessExperimental'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Page', 'Runtime'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &HeadlessExperimentalDomain{tab}
}

// Sends a BeginFrame to the target and returns when the frame was completed. Optionally captures a
// screenshot from the resulting frame. Requires that the target was created with enabled
// BeginFrameControl. Designed for use with --run-all-compositor-stages-before-draw, see also
// https://goo.gle/chrome-headless-rendering for more background. see https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental/#method-beginFrame.
pub fn (mut p HeadlessExperimentalDomain) begin_frame(par HeadlessExperimentalBeginFrameParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('HeadlessExperimental.beginFrame',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables headless events for the target. see https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental/#method-disable.
pub fn (mut p HeadlessExperimentalDomain) disable(msg Message) !Result {
	return p.tab.send('HeadlessExperimental.disable', msg)!
}

// Enables headless events for the target. see https://chromedevtools.github.io/devtools-protocol/tot/HeadlessExperimental/#method-enable.
pub fn (mut p HeadlessExperimentalDomain) enable(msg Message) !Result {
	return p.tab.send('HeadlessExperimental.enable', msg)!
}

// Input/Output operations for streams produced by DevTools. see https://chromedevtools.github.io/devtools-protocol/tot/IO.
pub struct IODomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use IO domains.
pub fn (mut tab Tab) use_io(opts ConfigCDVDomain) !&IODomain {
	if opts.enable && tab.is_inactive_deps('IO') {
		tab.send('IO.enable')!
		tab.deps << 'IO'
	}

	return &IODomain{tab}
}

// Close the stream, discard any temporary backing storage. see https://chromedevtools.github.io/devtools-protocol/tot/IO/#method-close.
pub fn (mut p IODomain) close(par IOCloseParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('IO.close',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Read a chunk of the stream see https://chromedevtools.github.io/devtools-protocol/tot/IO/#method-read.
pub fn (mut p IODomain) read(par IOReadParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('IO.read',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Return UUID of Blob object specified by a remote object id. see https://chromedevtools.github.io/devtools-protocol/tot/IO/#method-resolveBlob.
pub fn (mut p IODomain) resolve_blob(par IOResolveBlobParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('IO.resolveBlob',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub struct FileSystemDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use FileSystem domains.
pub fn (mut tab Tab) use_file_system(opts ConfigCDVDomain) !&FileSystemDomain {
	if opts.enable && tab.is_inactive_deps('FileSystem') {
		tab.send('FileSystem.enable')!
		tab.deps << 'FileSystem'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Network', 'Storage'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &FileSystemDomain{tab}
}

pub fn (mut p FileSystemDomain) get_directory(par FileSystemGetDirectoryParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('FileSystem.getDirectory',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub struct IndexedDBDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use IndexedDB domains.
pub fn (mut tab Tab) use_indexed_db(opts ConfigCDVDomain) !&IndexedDBDomain {
	if opts.enable && tab.is_inactive_deps('IndexedDB') {
		tab.send('IndexedDB.enable')!
		tab.deps << 'IndexedDB'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Runtime', 'Storage'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &IndexedDBDomain{tab}
}

// Clears all entries from an object store. see https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-clearObjectStore.
pub fn (mut p IndexedDBDomain) clear_object_store(par IndexedDBClearObjectStoreParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('IndexedDB.clearObjectStore',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deletes a database. see https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-deleteDatabase.
pub fn (mut p IndexedDBDomain) delete_database(par IndexedDBDeleteDatabaseParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('IndexedDB.deleteDatabase',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Delete a range of entries from an object store see https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-deleteObjectStoreEntries.
pub fn (mut p IndexedDBDomain) delete_object_store_entries(par IndexedDBDeleteObjectStoreEntriesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('IndexedDB.deleteObjectStoreEntries',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables events from backend. see https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-disable.
pub fn (mut p IndexedDBDomain) disable(msg Message) !Result {
	return p.tab.send('IndexedDB.disable', msg)!
}

// Enables events from backend. see https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-enable.
pub fn (mut p IndexedDBDomain) enable(msg Message) !Result {
	return p.tab.send('IndexedDB.enable', msg)!
}

// Requests data from object store or index. see https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-requestData.
pub fn (mut p IndexedDBDomain) request_data(par IndexedDBRequestDataParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('IndexedDB.requestData',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Gets metadata of an object store. see https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-getMetadata.
pub fn (mut p IndexedDBDomain) get_metadata(par IndexedDBGetMetadataParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('IndexedDB.getMetadata',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests database with given name in given frame. see https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-requestDatabase.
pub fn (mut p IndexedDBDomain) request_database(par IndexedDBRequestDatabaseParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('IndexedDB.requestDatabase',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests database names for given security origin. see https://chromedevtools.github.io/devtools-protocol/tot/IndexedDB/#method-requestDatabaseNames.
pub fn (mut p IndexedDBDomain) request_database_names(par IndexedDBRequestDatabaseNamesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('IndexedDB.requestDatabaseNames',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub struct InputDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Input domains.
pub fn (mut tab Tab) use_input(opts ConfigCDVDomain) !&InputDomain {
	if opts.enable && tab.is_inactive_deps('Input') {
		tab.send('Input.enable')!
		tab.deps << 'Input'
	}

	return &InputDomain{tab}
}

// Dispatches a drag event into the page. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchDragEvent.
pub fn (mut p InputDomain) dispatch_drag_event(par InputDispatchDragEventParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.dispatchDragEvent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Dispatches a key event to the page. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchKeyEvent.
pub fn (mut p InputDomain) dispatch_key_event(par InputDispatchKeyEventParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.dispatchKeyEvent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// This method emulates inserting text that doesn't come from a key press,
// for example an emoji keyboard or an IME. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-insertText.
pub fn (mut p InputDomain) insert_text(par InputInsertTextParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.insertText',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// This method sets the current candidate text for IME.
// Use imeCommitComposition to commit the final text.
// Use imeSetComposition with empty string as text to cancel composition. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-imeSetComposition.
pub fn (mut p InputDomain) ime_set_composition(par InputImeSetCompositionParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.imeSetComposition',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Dispatches a mouse event to the page. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchMouseEvent.
pub fn (mut p InputDomain) dispatch_mouse_event(par InputDispatchMouseEventParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.dispatchMouseEvent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Dispatches a touch event to the page. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchTouchEvent.
pub fn (mut p InputDomain) dispatch_touch_event(par InputDispatchTouchEventParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.dispatchTouchEvent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Cancels any active dragging in the page. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-cancelDragging.
pub fn (mut p InputDomain) cancel_dragging(msg Message) !Result {
	return p.tab.send('Input.cancelDragging', msg)!
}

// Emulates touch event from the mouse event parameters. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-emulateTouchFromMouseEvent.
pub fn (mut p InputDomain) emulate_touch_from_mouse_event(par InputEmulateTouchFromMouseEventParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.emulateTouchFromMouseEvent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Ignores input events (useful while auditing page). see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-setIgnoreInputEvents.
pub fn (mut p InputDomain) set_ignore_input_events(par InputSetIgnoreInputEventsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.setIgnoreInputEvents',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Prevents default drag and drop behavior and instead emits `Input.dragIntercepted` events.
// Drag and drop behavior can be directly controlled via `Input.dispatchDragEvent`. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-setInterceptDrags.
pub fn (mut p InputDomain) set_intercept_drags(par InputSetInterceptDragsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.setInterceptDrags',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Synthesizes a pinch gesture over a time period by issuing appropriate touch events. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-synthesizePinchGesture.
pub fn (mut p InputDomain) synthesize_pinch_gesture(par InputSynthesizePinchGestureParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.synthesizePinchGesture',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Synthesizes a scroll gesture over a time period by issuing appropriate touch events. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-synthesizeScrollGesture.
pub fn (mut p InputDomain) synthesize_scroll_gesture(par InputSynthesizeScrollGestureParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.synthesizeScrollGesture',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Synthesizes a tap gesture over a time period by issuing appropriate touch events. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-synthesizeTapGesture.
pub fn (mut p InputDomain) synthesize_tap_gesture(par InputSynthesizeTapGestureParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Input.synthesizeTapGesture',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Emitted only when `Input.setInterceptDrags` is enabled. Use this data with `Input.dispatchDragEvent` to
// restore normal drag and drop behavior. see https://chromedevtools.github.io/devtools-protocol/tot/Input/#event-dragIntercepted.
pub fn (mut p InputDomain) drag_intercepted(msg Message) !Result {
	return p.tab.send('Input.dragIntercepted', msg)!
}

pub struct InspectorDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Inspector domains.
pub fn (mut tab Tab) use_inspector(opts ConfigCDVDomain) !&InspectorDomain {
	if opts.enable && tab.is_inactive_deps('Inspector') {
		tab.send('Inspector.enable')!
		tab.deps << 'Inspector'
	}

	return &InspectorDomain{tab}
}

// Disables inspector domain notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#method-disable.
pub fn (mut p InspectorDomain) disable(msg Message) !Result {
	return p.tab.send('Inspector.disable', msg)!
}

// Enables inspector domain notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#method-enable.
pub fn (mut p InspectorDomain) enable(msg Message) !Result {
	return p.tab.send('Inspector.enable', msg)!
}

// Fired when remote debugging connection is about to be terminated. Contains detach reason. see https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#event-detached.
pub fn (mut p InspectorDomain) detached(msg Message) !Result {
	return p.tab.send('Inspector.detached', msg)!
}

// Fired when debugging target has crashed see https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#event-targetCrashed.
pub fn (mut p InspectorDomain) target_crashed(msg Message) !Result {
	return p.tab.send('Inspector.targetCrashed', msg)!
}

// Fired when debugging target has reloaded after crash see https://chromedevtools.github.io/devtools-protocol/tot/Inspector/#event-targetReloadedAfterCrash.
pub fn (mut p InspectorDomain) target_reloaded_after_crash(msg Message) !Result {
	return p.tab.send('Inspector.targetReloadedAfterCrash', msg)!
}

pub struct LayerTreeDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use LayerTree domains.
pub fn (mut tab Tab) use_layer_tree(opts ConfigCDVDomain) !&LayerTreeDomain {
	if opts.enable && tab.is_inactive_deps('LayerTree') {
		tab.send('LayerTree.enable')!
		tab.deps << 'LayerTree'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['DOM'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &LayerTreeDomain{tab}
}

// Provides the reasons why the given layer was composited. see https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-compositingReasons.
pub fn (mut p LayerTreeDomain) compositing_reasons(par LayerTreeCompositingReasonsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('LayerTree.compositingReasons',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables compositing tree inspection. see https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-disable.
pub fn (mut p LayerTreeDomain) disable(msg Message) !Result {
	return p.tab.send('LayerTree.disable', msg)!
}

// Enables compositing tree inspection. see https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-enable.
pub fn (mut p LayerTreeDomain) enable(msg Message) !Result {
	return p.tab.send('LayerTree.enable', msg)!
}

// Returns the snapshot identifier. see https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-loadSnapshot.
pub fn (mut p LayerTreeDomain) load_snapshot(par LayerTreeLoadSnapshotParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('LayerTree.loadSnapshot',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the layer snapshot identifier. see https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-makeSnapshot.
pub fn (mut p LayerTreeDomain) make_snapshot(par LayerTreeMakeSnapshotParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('LayerTree.makeSnapshot',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p LayerTreeDomain) profile_snapshot(par LayerTreeProfileSnapshotParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('LayerTree.profileSnapshot',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Releases layer snapshot captured by the back-end. see https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-releaseSnapshot.
pub fn (mut p LayerTreeDomain) release_snapshot(par LayerTreeReleaseSnapshotParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('LayerTree.releaseSnapshot',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Replays the layer snapshot and returns the resulting bitmap. see https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-replaySnapshot.
pub fn (mut p LayerTreeDomain) replay_snapshot(par LayerTreeReplaySnapshotParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('LayerTree.replaySnapshot',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Replays the layer snapshot and returns canvas log. see https://chromedevtools.github.io/devtools-protocol/tot/LayerTree/#method-snapshotCommandLog.
pub fn (mut p LayerTreeDomain) snapshot_command_log(par LayerTreeSnapshotCommandLogParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('LayerTree.snapshotCommandLog',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p LayerTreeDomain) layer_painted(msg Message) !Result {
	return p.tab.send('LayerTree.layerPainted', msg)!
}

pub fn (mut p LayerTreeDomain) layer_tree_did_change(msg Message) !Result {
	return p.tab.send('LayerTree.layerTreeDidChange', msg)!
}

// Provides access to log entries. see https://chromedevtools.github.io/devtools-protocol/tot/Log.
pub struct LogDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Log domains.
pub fn (mut tab Tab) use_log(opts ConfigCDVDomain) !&LogDomain {
	if opts.enable && tab.is_inactive_deps('Log') {
		tab.send('Log.enable')!
		tab.deps << 'Log'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Runtime', 'Network'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &LogDomain{tab}
}

// Clears the log. see https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-clear.
pub fn (mut p LogDomain) clear(msg Message) !Result {
	return p.tab.send('Log.clear', msg)!
}

// Disables log domain, prevents further log entries from being reported to the client. see https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-disable.
pub fn (mut p LogDomain) disable(msg Message) !Result {
	return p.tab.send('Log.disable', msg)!
}

// Enables log domain, sends the entries collected so far to the client by means of the
//`entryAdded` notification. see https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-enable.
pub fn (mut p LogDomain) enable(msg Message) !Result {
	return p.tab.send('Log.enable', msg)!
}

// start violation reporting. see https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-startViolationsReport.
pub fn (mut p LogDomain) start_violations_report(par LogStartViolationsReportParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Log.startViolationsReport',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Stop violation reporting. see https://chromedevtools.github.io/devtools-protocol/tot/Log/#method-stopViolationsReport.
pub fn (mut p LogDomain) stop_violations_report(msg Message) !Result {
	return p.tab.send('Log.stopViolationsReport', msg)!
}

// Issued when new message was logged. see https://chromedevtools.github.io/devtools-protocol/tot/Log/#event-entryAdded.
pub fn (mut p LogDomain) entry_added(msg Message) !Result {
	return p.tab.send('Log.entryAdded', msg)!
}

pub struct MemoryDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Memory domains.
pub fn (mut tab Tab) use_memory(opts ConfigCDVDomain) !&MemoryDomain {
	if opts.enable && tab.is_inactive_deps('Memory') {
		tab.send('Memory.enable')!
		tab.deps << 'Memory'
	}

	return &MemoryDomain{tab}
}

// Retruns current DOM object counters. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getDOMCounters.
pub fn (mut p MemoryDomain) get_dom_counters(msg Message) !Result {
	return p.tab.send('Memory.getDOMCounters', msg)!
}

// Retruns DOM object counters after preparing renderer for leak detection. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getDOMCountersForLeakDetection.
pub fn (mut p MemoryDomain) get_dom_counters_for_leak_detection(msg Message) !Result {
	return p.tab.send('Memory.getDOMCountersForLeakDetection', msg)!
}

// Prepares for leak detection by terminating workers, stopping spellcheckers,
// dropping non-essential internal caches, running garbage collections, etc. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-prepareForLeakDetection.
pub fn (mut p MemoryDomain) prepare_for_leak_detection(msg Message) !Result {
	return p.tab.send('Memory.prepareForLeakDetection', msg)!
}

// Simulate OomIntervention by purging V8 memory. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-forciblyPurgeJavaScriptMemory.
pub fn (mut p MemoryDomain) forcibly_purge_java_script_memory(msg Message) !Result {
	return p.tab.send('Memory.forciblyPurgeJavaScriptMemory', msg)!
}

// Enable/disable suppressing memory pressure notifications in all processes. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-setPressureNotificationsSuppressed.
pub fn (mut p MemoryDomain) set_pressure_notifications_suppressed(par MemorySetPressureNotificationsSuppressedParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Memory.setPressureNotificationsSuppressed',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Simulate a memory pressure notification in all processes. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-simulatePressureNotification.
pub fn (mut p MemoryDomain) simulate_pressure_notification(par MemorySimulatePressureNotificationParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Memory.simulatePressureNotification',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Start collecting native memory profile. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-startSampling.
pub fn (mut p MemoryDomain) start_sampling(par MemoryStartSamplingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Memory.startSampling',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Stop collecting native memory profile. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-stopSampling.
pub fn (mut p MemoryDomain) stop_sampling(msg Message) !Result {
	return p.tab.send('Memory.stopSampling', msg)!
}

// Retrieve native memory allocations profile
// collected since renderer process startup. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getAllTimeSamplingProfile.
pub fn (mut p MemoryDomain) get_all_time_sampling_profile(msg Message) !Result {
	return p.tab.send('Memory.getAllTimeSamplingProfile', msg)!
}

// Retrieve native memory allocations profile
// collected since browser process startup. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getBrowserSamplingProfile.
pub fn (mut p MemoryDomain) get_browser_sampling_profile(msg Message) !Result {
	return p.tab.send('Memory.getBrowserSamplingProfile', msg)!
}

// Retrieve native memory allocations profile collected since last
//`startSampling` call. see https://chromedevtools.github.io/devtools-protocol/tot/Memory/#method-getSamplingProfile.
pub fn (mut p MemoryDomain) get_sampling_profile(msg Message) !Result {
	return p.tab.send('Memory.getSamplingProfile', msg)!
}

// Network domain allows tracking network activities of the page. It exposes information about http,
// file, data and other requests and responses, their headers, bodies, timing, etc. see https://chromedevtools.github.io/devtools-protocol/tot/Network.
pub struct NetworkDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Network domains.
pub fn (mut tab Tab) use_network(opts ConfigCDVDomain) !&NetworkDomain {
	if opts.enable && tab.is_inactive_deps('Network') {
		tab.send('Network.enable')!
		tab.deps << 'Network'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Debugger', 'Runtime', 'Security'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &NetworkDomain{tab}
}

// Sets a list of content encodings that will be accepted. Empty list means no encoding is accepted. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setAcceptedEncodings.
pub fn (mut p NetworkDomain) set_accepted_encodings(par NetworkSetAcceptedEncodingsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.setAcceptedEncodings',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears accepted encodings set by setAcceptedEncodings see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-clearAcceptedEncodingsOverride.
pub fn (mut p NetworkDomain) clear_accepted_encodings_override(msg Message) !Result {
	return p.tab.send('Network.clearAcceptedEncodingsOverride', msg)!
}

// Tells whether clearing browser cache is supported. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-canClearBrowserCache.
pub fn (mut p NetworkDomain) can_clear_browser_cache(msg Message) !Result {
	return p.tab.send('Network.canClearBrowserCache', msg)!
}

// Tells whether clearing browser cookies is supported. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-canClearBrowserCookies.
pub fn (mut p NetworkDomain) can_clear_browser_cookies(msg Message) !Result {
	return p.tab.send('Network.canClearBrowserCookies', msg)!
}

// Tells whether emulation of network conditions is supported. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-canEmulateNetworkConditions.
pub fn (mut p NetworkDomain) can_emulate_network_conditions(msg Message) !Result {
	return p.tab.send('Network.canEmulateNetworkConditions', msg)!
}

// Clears browser cache. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-clearBrowserCache.
pub fn (mut p NetworkDomain) clear_browser_cache(msg Message) !Result {
	return p.tab.send('Network.clearBrowserCache', msg)!
}

// Clears browser cookies. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-clearBrowserCookies.
pub fn (mut p NetworkDomain) clear_browser_cookies(msg Message) !Result {
	return p.tab.send('Network.clearBrowserCookies', msg)!
}

// Response to Network.requestIntercepted which either modifies the request to continue with any
// modifications, or blocks it, or completes it with the provided response bytes. If a network
// fetch occurs as a result which encounters a redirect an additional Network.requestIntercepted
// event will be sent with the same InterceptionId.
// Deprecated, use Fetch.continueRequest, Fetch.fulfillRequest and Fetch.failRequest instead. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-continueInterceptedRequest.
pub fn (mut p NetworkDomain) continue_intercepted_request(par NetworkContinueInterceptedRequestParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.continueInterceptedRequest',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deletes browser cookies with matching name and url or domain/path/partitionKey pair. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-deleteCookies.
pub fn (mut p NetworkDomain) delete_cookies(par NetworkDeleteCookiesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.deleteCookies',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables network tracking, prevents network events from being sent to the client. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-disable.
pub fn (mut p NetworkDomain) disable(msg Message) !Result {
	return p.tab.send('Network.disable', msg)!
}

// Activates emulation of network conditions. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-emulateNetworkConditions.
pub fn (mut p NetworkDomain) emulate_network_conditions(par NetworkEmulateNetworkConditionsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.emulateNetworkConditions',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables network tracking, network events will now be delivered to the client. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-enable.
pub fn (mut p NetworkDomain) enable(par NetworkEnableParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.enable',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns all browser cookies. Depending on the backend support, will return detailed cookie
// information in the `cookies` field.
// Deprecated. Use Storage.getCookies instead. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getAllCookies.
pub fn (mut p NetworkDomain) get_all_cookies(msg Message) !Result {
	return p.tab.send('Network.getAllCookies', msg)!
}

// Returns the DER-encoded certificate. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getCertificate.
pub fn (mut p NetworkDomain) get_certificate(par NetworkGetCertificateParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.getCertificate',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns all browser cookies for the current URL. Depending on the backend support, will return
// detailed cookie information in the `cookies` field. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getCookies.
pub fn (mut p NetworkDomain) get_cookies(par NetworkGetCookiesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.getCookies',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns content served for the given request. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getResponseBody.
pub fn (mut p NetworkDomain) get_response_body(par NetworkGetResponseBodyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.getResponseBody',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns post data sent with the request. Returns an error when no data was sent with the request. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getRequestPostData.
pub fn (mut p NetworkDomain) get_request_post_data(par NetworkGetRequestPostDataParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.getRequestPostData',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns content served for the given currently intercepted request. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getResponseBodyForInterception.
pub fn (mut p NetworkDomain) get_response_body_for_interception(par NetworkGetResponseBodyForInterceptionParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.getResponseBodyForInterception',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns a handle to the stream representing the response body. Note that after this command,
// the intercepted request can't be continued as is -- you either need to cancel it or to provide
// the response body. The stream only supports sequential read, IO.read will fail if the position
// is specified. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-takeResponseBodyForInterceptionAsStream.
pub fn (mut p NetworkDomain) take_response_body_for_interception_as_stream(par NetworkTakeResponseBodyForInterceptionAsStreamParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.takeResponseBodyForInterceptionAsStream',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// This method sends a new XMLHttpRequest which is identical to the original one. The following
// parameters should be identical: method, url, async, request body, extra headers, withCredentials
// attribute, user, password. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-replayXHR.
pub fn (mut p NetworkDomain) replay_xhr(par NetworkReplayXHRParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.replayXHR',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Searches for given string in response content. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-searchInResponseBody.
pub fn (mut p NetworkDomain) search_in_response_body(par NetworkSearchInResponseBodyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.searchInResponseBody',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Blocks URLs from loading. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setBlockedURLs.
pub fn (mut p NetworkDomain) set_blocked_ur_ls(par NetworkSetBlockedURLsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.setBlockedURLs',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Toggles ignoring of service worker for each request. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setBypassServiceWorker.
pub fn (mut p NetworkDomain) set_bypass_service_worker(par NetworkSetBypassServiceWorkerParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.setBypassServiceWorker',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Toggles ignoring cache for each request. If `true`, cache will not be used. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setCacheDisabled.
pub fn (mut p NetworkDomain) set_cache_disabled(par NetworkSetCacheDisabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.setCacheDisabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setCookie.
pub fn (mut p NetworkDomain) set_cookie(par NetworkSetCookieParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.setCookie',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets given cookies. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setCookies.
pub fn (mut p NetworkDomain) set_cookies(par NetworkSetCookiesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.setCookies',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Specifies whether to always send extra HTTP headers with the requests from this page. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setExtraHTTPHeaders.
pub fn (mut p NetworkDomain) set_extra_http_headers(par NetworkSetExtraHTTPHeadersParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.setExtraHTTPHeaders',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Specifies whether to attach a page script stack id in requests see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setAttachDebugStack.
pub fn (mut p NetworkDomain) set_attach_debug_stack(par NetworkSetAttachDebugStackParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.setAttachDebugStack',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets the requests to intercept that match the provided patterns and optionally resource types.
// Deprecated, please use Fetch.enable instead. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setRequestInterception.
pub fn (mut p NetworkDomain) set_request_interception(par NetworkSetRequestInterceptionParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.setRequestInterception',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Allows overriding user agent with the given string. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-setUserAgentOverride.
pub fn (mut p NetworkDomain) set_user_agent_override(par NetworkSetUserAgentOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.setUserAgentOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables streaming of the response for the given requestId.
// If enabled, the dataReceived event contains the data that was received during streaming. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-streamResourceContent.
pub fn (mut p NetworkDomain) stream_resource_content(par NetworkStreamResourceContentParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.streamResourceContent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns information about the COEP/COOP isolation status. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-getSecurityIsolationStatus.
pub fn (mut p NetworkDomain) get_security_isolation_status(par NetworkGetSecurityIsolationStatusParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.getSecurityIsolationStatus',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables tracking for the Reporting API, events generated by the Reporting API will now be delivered to the client.
// Enabling triggers 'reportingApiReportAdded' for all existing reports. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-enableReportingApi.
pub fn (mut p NetworkDomain) enable_reporting_api(par NetworkEnableReportingApiParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.enableReportingApi',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fetches the resource and returns the content. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#method-loadNetworkResource.
pub fn (mut p NetworkDomain) load_network_resource(par NetworkLoadNetworkResourceParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Network.loadNetworkResource',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fired when data chunk was received over the network. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-dataReceived.
pub fn (mut p NetworkDomain) data_received(msg Message) !Result {
	return p.tab.send('Network.dataReceived', msg)!
}

// Fired when EventSource message is received. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-eventSourceMessageReceived.
pub fn (mut p NetworkDomain) event_source_message_received(msg Message) !Result {
	return p.tab.send('Network.eventSourceMessageReceived', msg)!
}

// Fired when HTTP request has failed to load. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-loadingFailed.
pub fn (mut p NetworkDomain) loading_failed(msg Message) !Result {
	return p.tab.send('Network.loadingFailed', msg)!
}

// Fired when HTTP request has finished loading. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-loadingFinished.
pub fn (mut p NetworkDomain) loading_finished(msg Message) !Result {
	return p.tab.send('Network.loadingFinished', msg)!
}

// Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
// mocked.
// Deprecated, use Fetch.requestPaused instead. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestIntercepted.
pub fn (mut p NetworkDomain) request_intercepted(msg Message) !Result {
	return p.tab.send('Network.requestIntercepted', msg)!
}

// Fired if request ended up loading from cache. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestServedFromCache.
pub fn (mut p NetworkDomain) request_served_from_cache(msg Message) !Result {
	return p.tab.send('Network.requestServedFromCache', msg)!
}

// Fired when page is about to send HTTP request. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSent.
pub fn (mut p NetworkDomain) request_will_be_sent(msg Message) !Result {
	return p.tab.send('Network.requestWillBeSent', msg)!
}

// Fired when resource loading priority is changed see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-resourceChangedPriority.
pub fn (mut p NetworkDomain) resource_changed_priority(msg Message) !Result {
	return p.tab.send('Network.resourceChangedPriority', msg)!
}

// Fired when a signed exchange was received over the network see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-signedExchangeReceived.
pub fn (mut p NetworkDomain) signed_exchange_received(msg Message) !Result {
	return p.tab.send('Network.signedExchangeReceived', msg)!
}

// Fired when HTTP response is available. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceived.
pub fn (mut p NetworkDomain) response_received(msg Message) !Result {
	return p.tab.send('Network.responseReceived', msg)!
}

// Fired when WebSocket is closed. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketClosed.
pub fn (mut p NetworkDomain) web_socket_closed(msg Message) !Result {
	return p.tab.send('Network.webSocketClosed', msg)!
}

// Fired upon WebSocket creation. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketCreated.
pub fn (mut p NetworkDomain) web_socket_created(msg Message) !Result {
	return p.tab.send('Network.webSocketCreated', msg)!
}

// Fired when WebSocket message error occurs. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketFrameError.
pub fn (mut p NetworkDomain) web_socket_frame_error(msg Message) !Result {
	return p.tab.send('Network.webSocketFrameError', msg)!
}

// Fired when WebSocket message is received. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketFrameReceived.
pub fn (mut p NetworkDomain) web_socket_frame_received(msg Message) !Result {
	return p.tab.send('Network.webSocketFrameReceived', msg)!
}

// Fired when WebSocket message is sent. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketFrameSent.
pub fn (mut p NetworkDomain) web_socket_frame_sent(msg Message) !Result {
	return p.tab.send('Network.webSocketFrameSent', msg)!
}

// Fired when WebSocket handshake response becomes available. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketHandshakeResponseReceived.
pub fn (mut p NetworkDomain) web_socket_handshake_response_received(msg Message) !Result {
	return p.tab.send('Network.webSocketHandshakeResponseReceived', msg)!
}

// Fired when WebSocket is about to initiate handshake. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webSocketWillSendHandshakeRequest.
pub fn (mut p NetworkDomain) web_socket_will_send_handshake_request(msg Message) !Result {
	return p.tab.send('Network.webSocketWillSendHandshakeRequest', msg)!
}

// Fired upon WebTransport creation. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webTransportCreated.
pub fn (mut p NetworkDomain) web_transport_created(msg Message) !Result {
	return p.tab.send('Network.webTransportCreated', msg)!
}

// Fired when WebTransport handshake is finished. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webTransportConnectionEstablished.
pub fn (mut p NetworkDomain) web_transport_connection_established(msg Message) !Result {
	return p.tab.send('Network.webTransportConnectionEstablished', msg)!
}

// Fired when WebTransport is disposed. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-webTransportClosed.
pub fn (mut p NetworkDomain) web_transport_closed(msg Message) !Result {
	return p.tab.send('Network.webTransportClosed', msg)!
}

// Fired when additional information about a requestWillBeSent event is available from the
// network stack. Not every requestWillBeSent event will have an additional
// requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
// or requestWillBeSentExtraInfo will be fired first for the same request. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-requestWillBeSentExtraInfo.
pub fn (mut p NetworkDomain) request_will_be_sent_extra_info(msg Message) !Result {
	return p.tab.send('Network.requestWillBeSentExtraInfo', msg)!
}

// Fired when additional information about a responseReceived event is available from the network
// stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
// it, and responseReceivedExtraInfo may be fired before or after responseReceived. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceivedExtraInfo.
pub fn (mut p NetworkDomain) response_received_extra_info(msg Message) !Result {
	return p.tab.send('Network.responseReceivedExtraInfo', msg)!
}

// Fired when 103 Early Hints headers is received in addition to the common response.
// Not every responseReceived event will have an responseReceivedEarlyHints fired.
// Only one responseReceivedEarlyHints may be fired for eached responseReceived event. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-responseReceivedEarlyHints.
pub fn (mut p NetworkDomain) response_received_early_hints(msg Message) !Result {
	return p.tab.send('Network.responseReceivedEarlyHints', msg)!
}

// Fired exactly once for each Trust Token operation. Depending on
// the type of the operation and whether the operation succeeded or
// failed, the event is fired before the corresponding request was sent
// or after the response was received. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-trustTokenOperationDone.
pub fn (mut p NetworkDomain) trust_token_operation_done(msg Message) !Result {
	return p.tab.send('Network.trustTokenOperationDone', msg)!
}

// Fired once security policy has been updated. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-policyUpdated.
pub fn (mut p NetworkDomain) policy_updated(msg Message) !Result {
	return p.tab.send('Network.policyUpdated', msg)!
}

// Fired once when parsing the .wbn file has succeeded.
// The event contains the information about the web bundle contents. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-subresourceWebBundleMetadataReceived.
pub fn (mut p NetworkDomain) subresource_web_bundle_metadata_received(msg Message) !Result {
	return p.tab.send('Network.subresourceWebBundleMetadataReceived', msg)!
}

// Fired once when parsing the .wbn file has failed. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-subresourceWebBundleMetadataError.
pub fn (mut p NetworkDomain) subresource_web_bundle_metadata_error(msg Message) !Result {
	return p.tab.send('Network.subresourceWebBundleMetadataError', msg)!
}

// Fired when handling requests for resources within a .wbn file.
// Note: this will only be fired for resources that are requested by the webpage. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-subresourceWebBundleInnerResponseParsed.
pub fn (mut p NetworkDomain) subresource_web_bundle_inner_response_parsed(msg Message) !Result {
	return p.tab.send('Network.subresourceWebBundleInnerResponseParsed', msg)!
}

// Fired when request for resources within a .wbn file failed. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-subresourceWebBundleInnerResponseError.
pub fn (mut p NetworkDomain) subresource_web_bundle_inner_response_error(msg Message) !Result {
	return p.tab.send('Network.subresourceWebBundleInnerResponseError', msg)!
}

// Is sent whenever a new report is added.
// And after 'enableReportingApi' for all existing reports. see https://chromedevtools.github.io/devtools-protocol/tot/Network/#event-reportingApiReportAdded.
pub fn (mut p NetworkDomain) reporting_api_report_added(msg Message) !Result {
	return p.tab.send('Network.reportingApiReportAdded', msg)!
}

pub fn (mut p NetworkDomain) reporting_api_report_updated(msg Message) !Result {
	return p.tab.send('Network.reportingApiReportUpdated', msg)!
}

pub fn (mut p NetworkDomain) reporting_api_endpoints_changed_for_origin(msg Message) !Result {
	return p.tab.send('Network.reportingApiEndpointsChangedForOrigin', msg)!
}

// This domain provides various functionality related to drawing atop the inspected page. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay.
pub struct OverlayDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Overlay domains.
pub fn (mut tab Tab) use_overlay(opts ConfigCDVDomain) !&OverlayDomain {
	if opts.enable && tab.is_inactive_deps('Overlay') {
		tab.send('Overlay.enable')!
		tab.deps << 'Overlay'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['DOM', 'Page', 'Runtime'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &OverlayDomain{tab}
}

// Disables domain notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-disable.
pub fn (mut p OverlayDomain) disable(msg Message) !Result {
	return p.tab.send('Overlay.disable', msg)!
}

// Enables domain notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-enable.
pub fn (mut p OverlayDomain) enable(msg Message) !Result {
	return p.tab.send('Overlay.enable', msg)!
}

// For testing. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-getHighlightObjectForTest.
pub fn (mut p OverlayDomain) get_highlight_object_for_test(par OverlayGetHighlightObjectForTestParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.getHighlightObjectForTest',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// For Persistent Grid testing. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-getGridHighlightObjectsForTest.
pub fn (mut p OverlayDomain) get_grid_highlight_objects_for_test(par OverlayGetGridHighlightObjectsForTestParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.getGridHighlightObjectsForTest',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// For Source Order Viewer testing. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-getSourceOrderHighlightObjectForTest.
pub fn (mut p OverlayDomain) get_source_order_highlight_object_for_test(par OverlayGetSourceOrderHighlightObjectForTestParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.getSourceOrderHighlightObjectForTest',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Hides any highlight. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-hideHighlight.
pub fn (mut p OverlayDomain) hide_highlight(msg Message) !Result {
	return p.tab.send('Overlay.hideHighlight', msg)!
}

// Highlights owner element of the frame with given id.
// Deprecated: Doesn't work reliably and cannot be fixed due to process
// separation (the owner node might be in a different process). Determine
// the owner node in the client and use highlightNode. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightFrame.
pub fn (mut p OverlayDomain) highlight_frame(par OverlayHighlightFrameParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.highlightFrame',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or
// objectId must be specified. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightNode.
pub fn (mut p OverlayDomain) highlight_node(par OverlayHighlightNodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.highlightNode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Highlights given quad. Coordinates are absolute with respect to the main frame viewport. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightQuad.
pub fn (mut p OverlayDomain) highlight_quad(par OverlayHighlightQuadParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.highlightQuad',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightRect.
pub fn (mut p OverlayDomain) highlight_rect(par OverlayHighlightRectParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.highlightRect',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Highlights the source order of the children of the DOM node with given id or with the given
// JavaScript object wrapper. Either nodeId or objectId must be specified. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-highlightSourceOrder.
pub fn (mut p OverlayDomain) highlight_source_order(par OverlayHighlightSourceOrderParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.highlightSourceOrder',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted.
// Backend then generates 'inspectNodeRequested' event upon element selection. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setInspectMode.
pub fn (mut p OverlayDomain) set_inspect_mode(par OverlaySetInspectModeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setInspectMode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Highlights owner element of all frames detected to be ads. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowAdHighlights.
pub fn (mut p OverlayDomain) set_show_ad_highlights(par OverlaySetShowAdHighlightsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowAdHighlights',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p OverlayDomain) set_paused_in_debugger_message(par OverlaySetPausedInDebuggerMessageParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setPausedInDebuggerMessage',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests that backend shows debug borders on layers see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowDebugBorders.
pub fn (mut p OverlayDomain) set_show_debug_borders(par OverlaySetShowDebugBordersParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowDebugBorders',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests that backend shows the FPS counter see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowFPSCounter.
pub fn (mut p OverlayDomain) set_show_fps_counter(par OverlaySetShowFPSCounterParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowFPSCounter',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Highlight multiple elements with the CSS Grid overlay. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowGridOverlays.
pub fn (mut p OverlayDomain) set_show_grid_overlays(par OverlaySetShowGridOverlaysParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowGridOverlays',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p OverlayDomain) set_show_flex_overlays(par OverlaySetShowFlexOverlaysParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowFlexOverlays',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p OverlayDomain) set_show_scroll_snap_overlays(par OverlaySetShowScrollSnapOverlaysParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowScrollSnapOverlays',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p OverlayDomain) set_show_container_query_overlays(par OverlaySetShowContainerQueryOverlaysParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowContainerQueryOverlays',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests that backend shows paint rectangles see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowPaintRects.
pub fn (mut p OverlayDomain) set_show_paint_rects(par OverlaySetShowPaintRectsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowPaintRects',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests that backend shows layout shift regions see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowLayoutShiftRegions.
pub fn (mut p OverlayDomain) set_show_layout_shift_regions(par OverlaySetShowLayoutShiftRegionsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowLayoutShiftRegions',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Requests that backend shows scroll bottleneck rects see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowScrollBottleneckRects.
pub fn (mut p OverlayDomain) set_show_scroll_bottleneck_rects(par OverlaySetShowScrollBottleneckRectsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowScrollBottleneckRects',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deprecated, no longer has any effect. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowHitTestBorders.
pub fn (mut p OverlayDomain) set_show_hit_test_borders(par OverlaySetShowHitTestBordersParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowHitTestBorders',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deprecated, no longer has any effect. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowWebVitals.
pub fn (mut p OverlayDomain) set_show_web_vitals(par OverlaySetShowWebVitalsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowWebVitals',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Paints viewport size upon main frame resize. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowViewportSizeOnResize.
pub fn (mut p OverlayDomain) set_show_viewport_size_on_resize(par OverlaySetShowViewportSizeOnResizeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowViewportSizeOnResize',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Add a dual screen device hinge see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowHinge.
pub fn (mut p OverlayDomain) set_show_hinge(par OverlaySetShowHingeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowHinge',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Show elements in isolation mode with overlays. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowIsolatedElements.
pub fn (mut p OverlayDomain) set_show_isolated_elements(par OverlaySetShowIsolatedElementsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowIsolatedElements',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Show Window Controls Overlay for PWA see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#method-setShowWindowControlsOverlay.
pub fn (mut p OverlayDomain) set_show_window_controls_overlay(par OverlaySetShowWindowControlsOverlayParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Overlay.setShowWindowControlsOverlay',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fired when the node should be inspected. This happens after call to `setInspectMode` or when
// user manually inspects an element. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#event-inspectNodeRequested.
pub fn (mut p OverlayDomain) inspect_node_requested(msg Message) !Result {
	return p.tab.send('Overlay.inspectNodeRequested', msg)!
}

// Fired when the node should be highlighted. This happens after call to `setInspectMode`. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#event-nodeHighlightRequested.
pub fn (mut p OverlayDomain) node_highlight_requested(msg Message) !Result {
	return p.tab.send('Overlay.nodeHighlightRequested', msg)!
}

// Fired when user asks to capture screenshot of some area on the page. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#event-screenshotRequested.
pub fn (mut p OverlayDomain) screenshot_requested(msg Message) !Result {
	return p.tab.send('Overlay.screenshotRequested', msg)!
}

// Fired when user cancels the inspect mode. see https://chromedevtools.github.io/devtools-protocol/tot/Overlay/#event-inspectModeCanceled.
pub fn (mut p OverlayDomain) inspect_mode_canceled(msg Message) !Result {
	return p.tab.send('Overlay.inspectModeCanceled', msg)!
}

// Actions and events related to the inspected page belong to the page domain. see https://chromedevtools.github.io/devtools-protocol/tot/Page.
pub struct PageDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Page domains.
pub fn (mut tab Tab) use_page(opts ConfigCDVDomain) !&PageDomain {
	if opts.enable && tab.is_inactive_deps('Page') {
		tab.send('Page.enable')!
		tab.deps << 'Page'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 {
			['Debugger', 'DOM', 'IO', 'Network', 'Runtime']
		} else {
			opts.deps
		}
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &PageDomain{tab}
}

// Deprecated, please use addScriptToEvaluateOnNewDocument instead. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-addScriptToEvaluateOnLoad.
pub fn (mut p PageDomain) add_script_to_evaluate_on_load(par PageAddScriptToEvaluateOnLoadParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.addScriptToEvaluateOnLoad',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Evaluates given script in every frame upon creation (before loading frame's scripts). see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-addScriptToEvaluateOnNewDocument.
pub fn (mut p PageDomain) add_script_to_evaluate_on_new_document(par PageAddScriptToEvaluateOnNewDocumentParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.addScriptToEvaluateOnNewDocument',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Brings page to front (activates tab). see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-bringToFront.
pub fn (mut p PageDomain) bring_to_front(msg Message) !Result {
	return p.tab.send('Page.bringToFront', msg)!
}

// Capture page screenshot. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-captureScreenshot.
pub fn (mut p PageDomain) capture_screenshot(par PageCaptureScreenshotParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.captureScreenshot',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns a snapshot of the page as a string. For MHTML format, the serialization includes
// iframes, shadow DOM, external resources, and element-inline styles. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-captureSnapshot.
pub fn (mut p PageDomain) capture_snapshot(par PageCaptureSnapshotParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.captureSnapshot',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears the overridden device metrics. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-clearDeviceMetricsOverride.
pub fn (mut p PageDomain) clear_device_metrics_override(msg Message) !Result {
	return p.tab.send('Page.clearDeviceMetricsOverride', msg)!
}

// Clears the overridden Device Orientation. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-clearDeviceOrientationOverride.
pub fn (mut p PageDomain) clear_device_orientation_override(msg Message) !Result {
	return p.tab.send('Page.clearDeviceOrientationOverride', msg)!
}

// Clears the overridden Geolocation Position and Error. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-clearGeolocationOverride.
pub fn (mut p PageDomain) clear_geolocation_override(msg Message) !Result {
	return p.tab.send('Page.clearGeolocationOverride', msg)!
}

// Creates an isolated world for the given frame. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-createIsolatedWorld.
pub fn (mut p PageDomain) create_isolated_world(par PageCreateIsolatedWorldParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.createIsolatedWorld',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deletes browser cookie with given name, domain and path. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-deleteCookie.
pub fn (mut p PageDomain) delete_cookie(par PageDeleteCookieParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.deleteCookie',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables page domain notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-disable.
pub fn (mut p PageDomain) disable(msg Message) !Result {
	return p.tab.send('Page.disable', msg)!
}

// Enables page domain notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-enable.
pub fn (mut p PageDomain) enable(msg Message) !Result {
	return p.tab.send('Page.enable', msg)!
}

// Gets the processed manifest for this current document.
//  This API always waits for the manifest to be loaded.
//  If manifestId is provided, and it does not match the manifest of the
//    current document, this API errors out.
//  If there is not a loaded page, this API errors out immediately. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getAppManifest.
pub fn (mut p PageDomain) get_app_manifest(par PageGetAppManifestParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.getAppManifest',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p PageDomain) get_installability_errors(msg Message) !Result {
	return p.tab.send('Page.getInstallabilityErrors', msg)!
}

// Deprecated because it's not guaranteed that the returned icon is in fact the one used for PWA installation. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getManifestIcons.
pub fn (mut p PageDomain) get_manifest_icons(msg Message) !Result {
	return p.tab.send('Page.getManifestIcons', msg)!
}

// Returns the unique (PWA) app id.
// Only returns values if the feature flag 'WebAppEnableManifestId' is enabled see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getAppId.
pub fn (mut p PageDomain) get_app_id(msg Message) !Result {
	return p.tab.send('Page.getAppId', msg)!
}

pub fn (mut p PageDomain) get_ad_script_id(par PageGetAdScriptIdParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.getAdScriptId',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns present frame tree structure. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getFrameTree.
pub fn (mut p PageDomain) get_frame_tree(msg Message) !Result {
	return p.tab.send('Page.getFrameTree', msg)!
}

// Returns metrics relating to the layouting of the page, such as viewport bounds/scale. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getLayoutMetrics.
pub fn (mut p PageDomain) get_layout_metrics(msg Message) !Result {
	return p.tab.send('Page.getLayoutMetrics', msg)!
}

// Returns navigation history for the current page. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getNavigationHistory.
pub fn (mut p PageDomain) get_navigation_history(msg Message) !Result {
	return p.tab.send('Page.getNavigationHistory', msg)!
}

// Resets navigation history for the current page. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-resetNavigationHistory.
pub fn (mut p PageDomain) reset_navigation_history(msg Message) !Result {
	return p.tab.send('Page.resetNavigationHistory', msg)!
}

// Returns content of the given resource. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getResourceContent.
pub fn (mut p PageDomain) get_resource_content(par PageGetResourceContentParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.getResourceContent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns present frame / resource tree structure. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getResourceTree.
pub fn (mut p PageDomain) get_resource_tree(msg Message) !Result {
	return p.tab.send('Page.getResourceTree', msg)!
}

// Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload). see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-handleJavaScriptDialog.
pub fn (mut p PageDomain) handle_java_script_dialog(par PageHandleJavaScriptDialogParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.handleJavaScriptDialog',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Navigates current page to the given URL. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-navigate.
pub fn (mut p PageDomain) navigate(par PageNavigateParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.navigate',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Navigates current page to the given history entry. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-navigateToHistoryEntry.
pub fn (mut p PageDomain) navigate_to_history_entry(par PageNavigateToHistoryEntryParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.navigateToHistoryEntry',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Print page as PDF. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-printToPDF.
pub fn (mut p PageDomain) print_to_pdf(par PagePrintToPDFParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.printToPDF',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Reloads given page optionally ignoring the cache. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-reload.
pub fn (mut p PageDomain) reload(par PageReloadParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.reload',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deprecated, please use removeScriptToEvaluateOnNewDocument instead. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-removeScriptToEvaluateOnLoad.
pub fn (mut p PageDomain) remove_script_to_evaluate_on_load(par PageRemoveScriptToEvaluateOnLoadParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.removeScriptToEvaluateOnLoad',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes given script from the list. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-removeScriptToEvaluateOnNewDocument.
pub fn (mut p PageDomain) remove_script_to_evaluate_on_new_document(par PageRemoveScriptToEvaluateOnNewDocumentParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.removeScriptToEvaluateOnNewDocument',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Acknowledges that a screencast frame has been received by the frontend. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-screencastFrameAck.
pub fn (mut p PageDomain) screencast_frame_ack(par PageScreencastFrameAckParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.screencastFrameAck',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Searches for given string in resource content. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-searchInResource.
pub fn (mut p PageDomain) search_in_resource(par PageSearchInResourceParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.searchInResource',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enable Chrome's experimental ad filter on all sites. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setAdBlockingEnabled.
pub fn (mut p PageDomain) set_ad_blocking_enabled(par PageSetAdBlockingEnabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setAdBlockingEnabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enable page Content Security Policy by-passing. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setBypassCSP.
pub fn (mut p PageDomain) set_bypass_csp(par PageSetBypassCSPParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setBypassCSP',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Get Permissions Policy state on given frame. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getPermissionsPolicyState.
pub fn (mut p PageDomain) get_permissions_policy_state(par PageGetPermissionsPolicyStateParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.getPermissionsPolicyState',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Get Origin Trials on given frame. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-getOriginTrials.
pub fn (mut p PageDomain) get_origin_trials(par PageGetOriginTrialsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.getOriginTrials',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Overrides the values of device screen dimensions (window.screen.width, window.screen.height,
// window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media
// query results). see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setDeviceMetricsOverride.
pub fn (mut p PageDomain) set_device_metrics_override(par PageSetDeviceMetricsOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setDeviceMetricsOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Overrides the Device Orientation. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setDeviceOrientationOverride.
pub fn (mut p PageDomain) set_device_orientation_override(par PageSetDeviceOrientationOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setDeviceOrientationOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Set generic font families. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setFontFamilies.
pub fn (mut p PageDomain) set_font_families(par PageSetFontFamiliesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setFontFamilies',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Set default font sizes. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setFontSizes.
pub fn (mut p PageDomain) set_font_sizes(par PageSetFontSizesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setFontSizes',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets given markup as the document's HTML. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setDocumentContent.
pub fn (mut p PageDomain) set_document_content(par PageSetDocumentContentParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setDocumentContent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Set the behavior when downloading a file. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setDownloadBehavior.
pub fn (mut p PageDomain) set_download_behavior(par PageSetDownloadBehaviorParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setDownloadBehavior',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position
// unavailable. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setGeolocationOverride.
pub fn (mut p PageDomain) set_geolocation_override(par PageSetGeolocationOverrideParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setGeolocationOverride',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Controls whether page will emit lifecycle events. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setLifecycleEventsEnabled.
pub fn (mut p PageDomain) set_lifecycle_events_enabled(par PageSetLifecycleEventsEnabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setLifecycleEventsEnabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Toggles mouse event-based touch event emulation. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setTouchEmulationEnabled.
pub fn (mut p PageDomain) set_touch_emulation_enabled(par PageSetTouchEmulationEnabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setTouchEmulationEnabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Starts sending each frame using the `screencastFrame` event. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-startScreencast.
pub fn (mut p PageDomain) start_screencast(par PageStartScreencastParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.startScreencast',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Force the page stop all navigations and pending resource fetches. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-stopLoading.
pub fn (mut p PageDomain) stop_loading(msg Message) !Result {
	return p.tab.send('Page.stopLoading', msg)!
}

// Crashes renderer on the IO thread, generates minidumps. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-crash.
pub fn (mut p PageDomain) crash(msg Message) !Result {
	return p.tab.send('Page.crash', msg)!
}

// Tries to close page, running its beforeunload hooks, if any. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-close.
pub fn (mut p PageDomain) close(msg Message) !Result {
	return p.tab.send('Page.close', msg)!
}

// Tries to update the web lifecycle state of the page.
// It will transition the page to the given state according to:
// https://github.com/WICG/web-lifecycle/ see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setWebLifecycleState.
pub fn (mut p PageDomain) set_web_lifecycle_state(par PageSetWebLifecycleStateParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setWebLifecycleState',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Stops sending each frame in the `screencastFrame`. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-stopScreencast.
pub fn (mut p PageDomain) stop_screencast(msg Message) !Result {
	return p.tab.send('Page.stopScreencast', msg)!
}

// Requests backend to produce compilation cache for the specified scripts.
//`scripts` are appended to the list of scripts for which the cache
// would be produced. The list may be reset during page navigation.
// When script with a matching URL is encountered, the cache is optionally
// produced upon backend discretion, based on internal heuristics.
// See also: `Page.compilationCacheProduced`. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-produceCompilationCache.
pub fn (mut p PageDomain) produce_compilation_cache(par PageProduceCompilationCacheParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.produceCompilationCache',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Seeds compilation cache for given url. Compilation cache does not survive
// cross-process navigation. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-addCompilationCache.
pub fn (mut p PageDomain) add_compilation_cache(par PageAddCompilationCacheParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.addCompilationCache',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears seeded compilation cache. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-clearCompilationCache.
pub fn (mut p PageDomain) clear_compilation_cache(msg Message) !Result {
	return p.tab.send('Page.clearCompilationCache', msg)!
}

// Sets the Secure Payment Confirmation transaction mode.
// https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setSPCTransactionMode.
pub fn (mut p PageDomain) set_spc_transaction_mode(par PageSetSPCTransactionModeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setSPCTransactionMode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Extensions for Custom Handlers API:
// https://html.spec.whatwg.org/multipage/system-state.html#rph-automation see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setRPHRegistrationMode.
pub fn (mut p PageDomain) set_rph_registration_mode(par PageSetRPHRegistrationModeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setRPHRegistrationMode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Generates a report for testing. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-generateTestReport.
pub fn (mut p PageDomain) generate_test_report(par PageGenerateTestReportParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.generateTestReport',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Pauses page execution. Can be resumed using generic Runtime.runIfWaitingForDebugger. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-waitForDebugger.
pub fn (mut p PageDomain) wait_for_debugger(msg Message) !Result {
	return p.tab.send('Page.waitForDebugger', msg)!
}

// Intercept file chooser requests and transfer control to protocol clients.
// When file chooser interception is enabled, native file chooser dialog is not shown.
// Instead, a protocol event `Page.fileChooserOpened` is emitted. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setInterceptFileChooserDialog.
pub fn (mut p PageDomain) set_intercept_file_chooser_dialog(par PageSetInterceptFileChooserDialogParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setInterceptFileChooserDialog',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enable/disable prerendering manually.
//
// This command is a short-term solution for https://crbug.com/1440085.
// See https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
// for more details.
//
// TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab targets. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#method-setPrerenderingAllowed.
pub fn (mut p PageDomain) set_prerendering_allowed(par PageSetPrerenderingAllowedParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Page.setPrerenderingAllowed',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p PageDomain) dom_content_event_fired(msg Message) !Result {
	return p.tab.send('Page.domContentEventFired', msg)!
}

// Emitted only when `page.interceptFileChooser` is enabled. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-fileChooserOpened.
pub fn (mut p PageDomain) file_chooser_opened(msg Message) !Result {
	return p.tab.send('Page.fileChooserOpened', msg)!
}

// Fired when frame has been attached to its parent. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameAttached.
pub fn (mut p PageDomain) frame_attached(msg Message) !Result {
	return p.tab.send('Page.frameAttached', msg)!
}

// Fired when frame no longer has a scheduled navigation. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameClearedScheduledNavigation.
pub fn (mut p PageDomain) frame_cleared_scheduled_navigation(msg Message) !Result {
	return p.tab.send('Page.frameClearedScheduledNavigation', msg)!
}

// Fired when frame has been detached from its parent. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameDetached.
pub fn (mut p PageDomain) frame_detached(msg Message) !Result {
	return p.tab.send('Page.frameDetached', msg)!
}

// Fired before frame subtree is detached. Emitted before any frame of the
// subtree is actually detached. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameSubtreeWillBeDetached.
pub fn (mut p PageDomain) frame_subtree_will_be_detached(msg Message) !Result {
	return p.tab.send('Page.frameSubtreeWillBeDetached', msg)!
}

// Fired once navigation of the frame has completed. Frame is now associated with the new loader. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameNavigated.
pub fn (mut p PageDomain) frame_navigated(msg Message) !Result {
	return p.tab.send('Page.frameNavigated', msg)!
}

// Fired when opening document to write to. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-documentOpened.
pub fn (mut p PageDomain) document_opened(msg Message) !Result {
	return p.tab.send('Page.documentOpened', msg)!
}

pub fn (mut p PageDomain) frame_resized(msg Message) !Result {
	return p.tab.send('Page.frameResized', msg)!
}

// Fired when a renderer-initiated navigation is requested.
// Navigation may still be cancelled after the event is issued. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameRequestedNavigation.
pub fn (mut p PageDomain) frame_requested_navigation(msg Message) !Result {
	return p.tab.send('Page.frameRequestedNavigation', msg)!
}

// Fired when frame schedules a potential navigation. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameScheduledNavigation.
pub fn (mut p PageDomain) frame_scheduled_navigation(msg Message) !Result {
	return p.tab.send('Page.frameScheduledNavigation', msg)!
}

// Fired when frame has started loading. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameStartedLoading.
pub fn (mut p PageDomain) frame_started_loading(msg Message) !Result {
	return p.tab.send('Page.frameStartedLoading', msg)!
}

// Fired when frame has stopped loading. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-frameStoppedLoading.
pub fn (mut p PageDomain) frame_stopped_loading(msg Message) !Result {
	return p.tab.send('Page.frameStoppedLoading', msg)!
}

// Fired when page is about to start a download.
// Deprecated. Use Browser.downloadWillBegin instead. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-downloadWillBegin.
pub fn (mut p PageDomain) download_will_begin(msg Message) !Result {
	return p.tab.send('Page.downloadWillBegin', msg)!
}

// Fired when download makes progress. Last call has |done| == true.
// Deprecated. Use Browser.downloadProgress instead. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-downloadProgress.
pub fn (mut p PageDomain) download_progress(msg Message) !Result {
	return p.tab.send('Page.downloadProgress', msg)!
}

// Fired when interstitial page was hidden see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-interstitialHidden.
pub fn (mut p PageDomain) interstitial_hidden(msg Message) !Result {
	return p.tab.send('Page.interstitialHidden', msg)!
}

// Fired when interstitial page was shown see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-interstitialShown.
pub fn (mut p PageDomain) interstitial_shown(msg Message) !Result {
	return p.tab.send('Page.interstitialShown', msg)!
}

// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been
// closed. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogClosed.
pub fn (mut p PageDomain) javascript_dialog_closed(msg Message) !Result {
	return p.tab.send('Page.javascriptDialogClosed', msg)!
}

// Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to
// open. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-javascriptDialogOpening.
pub fn (mut p PageDomain) javascript_dialog_opening(msg Message) !Result {
	return p.tab.send('Page.javascriptDialogOpening', msg)!
}

// Fired for lifecycle events (navigation, load, paint, etc) in the current
// target (including local frames). see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-lifecycleEvent.
pub fn (mut p PageDomain) lifecycle_event(msg Message) !Result {
	return p.tab.send('Page.lifecycleEvent', msg)!
}

// Fired for failed bfcache history navigations if BackForwardCache feature is enabled. Do
// not assume any ordering with the Page.frameNavigated event. This event is fired only for
// main-frame history navigation where the document changes (non-same-document navigations),
// when bfcache navigation fails. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-backForwardCacheNotUsed.
pub fn (mut p PageDomain) back_forward_cache_not_used(msg Message) !Result {
	return p.tab.send('Page.backForwardCacheNotUsed', msg)!
}

pub fn (mut p PageDomain) load_event_fired(msg Message) !Result {
	return p.tab.send('Page.loadEventFired', msg)!
}

// Fired when same-document navigation happens, e.g. due to history API usage or anchor navigation. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-navigatedWithinDocument.
pub fn (mut p PageDomain) navigated_within_document(msg Message) !Result {
	return p.tab.send('Page.navigatedWithinDocument', msg)!
}

// Compressed image data requested by the `startScreencast`. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-screencastFrame.
pub fn (mut p PageDomain) screencast_frame(msg Message) !Result {
	return p.tab.send('Page.screencastFrame', msg)!
}

// Fired when the page with currently enabled screencast was shown or hidden `. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-screencastVisibilityChanged.
pub fn (mut p PageDomain) screencast_visibility_changed(msg Message) !Result {
	return p.tab.send('Page.screencastVisibilityChanged', msg)!
}

// Fired when a new window is going to be opened, via window.open(), link click, form submission,
// etc. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-windowOpen.
pub fn (mut p PageDomain) window_open(msg Message) !Result {
	return p.tab.send('Page.windowOpen', msg)!
}

// Issued for every compilation cache generated. Is only available
// if Page.setGenerateCompilationCache is enabled. see https://chromedevtools.github.io/devtools-protocol/tot/Page/#event-compilationCacheProduced.
pub fn (mut p PageDomain) compilation_cache_produced(msg Message) !Result {
	return p.tab.send('Page.compilationCacheProduced', msg)!
}

pub struct PerformanceDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Performance domains.
pub fn (mut tab Tab) use_performance(opts ConfigCDVDomain) !&PerformanceDomain {
	if opts.enable && tab.is_inactive_deps('Performance') {
		tab.send('Performance.enable')!
		tab.deps << 'Performance'
	}

	return &PerformanceDomain{tab}
}

// Disable collecting and reporting metrics. see https://chromedevtools.github.io/devtools-protocol/tot/Performance/#method-disable.
pub fn (mut p PerformanceDomain) disable(msg Message) !Result {
	return p.tab.send('Performance.disable', msg)!
}

// Enable collecting and reporting metrics. see https://chromedevtools.github.io/devtools-protocol/tot/Performance/#method-enable.
pub fn (mut p PerformanceDomain) enable(par PerformanceEnableParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Performance.enable',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets time domain to use for collecting and reporting duration metrics.
// Note that this must be called before enabling metrics collection. Calling
// this method while metrics collection is enabled returns an error. see https://chromedevtools.github.io/devtools-protocol/tot/Performance/#method-setTimeDomain.
pub fn (mut p PerformanceDomain) set_time_domain(par PerformanceSetTimeDomainParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Performance.setTimeDomain',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Retrieve current values of run-time metrics. see https://chromedevtools.github.io/devtools-protocol/tot/Performance/#method-getMetrics.
pub fn (mut p PerformanceDomain) get_metrics(msg Message) !Result {
	return p.tab.send('Performance.getMetrics', msg)!
}

// Current values of the metrics. see https://chromedevtools.github.io/devtools-protocol/tot/Performance/#event-metrics.
pub fn (mut p PerformanceDomain) metrics(msg Message) !Result {
	return p.tab.send('Performance.metrics', msg)!
}

// Reporting of performance timeline events, as specified in
// https://w3c.github.io/performance-timeline/#dom-performanceobserver. see https://chromedevtools.github.io/devtools-protocol/tot/PerformanceTimeline.
pub struct PerformanceTimelineDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use PerformanceTimeline domains.
pub fn (mut tab Tab) use_performance_timeline(opts ConfigCDVDomain) !&PerformanceTimelineDomain {
	if opts.enable && tab.is_inactive_deps('PerformanceTimeline') {
		tab.send('PerformanceTimeline.enable')!
		tab.deps << 'PerformanceTimeline'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['DOM', 'Network'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &PerformanceTimelineDomain{tab}
}

// Previously buffered events would be reported before method returns.
// See also: timelineEventAdded see https://chromedevtools.github.io/devtools-protocol/tot/PerformanceTimeline/#method-enable.
pub fn (mut p PerformanceTimelineDomain) enable(par PerformanceTimelineEnableParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('PerformanceTimeline.enable',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sent when a performance timeline event is added. See reportPerformanceTimeline method. see https://chromedevtools.github.io/devtools-protocol/tot/PerformanceTimeline/#event-timelineEventAdded.
pub fn (mut p PerformanceTimelineDomain) timeline_event_added(msg Message) !Result {
	return p.tab.send('PerformanceTimeline.timelineEventAdded', msg)!
}

// Security see https://chromedevtools.github.io/devtools-protocol/tot/Security.
pub struct SecurityDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Security domains.
pub fn (mut tab Tab) use_security(opts ConfigCDVDomain) !&SecurityDomain {
	if opts.enable && tab.is_inactive_deps('Security') {
		tab.send('Security.enable')!
		tab.deps << 'Security'
	}

	return &SecurityDomain{tab}
}

// Disables tracking security state changes. see https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-disable.
pub fn (mut p SecurityDomain) disable(msg Message) !Result {
	return p.tab.send('Security.disable', msg)!
}

// Enables tracking security state changes. see https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-enable.
pub fn (mut p SecurityDomain) enable(msg Message) !Result {
	return p.tab.send('Security.enable', msg)!
}

// Enable/disable whether all certificate errors should be ignored. see https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-setIgnoreCertificateErrors.
pub fn (mut p SecurityDomain) set_ignore_certificate_errors(par SecuritySetIgnoreCertificateErrorsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Security.setIgnoreCertificateErrors',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Handles a certificate error that fired a certificateError event. see https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-handleCertificateError.
pub fn (mut p SecurityDomain) handle_certificate_error(par SecurityHandleCertificateErrorParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Security.handleCertificateError',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enable/disable overriding certificate errors. If enabled, all certificate error events need to
// be handled by the DevTools client and should be answered with `handleCertificateError` commands. see https://chromedevtools.github.io/devtools-protocol/tot/Security/#method-setOverrideCertificateErrors.
pub fn (mut p SecurityDomain) set_override_certificate_errors(par SecuritySetOverrideCertificateErrorsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Security.setOverrideCertificateErrors',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// There is a certificate error. If overriding certificate errors is enabled, then it should be
// handled with the `handleCertificateError` command. Note: this event does not fire if the
// certificate error has been allowed internally. Only one client per target should override
// certificate errors at the same time. see https://chromedevtools.github.io/devtools-protocol/tot/Security/#event-certificateError.
pub fn (mut p SecurityDomain) certificate_error(msg Message) !Result {
	return p.tab.send('Security.certificateError', msg)!
}

// The security state of the page changed. see https://chromedevtools.github.io/devtools-protocol/tot/Security/#event-visibleSecurityStateChanged.
pub fn (mut p SecurityDomain) visible_security_state_changed(msg Message) !Result {
	return p.tab.send('Security.visibleSecurityStateChanged', msg)!
}

// The security state of the page changed. No longer being sent. see https://chromedevtools.github.io/devtools-protocol/tot/Security/#event-securityStateChanged.
pub fn (mut p SecurityDomain) security_state_changed(msg Message) !Result {
	return p.tab.send('Security.securityStateChanged', msg)!
}

pub struct ServiceWorkerDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use ServiceWorker domains.
pub fn (mut tab Tab) use_service_worker(opts ConfigCDVDomain) !&ServiceWorkerDomain {
	if opts.enable && tab.is_inactive_deps('ServiceWorker') {
		tab.send('ServiceWorker.enable')!
		tab.deps << 'ServiceWorker'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Target'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &ServiceWorkerDomain{tab}
}

pub fn (mut p ServiceWorkerDomain) deliver_push_message(par ServiceWorkerDeliverPushMessageParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('ServiceWorker.deliverPushMessage',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ServiceWorkerDomain) disable(msg Message) !Result {
	return p.tab.send('ServiceWorker.disable', msg)!
}

pub fn (mut p ServiceWorkerDomain) dispatch_sync_event(par ServiceWorkerDispatchSyncEventParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('ServiceWorker.dispatchSyncEvent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ServiceWorkerDomain) dispatch_periodic_sync_event(par ServiceWorkerDispatchPeriodicSyncEventParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('ServiceWorker.dispatchPeriodicSyncEvent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ServiceWorkerDomain) enable(msg Message) !Result {
	return p.tab.send('ServiceWorker.enable', msg)!
}

pub fn (mut p ServiceWorkerDomain) inspect_worker(par ServiceWorkerInspectWorkerParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('ServiceWorker.inspectWorker',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ServiceWorkerDomain) set_force_update_on_page_load(par ServiceWorkerSetForceUpdateOnPageLoadParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('ServiceWorker.setForceUpdateOnPageLoad',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ServiceWorkerDomain) skip_waiting(par ServiceWorkerSkipWaitingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('ServiceWorker.skipWaiting',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ServiceWorkerDomain) start_worker(par ServiceWorkerStartWorkerParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('ServiceWorker.startWorker',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ServiceWorkerDomain) stop_all_workers(msg Message) !Result {
	return p.tab.send('ServiceWorker.stopAllWorkers', msg)!
}

pub fn (mut p ServiceWorkerDomain) stop_worker(par ServiceWorkerStopWorkerParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('ServiceWorker.stopWorker',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ServiceWorkerDomain) unregister(par ServiceWorkerUnregisterParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('ServiceWorker.unregister',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ServiceWorkerDomain) update_registration(par ServiceWorkerUpdateRegistrationParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('ServiceWorker.updateRegistration',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ServiceWorkerDomain) worker_error_reported(msg Message) !Result {
	return p.tab.send('ServiceWorker.workerErrorReported', msg)!
}

pub fn (mut p ServiceWorkerDomain) worker_registration_updated(msg Message) !Result {
	return p.tab.send('ServiceWorker.workerRegistrationUpdated', msg)!
}

pub fn (mut p ServiceWorkerDomain) worker_version_updated(msg Message) !Result {
	return p.tab.send('ServiceWorker.workerVersionUpdated', msg)!
}

pub struct StorageDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Storage domains.
pub fn (mut tab Tab) use_storage(opts ConfigCDVDomain) !&StorageDomain {
	if opts.enable && tab.is_inactive_deps('Storage') {
		tab.send('Storage.enable')!
		tab.deps << 'Storage'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Browser', 'Network'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &StorageDomain{tab}
}

// Returns a storage key given a frame id. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getStorageKeyForFrame.
pub fn (mut p StorageDomain) get_storage_key_for_frame(par StorageGetStorageKeyForFrameParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.getStorageKeyForFrame',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears storage for origin. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearDataForOrigin.
pub fn (mut p StorageDomain) clear_data_for_origin(par StorageClearDataForOriginParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.clearDataForOrigin',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears storage for storage key. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearDataForStorageKey.
pub fn (mut p StorageDomain) clear_data_for_storage_key(par StorageClearDataForStorageKeyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.clearDataForStorageKey',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns all browser cookies. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getCookies.
pub fn (mut p StorageDomain) get_cookies(par StorageGetCookiesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.getCookies',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets given cookies. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setCookies.
pub fn (mut p StorageDomain) set_cookies(par StorageSetCookiesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.setCookies',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears cookies. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearCookies.
pub fn (mut p StorageDomain) clear_cookies(par StorageClearCookiesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.clearCookies',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns usage and quota in bytes. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getUsageAndQuota.
pub fn (mut p StorageDomain) get_usage_and_quota(par StorageGetUsageAndQuotaParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.getUsageAndQuota',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Override quota for the specified origin see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-overrideQuotaForOrigin.
pub fn (mut p StorageDomain) override_quota_for_origin(par StorageOverrideQuotaForOriginParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.overrideQuotaForOrigin',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Registers origin to be notified when an update occurs to its cache storage list. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-trackCacheStorageForOrigin.
pub fn (mut p StorageDomain) track_cache_storage_for_origin(par StorageTrackCacheStorageForOriginParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.trackCacheStorageForOrigin',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Registers storage key to be notified when an update occurs to its cache storage list. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-trackCacheStorageForStorageKey.
pub fn (mut p StorageDomain) track_cache_storage_for_storage_key(par StorageTrackCacheStorageForStorageKeyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.trackCacheStorageForStorageKey',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Registers origin to be notified when an update occurs to its IndexedDB. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-trackIndexedDBForOrigin.
pub fn (mut p StorageDomain) track_indexed_db_for_origin(par StorageTrackIndexedDBForOriginParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.trackIndexedDBForOrigin',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Registers storage key to be notified when an update occurs to its IndexedDB. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-trackIndexedDBForStorageKey.
pub fn (mut p StorageDomain) track_indexed_db_for_storage_key(par StorageTrackIndexedDBForStorageKeyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.trackIndexedDBForStorageKey',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Unregisters origin from receiving notifications for cache storage. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-untrackCacheStorageForOrigin.
pub fn (mut p StorageDomain) untrack_cache_storage_for_origin(par StorageUntrackCacheStorageForOriginParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.untrackCacheStorageForOrigin',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Unregisters storage key from receiving notifications for cache storage. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-untrackCacheStorageForStorageKey.
pub fn (mut p StorageDomain) untrack_cache_storage_for_storage_key(par StorageUntrackCacheStorageForStorageKeyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.untrackCacheStorageForStorageKey',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Unregisters origin from receiving notifications for IndexedDB. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-untrackIndexedDBForOrigin.
pub fn (mut p StorageDomain) untrack_indexed_db_for_origin(par StorageUntrackIndexedDBForOriginParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.untrackIndexedDBForOrigin',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Unregisters storage key from receiving notifications for IndexedDB. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-untrackIndexedDBForStorageKey.
pub fn (mut p StorageDomain) untrack_indexed_db_for_storage_key(par StorageUntrackIndexedDBForStorageKeyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.untrackIndexedDBForStorageKey',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the number of stored Trust Tokens per issuer for the
// current browsing context. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getTrustTokens.
pub fn (mut p StorageDomain) get_trust_tokens(msg Message) !Result {
	return p.tab.send('Storage.getTrustTokens', msg)!
}

// Removes all Trust Tokens issued by the provided issuerOrigin.
// Leaves other stored data, including the issuer's Redemption Records, intact. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearTrustTokens.
pub fn (mut p StorageDomain) clear_trust_tokens(par StorageClearTrustTokensParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.clearTrustTokens',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Gets details for a named interest group. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getInterestGroupDetails.
pub fn (mut p StorageDomain) get_interest_group_details(par StorageGetInterestGroupDetailsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.getInterestGroupDetails',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables/Disables issuing of interestGroupAccessed events. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setInterestGroupTracking.
pub fn (mut p StorageDomain) set_interest_group_tracking(par StorageSetInterestGroupTrackingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.setInterestGroupTracking',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables/Disables issuing of interestGroupAuctionEventOccurred and
// interestGroupAuctionNetworkRequestCreated. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setInterestGroupAuctionTracking.
pub fn (mut p StorageDomain) set_interest_group_auction_tracking(par StorageSetInterestGroupAuctionTrackingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.setInterestGroupAuctionTracking',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Gets metadata for an origin's shared storage. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getSharedStorageMetadata.
pub fn (mut p StorageDomain) get_shared_storage_metadata(par StorageGetSharedStorageMetadataParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.getSharedStorageMetadata',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Gets the entries in an given origin's shared storage. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getSharedStorageEntries.
pub fn (mut p StorageDomain) get_shared_storage_entries(par StorageGetSharedStorageEntriesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.getSharedStorageEntries',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets entry with `key` and `value` for a given origin's shared storage. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setSharedStorageEntry.
pub fn (mut p StorageDomain) set_shared_storage_entry(par StorageSetSharedStorageEntryParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.setSharedStorageEntry',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deletes entry for `key` (if it exists) for a given origin's shared storage. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-deleteSharedStorageEntry.
pub fn (mut p StorageDomain) delete_shared_storage_entry(par StorageDeleteSharedStorageEntryParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.deleteSharedStorageEntry',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears all entries for a given origin's shared storage. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-clearSharedStorageEntries.
pub fn (mut p StorageDomain) clear_shared_storage_entries(par StorageClearSharedStorageEntriesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.clearSharedStorageEntries',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Resets the budget for `ownerOrigin` by clearing all budget withdrawals. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-resetSharedStorageBudget.
pub fn (mut p StorageDomain) reset_shared_storage_budget(par StorageResetSharedStorageBudgetParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.resetSharedStorageBudget',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables/disables issuing of sharedStorageAccessed events. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setSharedStorageTracking.
pub fn (mut p StorageDomain) set_shared_storage_tracking(par StorageSetSharedStorageTrackingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.setSharedStorageTracking',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Set tracking for a storage key's buckets. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setStorageBucketTracking.
pub fn (mut p StorageDomain) set_storage_bucket_tracking(par StorageSetStorageBucketTrackingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.setStorageBucketTracking',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deletes the Storage Bucket with the given storage key and bucket name. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-deleteStorageBucket.
pub fn (mut p StorageDomain) delete_storage_bucket(par StorageDeleteStorageBucketParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.deleteStorageBucket',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deletes state for sites identified as potential bounce trackers, immediately. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-runBounceTrackingMitigations.
pub fn (mut p StorageDomain) run_bounce_tracking_mitigations(msg Message) !Result {
	return p.tab.send('Storage.runBounceTrackingMitigations', msg)!
}

// https://wicg.github.io/attribution-reporting-api/ see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setAttributionReportingLocalTestingMode.
pub fn (mut p StorageDomain) set_attribution_reporting_local_testing_mode(par StorageSetAttributionReportingLocalTestingModeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.setAttributionReportingLocalTestingMode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables/disables issuing of Attribution Reporting events. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-setAttributionReportingTracking.
pub fn (mut p StorageDomain) set_attribution_reporting_tracking(par StorageSetAttributionReportingTrackingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Storage.setAttributionReportingTracking',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sends all pending Attribution Reports immediately, regardless of their
// scheduled report time. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-sendPendingAttributionReports.
pub fn (mut p StorageDomain) send_pending_attribution_reports(msg Message) !Result {
	return p.tab.send('Storage.sendPendingAttributionReports', msg)!
}

// Returns the effective Related Website Sets in use by this profile for the browser
// session. The effective Related Website Sets will not change during a browser session. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#method-getRelatedWebsiteSets.
pub fn (mut p StorageDomain) get_related_website_sets(msg Message) !Result {
	return p.tab.send('Storage.getRelatedWebsiteSets', msg)!
}

// A cache's contents have been modified. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-cacheStorageContentUpdated.
pub fn (mut p StorageDomain) cache_storage_content_updated(msg Message) !Result {
	return p.tab.send('Storage.cacheStorageContentUpdated', msg)!
}

// A cache has been added/deleted. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-cacheStorageListUpdated.
pub fn (mut p StorageDomain) cache_storage_list_updated(msg Message) !Result {
	return p.tab.send('Storage.cacheStorageListUpdated', msg)!
}

// The origin's IndexedDB object store has been modified. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-indexedDBContentUpdated.
pub fn (mut p StorageDomain) indexed_db_content_updated(msg Message) !Result {
	return p.tab.send('Storage.indexedDBContentUpdated', msg)!
}

// The origin's IndexedDB database list has been modified. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-indexedDBListUpdated.
pub fn (mut p StorageDomain) indexed_db_list_updated(msg Message) !Result {
	return p.tab.send('Storage.indexedDBListUpdated', msg)!
}

// One of the interest groups was accessed. Note that these events are global
// to all targets sharing an interest group store. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-interestGroupAccessed.
pub fn (mut p StorageDomain) interest_group_accessed(msg Message) !Result {
	return p.tab.send('Storage.interestGroupAccessed', msg)!
}

// An auction involving interest groups is taking place. These events are
// target-specific. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-interestGroupAuctionEventOccurred.
pub fn (mut p StorageDomain) interest_group_auction_event_occurred(msg Message) !Result {
	return p.tab.send('Storage.interestGroupAuctionEventOccurred', msg)!
}

// Specifies which auctions a particular network fetch may be related to, and
// in what role. Note that it is not ordered with respect to
// Network.requestWillBeSent (but will happen before loadingFinished
// loadingFailed). see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-interestGroupAuctionNetworkRequestCreated.
pub fn (mut p StorageDomain) interest_group_auction_network_request_created(msg Message) !Result {
	return p.tab.send('Storage.interestGroupAuctionNetworkRequestCreated', msg)!
}

// Shared storage was accessed by the associated page.
// The following parameters are included in all events. see https://chromedevtools.github.io/devtools-protocol/tot/Storage/#event-sharedStorageAccessed.
pub fn (mut p StorageDomain) shared_storage_accessed(msg Message) !Result {
	return p.tab.send('Storage.sharedStorageAccessed', msg)!
}

pub fn (mut p StorageDomain) storage_bucket_created_or_updated(msg Message) !Result {
	return p.tab.send('Storage.storageBucketCreatedOrUpdated', msg)!
}

pub fn (mut p StorageDomain) storage_bucket_deleted(msg Message) !Result {
	return p.tab.send('Storage.storageBucketDeleted', msg)!
}

pub fn (mut p StorageDomain) attribution_reporting_source_registered(msg Message) !Result {
	return p.tab.send('Storage.attributionReportingSourceRegistered', msg)!
}

pub fn (mut p StorageDomain) attribution_reporting_trigger_registered(msg Message) !Result {
	return p.tab.send('Storage.attributionReportingTriggerRegistered', msg)!
}

// The SystemInfo domain defines methods and events for querying low-level system information. see https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo.
pub struct SystemInfoDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use SystemInfo domains.
pub fn (mut tab Tab) use_system_info(opts ConfigCDVDomain) !&SystemInfoDomain {
	if opts.enable && tab.is_inactive_deps('SystemInfo') {
		tab.send('SystemInfo.enable')!
		tab.deps << 'SystemInfo'
	}

	return &SystemInfoDomain{tab}
}

// Returns information about the system. see https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#method-getInfo.
pub fn (mut p SystemInfoDomain) get_info(msg Message) !Result {
	return p.tab.send('SystemInfo.getInfo', msg)!
}

// Returns information about the feature state. see https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#method-getFeatureState.
pub fn (mut p SystemInfoDomain) get_feature_state(par SystemInfoGetFeatureStateParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('SystemInfo.getFeatureState',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns information about all running processes. see https://chromedevtools.github.io/devtools-protocol/tot/SystemInfo/#method-getProcessInfo.
pub fn (mut p SystemInfoDomain) get_process_info(msg Message) !Result {
	return p.tab.send('SystemInfo.getProcessInfo', msg)!
}

// Supports additional targets discovery and allows to attach to them. see https://chromedevtools.github.io/devtools-protocol/tot/Target.
pub struct TargetDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Target domains.
pub fn (mut tab Tab) use_target(opts ConfigCDVDomain) !&TargetDomain {
	if opts.enable && tab.is_inactive_deps('Target') {
		tab.send('Target.enable')!
		tab.deps << 'Target'
	}

	return &TargetDomain{tab}
}

// Activates (focuses) the target. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-activateTarget.
pub fn (mut p TargetDomain) activate_target(par TargetActivateTargetParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.activateTarget',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Attaches to the target with given id. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-attachToTarget.
pub fn (mut p TargetDomain) attach_to_target(par TargetAttachToTargetParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.attachToTarget',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Attaches to the browser target, only uses flat sessionId mode. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-attachToBrowserTarget.
pub fn (mut p TargetDomain) attach_to_browser_target(msg Message) !Result {
	return p.tab.send('Target.attachToBrowserTarget', msg)!
}

// Closes the target. If the target is a page that gets closed too. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-closeTarget.
pub fn (mut p TargetDomain) close_target(par TargetCloseTargetParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.closeTarget',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Inject object to the target's main frame that provides a communication
// channel with browser target.
//
// Injected object will be available as `window[bindingName]`.
//
// The object has the following API:
//- `binding.send(json)` - a method to send messages over the remote debugging protocol
//- `binding.onmessage = json => handleMessage(json)` - a callback that will be called for the protocol notifications and command responses. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-exposeDevToolsProtocol.
pub fn (mut p TargetDomain) expose_dev_tools_protocol(par TargetExposeDevToolsProtocolParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.exposeDevToolsProtocol',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than
// one. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-createBrowserContext.
pub fn (mut p TargetDomain) create_browser_context(par TargetCreateBrowserContextParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.createBrowserContext',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns all browser contexts created with `Target.createBrowserContext` method. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-getBrowserContexts.
pub fn (mut p TargetDomain) get_browser_contexts(msg Message) !Result {
	return p.tab.send('Target.getBrowserContexts', msg)!
}

// Creates a new page. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-createTarget.
pub fn (mut p TargetDomain) create_target(par TargetCreateTargetParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.createTarget',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Detaches session with given id. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-detachFromTarget.
pub fn (mut p TargetDomain) detach_from_target(par TargetDetachFromTargetParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.detachFromTarget',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Deletes a BrowserContext. All the belonging pages will be closed without calling their
// beforeunload hooks. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-disposeBrowserContext.
pub fn (mut p TargetDomain) dispose_browser_context(par TargetDisposeBrowserContextParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.disposeBrowserContext',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns information about a target. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-getTargetInfo.
pub fn (mut p TargetDomain) get_target_info(par TargetGetTargetInfoParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.getTargetInfo',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Retrieves a list of available targets. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-getTargets.
pub fn (mut p TargetDomain) get_targets(par TargetGetTargetsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.getTargets',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sends protocol message over session with given id.
// Consider using flat mode instead; see commands attachToTarget, setAutoAttach,
// and crbug.com/991325. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-sendMessageToTarget.
pub fn (mut p TargetDomain) send_message_to_target(par TargetSendMessageToTargetParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.sendMessageToTarget',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Controls whether to automatically attach to new targets which are considered to be related to
// this one. When turned on, attaches to all existing related targets as well. When turned off,
// automatically detaches from all currently attached targets.
// This also clears all targets added by `autoAttachRelated` from the list of targets to watch
// for creation of related targets. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-setAutoAttach.
pub fn (mut p TargetDomain) set_auto_attach(par TargetSetAutoAttachParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.setAutoAttach',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Adds the specified target to the list of targets that will be monitored for any related target
// creation (such as child frames, child workers and new versions of service worker) and reported
// through `attachedToTarget`. The specified target is also auto-attached.
// This cancels the effect of any previous `setAutoAttach` and is also cancelled by subsequent
//`setAutoAttach`. Only available at the Browser target. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-autoAttachRelated.
pub fn (mut p TargetDomain) auto_attach_related(par TargetAutoAttachRelatedParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.autoAttachRelated',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Controls whether to discover available targets and notify via
//`targetCreated/targetInfoChanged/targetDestroyed` events. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-setDiscoverTargets.
pub fn (mut p TargetDomain) set_discover_targets(par TargetSetDiscoverTargetsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.setDiscoverTargets',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables target discovery for the specified locations, when `setDiscoverTargets` was set to
//`true`. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#method-setRemoteLocations.
pub fn (mut p TargetDomain) set_remote_locations(par TargetSetRemoteLocationsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Target.setRemoteLocations',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Issued when attached to target because of auto-attach or `attachToTarget` command. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-attachedToTarget.
pub fn (mut p TargetDomain) attached_to_target(msg Message) !Result {
	return p.tab.send('Target.attachedToTarget', msg)!
}

// Issued when detached from target for any reason (including `detachFromTarget` command). Can be
// issued multiple times per target if multiple sessions have been attached to it. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-detachedFromTarget.
pub fn (mut p TargetDomain) detached_from_target(msg Message) !Result {
	return p.tab.send('Target.detachedFromTarget', msg)!
}

// Notifies about a new protocol message received from the session (as reported in
//`attachedToTarget` event). see https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-receivedMessageFromTarget.
pub fn (mut p TargetDomain) received_message_from_target(msg Message) !Result {
	return p.tab.send('Target.receivedMessageFromTarget', msg)!
}

// Issued when a possible inspection target is created. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-targetCreated.
pub fn (mut p TargetDomain) target_created(msg Message) !Result {
	return p.tab.send('Target.targetCreated', msg)!
}

// Issued when a target is destroyed. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-targetDestroyed.
pub fn (mut p TargetDomain) target_destroyed(msg Message) !Result {
	return p.tab.send('Target.targetDestroyed', msg)!
}

// Issued when a target has crashed. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-targetCrashed.
pub fn (mut p TargetDomain) target_crashed(msg Message) !Result {
	return p.tab.send('Target.targetCrashed', msg)!
}

// Issued when some information about a target has changed. This only happens between
//`targetCreated` and `targetDestroyed`. see https://chromedevtools.github.io/devtools-protocol/tot/Target/#event-targetInfoChanged.
pub fn (mut p TargetDomain) target_info_changed(msg Message) !Result {
	return p.tab.send('Target.targetInfoChanged', msg)!
}

// The Tethering domain defines methods and events for browser port binding. see https://chromedevtools.github.io/devtools-protocol/tot/Tethering.
pub struct TetheringDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Tethering domains.
pub fn (mut tab Tab) use_tethering(opts ConfigCDVDomain) !&TetheringDomain {
	if opts.enable && tab.is_inactive_deps('Tethering') {
		tab.send('Tethering.enable')!
		tab.deps << 'Tethering'
	}

	return &TetheringDomain{tab}
}

// Request browser port binding. see https://chromedevtools.github.io/devtools-protocol/tot/Tethering/#method-bind.
pub fn (mut p TetheringDomain) bind(par TetheringBindParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Tethering.bind',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Request browser port unbinding. see https://chromedevtools.github.io/devtools-protocol/tot/Tethering/#method-unbind.
pub fn (mut p TetheringDomain) unbind(par TetheringUnbindParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Tethering.unbind',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Informs that port was successfully bound and got a specified connection id. see https://chromedevtools.github.io/devtools-protocol/tot/Tethering/#event-accepted.
pub fn (mut p TetheringDomain) accepted(msg Message) !Result {
	return p.tab.send('Tethering.accepted', msg)!
}

pub struct TracingDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Tracing domains.
pub fn (mut tab Tab) use_tracing(opts ConfigCDVDomain) !&TracingDomain {
	if opts.enable && tab.is_inactive_deps('Tracing') {
		tab.send('Tracing.enable')!
		tab.deps << 'Tracing'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['IO'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &TracingDomain{tab}
}

// Stop trace events collection. see https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-end.
pub fn (mut p TracingDomain) end(msg Message) !Result {
	return p.tab.send('Tracing.end', msg)!
}

// Gets supported tracing categories. see https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-getCategories.
pub fn (mut p TracingDomain) get_categories(msg Message) !Result {
	return p.tab.send('Tracing.getCategories', msg)!
}

// Record a clock sync marker in the trace. see https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-recordClockSyncMarker.
pub fn (mut p TracingDomain) record_clock_sync_marker(par TracingRecordClockSyncMarkerParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Tracing.recordClockSyncMarker',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Request a global memory dump. see https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-requestMemoryDump.
pub fn (mut p TracingDomain) request_memory_dump(par TracingRequestMemoryDumpParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Tracing.requestMemoryDump',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Start trace events collection. see https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#method-start.
pub fn (mut p TracingDomain) start(par TracingStartParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Tracing.start',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p TracingDomain) buffer_usage(msg Message) !Result {
	return p.tab.send('Tracing.bufferUsage', msg)!
}

// Contains a bucket of collected trace events. When tracing is stopped collected events will be
// sent as a sequence of dataCollected events followed by tracingComplete event. see https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#event-dataCollected.
pub fn (mut p TracingDomain) data_collected(msg Message) !Result {
	return p.tab.send('Tracing.dataCollected', msg)!
}

// Signals that tracing is stopped and there is no trace buffers pending flush, all data were
// delivered via dataCollected events. see https://chromedevtools.github.io/devtools-protocol/tot/Tracing/#event-tracingComplete.
pub fn (mut p TracingDomain) tracing_complete(msg Message) !Result {
	return p.tab.send('Tracing.tracingComplete', msg)!
}

// A domain for letting clients substitute browser's network layer with client code. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch.
pub struct FetchDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Fetch domains.
pub fn (mut tab Tab) use_fetch(opts ConfigCDVDomain) !&FetchDomain {
	if opts.enable && tab.is_inactive_deps('Fetch') {
		tab.send('Fetch.enable')!
		tab.deps << 'Fetch'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Network', 'IO', 'Page'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &FetchDomain{tab}
}

// Disables the fetch domain. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-disable.
pub fn (mut p FetchDomain) disable(msg Message) !Result {
	return p.tab.send('Fetch.disable', msg)!
}

// Enables issuing of requestPaused events. A request will be paused until client
// calls one of failRequest, fulfillRequest or continueRequest/continueWithAuth. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-enable.
pub fn (mut p FetchDomain) enable(par FetchEnableParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Fetch.enable',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Causes the request to fail with specified reason. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-failRequest.
pub fn (mut p FetchDomain) fail_request(par FetchFailRequestParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Fetch.failRequest',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Provides response to the request. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-fulfillRequest.
pub fn (mut p FetchDomain) fulfill_request(par FetchFulfillRequestParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Fetch.fulfillRequest',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Continues the request, optionally modifying some of its parameters. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueRequest.
pub fn (mut p FetchDomain) continue_request(par FetchContinueRequestParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Fetch.continueRequest',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Continues a request supplying authChallengeResponse following authRequired event. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueWithAuth.
pub fn (mut p FetchDomain) continue_with_auth(par FetchContinueWithAuthParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Fetch.continueWithAuth',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Continues loading of the paused response, optionally modifying the
// response headers. If either responseCode or headers are modified, all of them
// must be present. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueResponse.
pub fn (mut p FetchDomain) continue_response(par FetchContinueResponseParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Fetch.continueResponse',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Causes the body of the response to be received from the server and
// returned as a single string. May only be issued for a request that
// is paused in the Response stage and is mutually exclusive with
// takeResponseBodyForInterceptionAsStream. Calling other methods that
// affect the request or disabling fetch domain before body is received
// results in an undefined behavior.
// Note that the response body is not available for redirects. Requests
// paused in the _redirect received_ state may be differentiated by
//`responseCode` and presence of `location` response header, see
// comments to `requestPaused` for details. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-getResponseBody.
pub fn (mut p FetchDomain) get_response_body(par FetchGetResponseBodyParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Fetch.getResponseBody',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns a handle to the stream representing the response body.
// The request must be paused in the HeadersReceived stage.
// Note that after this command the request can't be continued
// as is -- client either needs to cancel it or to provide the
// response body.
// The stream only supports sequential read, IO.read will fail if the position
// is specified.
// This method is mutually exclusive with getResponseBody.
// Calling other methods that affect the request or disabling fetch
// domain before body is received results in an undefined behavior. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-takeResponseBodyAsStream.
pub fn (mut p FetchDomain) take_response_body_as_stream(par FetchTakeResponseBodyAsStreamParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Fetch.takeResponseBodyAsStream',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Issued when the domain is enabled and the request URL matches the
// specified filter. The request is paused until the client responds
// with one of continueRequest, failRequest or fulfillRequest.
// The stage of the request can be determined by presence of responseErrorReason
// and responseStatusCode -- the request is at the response stage if either
// of these fields is present and in the request stage otherwise.
// Redirect responses and subsequent requests are reported similarly to regular
// responses and requests. Redirect responses may be distinguished by the value
// of `responseStatusCode` (which is one of 301, 302, 303, 307, 308) along with
// presence of the `location` header. Requests resulting from a redirect will
// have `redirectedRequestId` field set. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#event-requestPaused.
pub fn (mut p FetchDomain) request_paused(msg Message) !Result {
	return p.tab.send('Fetch.requestPaused', msg)!
}

// Issued when the domain is enabled with handleAuthRequests set to true.
// The request is paused until client responds with continueWithAuth. see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#event-authRequired.
pub fn (mut p FetchDomain) auth_required(msg Message) !Result {
	return p.tab.send('Fetch.authRequired', msg)!
}

// This domain allows inspection of Web Audio API.
// https://webaudio.github.io/web-audio-api/ see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio.
pub struct WebAudioDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use WebAudio domains.
pub fn (mut tab Tab) use_web_audio(opts ConfigCDVDomain) !&WebAudioDomain {
	if opts.enable && tab.is_inactive_deps('WebAudio') {
		tab.send('WebAudio.enable')!
		tab.deps << 'WebAudio'
	}

	return &WebAudioDomain{tab}
}

// Enables the WebAudio domain and starts sending context lifetime events. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#method-enable.
pub fn (mut p WebAudioDomain) enable(msg Message) !Result {
	return p.tab.send('WebAudio.enable', msg)!
}

// Disables the WebAudio domain. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#method-disable.
pub fn (mut p WebAudioDomain) disable(msg Message) !Result {
	return p.tab.send('WebAudio.disable', msg)!
}

// Fetch the realtime data from the registered contexts. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#method-getRealtimeData.
pub fn (mut p WebAudioDomain) get_realtime_data(par WebAudioGetRealtimeDataParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAudio.getRealtimeData',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Notifies that a new BaseAudioContext has been created. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-contextCreated.
pub fn (mut p WebAudioDomain) context_created(msg Message) !Result {
	return p.tab.send('WebAudio.contextCreated', msg)!
}

// Notifies that an existing BaseAudioContext will be destroyed. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-contextWillBeDestroyed.
pub fn (mut p WebAudioDomain) context_will_be_destroyed(msg Message) !Result {
	return p.tab.send('WebAudio.contextWillBeDestroyed', msg)!
}

// Notifies that existing BaseAudioContext has changed some properties (id stays the same).. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-contextChanged.
pub fn (mut p WebAudioDomain) context_changed(msg Message) !Result {
	return p.tab.send('WebAudio.contextChanged', msg)!
}

// Notifies that the construction of an AudioListener has finished. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioListenerCreated.
pub fn (mut p WebAudioDomain) audio_listener_created(msg Message) !Result {
	return p.tab.send('WebAudio.audioListenerCreated', msg)!
}

// Notifies that a new AudioListener has been created. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioListenerWillBeDestroyed.
pub fn (mut p WebAudioDomain) audio_listener_will_be_destroyed(msg Message) !Result {
	return p.tab.send('WebAudio.audioListenerWillBeDestroyed', msg)!
}

// Notifies that a new AudioNode has been created. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioNodeCreated.
pub fn (mut p WebAudioDomain) audio_node_created(msg Message) !Result {
	return p.tab.send('WebAudio.audioNodeCreated', msg)!
}

// Notifies that an existing AudioNode has been destroyed. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioNodeWillBeDestroyed.
pub fn (mut p WebAudioDomain) audio_node_will_be_destroyed(msg Message) !Result {
	return p.tab.send('WebAudio.audioNodeWillBeDestroyed', msg)!
}

// Notifies that a new AudioParam has been created. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioParamCreated.
pub fn (mut p WebAudioDomain) audio_param_created(msg Message) !Result {
	return p.tab.send('WebAudio.audioParamCreated', msg)!
}

// Notifies that an existing AudioParam has been destroyed. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-audioParamWillBeDestroyed.
pub fn (mut p WebAudioDomain) audio_param_will_be_destroyed(msg Message) !Result {
	return p.tab.send('WebAudio.audioParamWillBeDestroyed', msg)!
}

// Notifies that two AudioNodes are connected. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-nodesConnected.
pub fn (mut p WebAudioDomain) nodes_connected(msg Message) !Result {
	return p.tab.send('WebAudio.nodesConnected', msg)!
}

// Notifies that AudioNodes are disconnected. The destination can be null, and it means all the outgoing connections from the source are disconnected. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-nodesDisconnected.
pub fn (mut p WebAudioDomain) nodes_disconnected(msg Message) !Result {
	return p.tab.send('WebAudio.nodesDisconnected', msg)!
}

// Notifies that an AudioNode is connected to an AudioParam. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-nodeParamConnected.
pub fn (mut p WebAudioDomain) node_param_connected(msg Message) !Result {
	return p.tab.send('WebAudio.nodeParamConnected', msg)!
}

// Notifies that an AudioNode is disconnected to an AudioParam. see https://chromedevtools.github.io/devtools-protocol/tot/WebAudio/#event-nodeParamDisconnected.
pub fn (mut p WebAudioDomain) node_param_disconnected(msg Message) !Result {
	return p.tab.send('WebAudio.nodeParamDisconnected', msg)!
}

// This domain allows configuring virtual authenticators to test the WebAuthn
// API. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn.
pub struct WebAuthnDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use WebAuthn domains.
pub fn (mut tab Tab) use_web_authn(opts ConfigCDVDomain) !&WebAuthnDomain {
	if opts.enable && tab.is_inactive_deps('WebAuthn') {
		tab.send('WebAuthn.enable')!
		tab.deps << 'WebAuthn'
	}

	return &WebAuthnDomain{tab}
}

// Enable the WebAuthn domain and start intercepting credential storage and
// retrieval with a virtual authenticator. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-enable.
pub fn (mut p WebAuthnDomain) enable(par WebAuthnEnableParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.enable',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disable the WebAuthn domain. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-disable.
pub fn (mut p WebAuthnDomain) disable(msg Message) !Result {
	return p.tab.send('WebAuthn.disable', msg)!
}

// Creates and adds a virtual authenticator. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-addVirtualAuthenticator.
pub fn (mut p WebAuthnDomain) add_virtual_authenticator(par WebAuthnAddVirtualAuthenticatorParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.addVirtualAuthenticator',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Resets parameters isBogusSignature, isBadUV, isBadUP to false if they are not present. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-setResponseOverrideBits.
pub fn (mut p WebAuthnDomain) set_response_override_bits(par WebAuthnSetResponseOverrideBitsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.setResponseOverrideBits',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes the given authenticator. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-removeVirtualAuthenticator.
pub fn (mut p WebAuthnDomain) remove_virtual_authenticator(par WebAuthnRemoveVirtualAuthenticatorParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.removeVirtualAuthenticator',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Adds the credential to the specified authenticator. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-addCredential.
pub fn (mut p WebAuthnDomain) add_credential(par WebAuthnAddCredentialParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.addCredential',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns a single credential stored in the given virtual authenticator that
// matches the credential ID. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-getCredential.
pub fn (mut p WebAuthnDomain) get_credential(par WebAuthnGetCredentialParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.getCredential',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns all the credentials stored in the given virtual authenticator. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-getCredentials.
pub fn (mut p WebAuthnDomain) get_credentials(par WebAuthnGetCredentialsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.getCredentials',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes a credential from the authenticator. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-removeCredential.
pub fn (mut p WebAuthnDomain) remove_credential(par WebAuthnRemoveCredentialParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.removeCredential',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Clears all the credentials from the specified device. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-clearCredentials.
pub fn (mut p WebAuthnDomain) clear_credentials(par WebAuthnClearCredentialsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.clearCredentials',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets whether User Verification succeeds or fails for an authenticator.
// The default is true. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-setUserVerified.
pub fn (mut p WebAuthnDomain) set_user_verified(par WebAuthnSetUserVerifiedParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.setUserVerified',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets whether tests of user presence will succeed immediately (if true) or fail to resolve (if false) for an authenticator.
// The default is true. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-setAutomaticPresenceSimulation.
pub fn (mut p WebAuthnDomain) set_automatic_presence_simulation(par WebAuthnSetAutomaticPresenceSimulationParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.setAutomaticPresenceSimulation',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Allows setting credential properties.
// https://w3c.github.io/webauthn/#sctn-automation-set-credential-properties see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#method-setCredentialProperties.
pub fn (mut p WebAuthnDomain) set_credential_properties(par WebAuthnSetCredentialPropertiesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('WebAuthn.setCredentialProperties',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Triggered when a credential is added to an authenticator. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#event-credentialAdded.
pub fn (mut p WebAuthnDomain) credential_added(msg Message) !Result {
	return p.tab.send('WebAuthn.credentialAdded', msg)!
}

// Triggered when a credential is deleted, e.g. through
// PublicKeyCredential.signalUnknownCredential(). see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#event-credentialDeleted.
pub fn (mut p WebAuthnDomain) credential_deleted(msg Message) !Result {
	return p.tab.send('WebAuthn.credentialDeleted', msg)!
}

// Triggered when a credential is updated, e.g. through
// PublicKeyCredential.signalCurrentUserDetails(). see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#event-credentialUpdated.
pub fn (mut p WebAuthnDomain) credential_updated(msg Message) !Result {
	return p.tab.send('WebAuthn.credentialUpdated', msg)!
}

// Triggered when a credential is used in a webauthn assertion. see https://chromedevtools.github.io/devtools-protocol/tot/WebAuthn/#event-credentialAsserted.
pub fn (mut p WebAuthnDomain) credential_asserted(msg Message) !Result {
	return p.tab.send('WebAuthn.credentialAsserted', msg)!
}

// This domain allows detailed inspection of media elements see https://chromedevtools.github.io/devtools-protocol/tot/Media.
pub struct MediaDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Media domains.
pub fn (mut tab Tab) use_media(opts ConfigCDVDomain) !&MediaDomain {
	if opts.enable && tab.is_inactive_deps('Media') {
		tab.send('Media.enable')!
		tab.deps << 'Media'
	}

	return &MediaDomain{tab}
}

// Enables the Media domain see https://chromedevtools.github.io/devtools-protocol/tot/Media/#method-enable.
pub fn (mut p MediaDomain) enable(msg Message) !Result {
	return p.tab.send('Media.enable', msg)!
}

// Disables the Media domain. see https://chromedevtools.github.io/devtools-protocol/tot/Media/#method-disable.
pub fn (mut p MediaDomain) disable(msg Message) !Result {
	return p.tab.send('Media.disable', msg)!
}

// This can be called multiple times, and can be used to set / override /
// remove player properties. A null propValue indicates removal. see https://chromedevtools.github.io/devtools-protocol/tot/Media/#event-playerPropertiesChanged.
pub fn (mut p MediaDomain) player_properties_changed(msg Message) !Result {
	return p.tab.send('Media.playerPropertiesChanged', msg)!
}

// Send events as a list, allowing them to be batched on the browser for less
// congestion. If batched, events must ALWAYS be in chronological order. see https://chromedevtools.github.io/devtools-protocol/tot/Media/#event-playerEventsAdded.
pub fn (mut p MediaDomain) player_events_added(msg Message) !Result {
	return p.tab.send('Media.playerEventsAdded', msg)!
}

// Send a list of any messages that need to be delivered. see https://chromedevtools.github.io/devtools-protocol/tot/Media/#event-playerMessagesLogged.
pub fn (mut p MediaDomain) player_messages_logged(msg Message) !Result {
	return p.tab.send('Media.playerMessagesLogged', msg)!
}

// Send a list of any errors that need to be delivered. see https://chromedevtools.github.io/devtools-protocol/tot/Media/#event-playerErrorsRaised.
pub fn (mut p MediaDomain) player_errors_raised(msg Message) !Result {
	return p.tab.send('Media.playerErrorsRaised', msg)!
}

// Called whenever a player is created, or when a new agent joins and receives
// a list of active players. If an agent is restored, it will receive the full
// list of player ids and all events again. see https://chromedevtools.github.io/devtools-protocol/tot/Media/#event-playersCreated.
pub fn (mut p MediaDomain) players_created(msg Message) !Result {
	return p.tab.send('Media.playersCreated', msg)!
}

pub struct DeviceAccessDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use DeviceAccess domains.
pub fn (mut tab Tab) use_device_access(opts ConfigCDVDomain) !&DeviceAccessDomain {
	if opts.enable && tab.is_inactive_deps('DeviceAccess') {
		tab.send('DeviceAccess.enable')!
		tab.deps << 'DeviceAccess'
	}

	return &DeviceAccessDomain{tab}
}

// Enable events in this domain. see https://chromedevtools.github.io/devtools-protocol/tot/DeviceAccess/#method-enable.
pub fn (mut p DeviceAccessDomain) enable(msg Message) !Result {
	return p.tab.send('DeviceAccess.enable', msg)!
}

// Disable events in this domain. see https://chromedevtools.github.io/devtools-protocol/tot/DeviceAccess/#method-disable.
pub fn (mut p DeviceAccessDomain) disable(msg Message) !Result {
	return p.tab.send('DeviceAccess.disable', msg)!
}

// Select a device in response to a DeviceAccess.deviceRequestPrompted event. see https://chromedevtools.github.io/devtools-protocol/tot/DeviceAccess/#method-selectPrompt.
pub fn (mut p DeviceAccessDomain) select_prompt(par DeviceAccessSelectPromptParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DeviceAccess.selectPrompt',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Cancel a prompt in response to a DeviceAccess.deviceRequestPrompted event. see https://chromedevtools.github.io/devtools-protocol/tot/DeviceAccess/#method-cancelPrompt.
pub fn (mut p DeviceAccessDomain) cancel_prompt(par DeviceAccessCancelPromptParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('DeviceAccess.cancelPrompt',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// A device request opened a user prompt to select a device. Respond with the
// selectPrompt or cancelPrompt command. see https://chromedevtools.github.io/devtools-protocol/tot/DeviceAccess/#event-deviceRequestPrompted.
pub fn (mut p DeviceAccessDomain) device_request_prompted(msg Message) !Result {
	return p.tab.send('DeviceAccess.deviceRequestPrompted', msg)!
}

pub struct PreloadDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Preload domains.
pub fn (mut tab Tab) use_preload(opts ConfigCDVDomain) !&PreloadDomain {
	if opts.enable && tab.is_inactive_deps('Preload') {
		tab.send('Preload.enable')!
		tab.deps << 'Preload'
	}

	return &PreloadDomain{tab}
}

pub fn (mut p PreloadDomain) enable(msg Message) !Result {
	return p.tab.send('Preload.enable', msg)!
}

pub fn (mut p PreloadDomain) disable(msg Message) !Result {
	return p.tab.send('Preload.disable', msg)!
}

// Upsert. Currently, it is only emitted when a rule set added. see https://chromedevtools.github.io/devtools-protocol/tot/Preload/#event-ruleSetUpdated.
pub fn (mut p PreloadDomain) rule_set_updated(msg Message) !Result {
	return p.tab.send('Preload.ruleSetUpdated', msg)!
}

pub fn (mut p PreloadDomain) rule_set_removed(msg Message) !Result {
	return p.tab.send('Preload.ruleSetRemoved', msg)!
}

// Fired when a preload enabled state is updated. see https://chromedevtools.github.io/devtools-protocol/tot/Preload/#event-preloadEnabledStateUpdated.
pub fn (mut p PreloadDomain) preload_enabled_state_updated(msg Message) !Result {
	return p.tab.send('Preload.preloadEnabledStateUpdated', msg)!
}

// Fired when a prefetch attempt is updated. see https://chromedevtools.github.io/devtools-protocol/tot/Preload/#event-prefetchStatusUpdated.
pub fn (mut p PreloadDomain) prefetch_status_updated(msg Message) !Result {
	return p.tab.send('Preload.prefetchStatusUpdated', msg)!
}

// Fired when a prerender attempt is updated. see https://chromedevtools.github.io/devtools-protocol/tot/Preload/#event-prerenderStatusUpdated.
pub fn (mut p PreloadDomain) prerender_status_updated(msg Message) !Result {
	return p.tab.send('Preload.prerenderStatusUpdated', msg)!
}

// Send a list of sources for all preloading attempts in a document. see https://chromedevtools.github.io/devtools-protocol/tot/Preload/#event-preloadingAttemptSourcesUpdated.
pub fn (mut p PreloadDomain) preloading_attempt_sources_updated(msg Message) !Result {
	return p.tab.send('Preload.preloadingAttemptSourcesUpdated', msg)!
}

// This domain allows interacting with the FedCM dialog. see https://chromedevtools.github.io/devtools-protocol/tot/FedCm.
pub struct FedCmDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use FedCm domains.
pub fn (mut tab Tab) use_fed_cm(opts ConfigCDVDomain) !&FedCmDomain {
	if opts.enable && tab.is_inactive_deps('FedCm') {
		tab.send('FedCm.enable')!
		tab.deps << 'FedCm'
	}

	return &FedCmDomain{tab}
}

pub fn (mut p FedCmDomain) enable(par FedCmEnableParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('FedCm.enable',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p FedCmDomain) disable(msg Message) !Result {
	return p.tab.send('FedCm.disable', msg)!
}

pub fn (mut p FedCmDomain) select_account(par FedCmSelectAccountParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('FedCm.selectAccount',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p FedCmDomain) click_dialog_button(par FedCmClickDialogButtonParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('FedCm.clickDialogButton',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p FedCmDomain) open_url(par FedCmOpenUrlParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('FedCm.openUrl',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p FedCmDomain) dismiss_dialog(par FedCmDismissDialogParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('FedCm.dismissDialog',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Resets the cooldown time, if any, to allow the next FedCM call to show
// a dialog even if one was recently dismissed by the user. see https://chromedevtools.github.io/devtools-protocol/tot/FedCm/#method-resetCooldown.
pub fn (mut p FedCmDomain) reset_cooldown(msg Message) !Result {
	return p.tab.send('FedCm.resetCooldown', msg)!
}

pub fn (mut p FedCmDomain) dialog_shown(msg Message) !Result {
	return p.tab.send('FedCm.dialogShown', msg)!
}

// Triggered when a dialog is closed, either by user action, JS abort,
// or a command below. see https://chromedevtools.github.io/devtools-protocol/tot/FedCm/#event-dialogClosed.
pub fn (mut p FedCmDomain) dialog_closed(msg Message) !Result {
	return p.tab.send('FedCm.dialogClosed', msg)!
}

// This domain allows interacting with the browser to control PWAs. see https://chromedevtools.github.io/devtools-protocol/tot/PWA.
pub struct PWADomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use PWA domains.
pub fn (mut tab Tab) use_pwa(opts ConfigCDVDomain) !&PWADomain {
	if opts.enable && tab.is_inactive_deps('PWA') {
		tab.send('PWA.enable')!
		tab.deps << 'PWA'
	}

	return &PWADomain{tab}
}

// Returns the following OS state for the given manifest id. see https://chromedevtools.github.io/devtools-protocol/tot/PWA/#method-getOsAppState.
pub fn (mut p PWADomain) get_os_app_state(par PWAGetOsAppStateParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('PWA.getOsAppState',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Installs the given manifest identity, optionally using the given install_url
// or IWA bundle location.
//
// TODO(crbug.com/337872319) Support IWA to meet the following specific
// requirement.
// IWA-specific install description: If the manifest_id is isolated-app://,
// install_url_or_bundle_url is required, and can be either an http(s) URL or
// file:// URL pointing to a signed web bundle (.swbn). The .swbn file's
// signing key must correspond to manifest_id. If Chrome is not in IWA dev
// mode, the installation will fail, regardless of the state of the allowlist. see https://chromedevtools.github.io/devtools-protocol/tot/PWA/#method-install.
pub fn (mut p PWADomain) install(par PWAInstallParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('PWA.install',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Uninstalls the given manifest_id and closes any opened app windows. see https://chromedevtools.github.io/devtools-protocol/tot/PWA/#method-uninstall.
pub fn (mut p PWADomain) uninstall(par PWAUninstallParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('PWA.uninstall',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Launches the installed web app, or an url in the same web app instead of the
// default start url if it is provided. Returns a page Target.TargetID which
// can be used to attach to via Target.attachToTarget or similar APIs. see https://chromedevtools.github.io/devtools-protocol/tot/PWA/#method-launch.
pub fn (mut p PWADomain) launch(par PWALaunchParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('PWA.launch',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Opens one or more local files from an installed web app identified by its
// manifestId. The web app needs to have file handlers registered to process
// the files. The API returns one or more page Target.TargetIDs which can be
// used to attach to via Target.attachToTarget or similar APIs.
// If some files in the parameters cannot be handled by the web app, they will
// be ignored. If none of the files can be handled, this API returns an error.
// If no files are provided as the parameter, this API also returns an error.
//
// According to the definition of the file handlers in the manifest file, one
// Target.TargetID may represent a page handling one or more files. The order
// of the returned Target.TargetIDs is not guaranteed.
//
// TODO(crbug.com/339454034): Check the existences of the input files. see https://chromedevtools.github.io/devtools-protocol/tot/PWA/#method-launchFilesInApp.
pub fn (mut p PWADomain) launch_files_in_app(par PWALaunchFilesInAppParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('PWA.launchFilesInApp',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Opens the current page in its web app identified by the manifest id, needs
// to be called on a page target. This function returns immediately without
// waiting for the app to finish loading. see https://chromedevtools.github.io/devtools-protocol/tot/PWA/#method-openCurrentPageInApp.
pub fn (mut p PWADomain) open_current_page_in_app(par PWAOpenCurrentPageInAppParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('PWA.openCurrentPageInApp',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Changes user settings of the web app identified by its manifestId. If the
// app was not installed, this command returns an error. Unset parameters will
// be ignored; unrecognized values will cause an error.
//
// Unlike the ones defined in the manifest files of the web apps, these
// settings are provided by the browser and controlled by the users, they
// impact the way the browser handling the web apps.
//
// See the comment of each parameter. see https://chromedevtools.github.io/devtools-protocol/tot/PWA/#method-changeAppUserSettings.
pub fn (mut p PWADomain) change_app_user_settings(par PWAChangeAppUserSettingsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('PWA.changeAppUserSettings',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// This domain allows configuring virtual Bluetooth devices to test
// the web-bluetooth API. see https://chromedevtools.github.io/devtools-protocol/tot/BluetoothEmulation.
pub struct BluetoothEmulationDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use BluetoothEmulation domains.
pub fn (mut tab Tab) use_bluetooth_emulation(opts ConfigCDVDomain) !&BluetoothEmulationDomain {
	if opts.enable && tab.is_inactive_deps('BluetoothEmulation') {
		tab.send('BluetoothEmulation.enable')!
		tab.deps << 'BluetoothEmulation'
	}

	return &BluetoothEmulationDomain{tab}
}

// Enable the BluetoothEmulation domain. see https://chromedevtools.github.io/devtools-protocol/tot/BluetoothEmulation/#method-enable.
pub fn (mut p BluetoothEmulationDomain) enable(par BluetoothEmulationEnableParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('BluetoothEmulation.enable',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disable the BluetoothEmulation domain. see https://chromedevtools.github.io/devtools-protocol/tot/BluetoothEmulation/#method-disable.
pub fn (mut p BluetoothEmulationDomain) disable(msg Message) !Result {
	return p.tab.send('BluetoothEmulation.disable', msg)!
}

// Simulates a peripheral with |address|, |name| and |knownServiceUuids|
// that has already been connected to the system. see https://chromedevtools.github.io/devtools-protocol/tot/BluetoothEmulation/#method-simulatePreconnectedPeripheral.
pub fn (mut p BluetoothEmulationDomain) simulate_preconnected_peripheral(par BluetoothEmulationSimulatePreconnectedPeripheralParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('BluetoothEmulation.simulatePreconnectedPeripheral',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Simulates an advertisement packet described in |entry| being received by
// the central. see https://chromedevtools.github.io/devtools-protocol/tot/BluetoothEmulation/#method-simulateAdvertisement.
pub fn (mut p BluetoothEmulationDomain) simulate_advertisement(par BluetoothEmulationSimulateAdvertisementParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('BluetoothEmulation.simulateAdvertisement',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// This domain is deprecated - use Runtime or Log instead. see https://chromedevtools.github.io/devtools-protocol/tot/Console.
pub struct ConsoleDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Console domains.
pub fn (mut tab Tab) use_console(opts ConfigCDVDomain) !&ConsoleDomain {
	if opts.enable && tab.is_inactive_deps('Console') {
		tab.send('Console.enable')!
		tab.deps << 'Console'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Runtime'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &ConsoleDomain{tab}
}

// Does nothing. see https://chromedevtools.github.io/devtools-protocol/tot/Console/#method-clearMessages.
pub fn (mut p ConsoleDomain) clear_messages(msg Message) !Result {
	return p.tab.send('Console.clearMessages', msg)!
}

// Disables console domain, prevents further console messages from being reported to the client. see https://chromedevtools.github.io/devtools-protocol/tot/Console/#method-disable.
pub fn (mut p ConsoleDomain) disable(msg Message) !Result {
	return p.tab.send('Console.disable', msg)!
}

// Enables console domain, sends the messages collected so far to the client by means of the
//`messageAdded` notification. see https://chromedevtools.github.io/devtools-protocol/tot/Console/#method-enable.
pub fn (mut p ConsoleDomain) enable(msg Message) !Result {
	return p.tab.send('Console.enable', msg)!
}

// Issued when new console message is added. see https://chromedevtools.github.io/devtools-protocol/tot/Console/#event-messageAdded.
pub fn (mut p ConsoleDomain) message_added(msg Message) !Result {
	return p.tab.send('Console.messageAdded', msg)!
}

// Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing
// breakpoints, stepping through execution, exploring stack traces, etc. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger.
pub struct DebuggerDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Debugger domains.
pub fn (mut tab Tab) use_debugger(opts ConfigCDVDomain) !&DebuggerDomain {
	if opts.enable && tab.is_inactive_deps('Debugger') {
		tab.send('Debugger.enable')!
		tab.deps << 'Debugger'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Runtime'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &DebuggerDomain{tab}
}

// Continues execution until specific location is reached. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-continueToLocation.
pub fn (mut p DebuggerDomain) continue_to_location(par DebuggerContinueToLocationParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.continueToLocation',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables debugger for given page. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-disable.
pub fn (mut p DebuggerDomain) disable(msg Message) !Result {
	return p.tab.send('Debugger.disable', msg)!
}

// Enables debugger for the given page. Clients should not assume that the debugging has been
// enabled until the result for this command is received. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-enable.
pub fn (mut p DebuggerDomain) enable(par DebuggerEnableParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.enable',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Evaluates expression on a given call frame. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-evaluateOnCallFrame.
pub fn (mut p DebuggerDomain) evaluate_on_call_frame(par DebuggerEvaluateOnCallFrameParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.evaluateOnCallFrame',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns possible locations for breakpoint. scriptId in start and end range locations should be
// the same. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-getPossibleBreakpoints.
pub fn (mut p DebuggerDomain) get_possible_breakpoints(par DebuggerGetPossibleBreakpointsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.getPossibleBreakpoints',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns source for the script with given id. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-getScriptSource.
pub fn (mut p DebuggerDomain) get_script_source(par DebuggerGetScriptSourceParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.getScriptSource',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p DebuggerDomain) disassemble_wasm_module(par DebuggerDisassembleWasmModuleParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.disassembleWasmModule',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disassemble the next chunk of lines for the module corresponding to the
// stream. If disassembly is complete, this API will invalidate the streamId
// and return an empty chunk. Any subsequent calls for the now invalid stream
// will return errors. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-nextWasmDisassemblyChunk.
pub fn (mut p DebuggerDomain) next_wasm_disassembly_chunk(par DebuggerNextWasmDisassemblyChunkParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.nextWasmDisassemblyChunk',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// This command is deprecated. Use getScriptSource instead. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-getWasmBytecode.
pub fn (mut p DebuggerDomain) get_wasm_bytecode(par DebuggerGetWasmBytecodeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.getWasmBytecode',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns stack trace with given `stackTraceId`. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-getStackTrace.
pub fn (mut p DebuggerDomain) get_stack_trace(par DebuggerGetStackTraceParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.getStackTrace',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Stops on the next JavaScript statement. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-pause.
pub fn (mut p DebuggerDomain) pause(msg Message) !Result {
	return p.tab.send('Debugger.pause', msg)!
}

pub fn (mut p DebuggerDomain) pause_on_async_call(par DebuggerPauseOnAsyncCallParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.pauseOnAsyncCall',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Removes JavaScript breakpoint. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-removeBreakpoint.
pub fn (mut p DebuggerDomain) remove_breakpoint(par DebuggerRemoveBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.removeBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Restarts particular call frame from the beginning. The old, deprecated
// behavior of `restartFrame` is to stay paused and allow further CDP commands
// after a restart was scheduled. This can cause problems with restarting, so
// we now continue execution immediatly after it has been scheduled until we
// reach the beginning of the restarted frame.
//
// To stay back-wards compatible, `restartFrame` now expects a `mode`
// parameter to be present. If the `mode` parameter is missing, `restartFrame`
// errors out.
//
// The various return values are deprecated and `callFrames` is always empty.
// Use the call frames from the `Debugger#paused` events instead, that fires
// once V8 pauses at the beginning of the restarted function. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-restartFrame.
pub fn (mut p DebuggerDomain) restart_frame(par DebuggerRestartFrameParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.restartFrame',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Resumes JavaScript execution. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-resume.
pub fn (mut p DebuggerDomain) resume(par DebuggerResumeParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.resume',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Searches for given string in script content. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-searchInContent.
pub fn (mut p DebuggerDomain) search_in_content(par DebuggerSearchInContentParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.searchInContent',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables or disables async call stacks tracking. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setAsyncCallStackDepth.
pub fn (mut p DebuggerDomain) set_async_call_stack_depth(par DebuggerSetAsyncCallStackDepthParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setAsyncCallStackDepth',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Replace previous blackbox execution contexts with passed ones. Forces backend to skip
// stepping/pausing in scripts in these execution contexts. VM will try to leave blackboxed script by
// performing 'step in' several times, finally resorting to 'step out' if unsuccessful. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBlackboxExecutionContexts.
pub fn (mut p DebuggerDomain) set_blackbox_execution_contexts(par DebuggerSetBlackboxExecutionContextsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setBlackboxExecutionContexts',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in
// scripts with url matching one of the patterns. VM will try to leave blackboxed script by
// performing 'step in' several times, finally resorting to 'step out' if unsuccessful. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBlackboxPatterns.
pub fn (mut p DebuggerDomain) set_blackbox_patterns(par DebuggerSetBlackboxPatternsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setBlackboxPatterns',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted
// scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
// Positions array contains positions where blackbox state is changed. First interval isn't
// blackboxed. Array should be sorted. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBlackboxedRanges.
pub fn (mut p DebuggerDomain) set_blackboxed_ranges(par DebuggerSetBlackboxedRangesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setBlackboxedRanges',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets JavaScript breakpoint at a given location. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpoint.
pub fn (mut p DebuggerDomain) set_breakpoint(par DebuggerSetBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets instrumentation breakpoint. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setInstrumentationBreakpoint.
pub fn (mut p DebuggerDomain) set_instrumentation_breakpoint(par DebuggerSetInstrumentationBreakpointParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setInstrumentationBreakpoint',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this
// command is issued, all existing parsed scripts will have breakpoints resolved and returned in
//`locations` property. Further matching script parsing will result in subsequent
//`breakpointResolved` events issued. This logical breakpoint will survive page reloads. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpointByUrl.
pub fn (mut p DebuggerDomain) set_breakpoint_by_url(par DebuggerSetBreakpointByUrlParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setBreakpointByUrl',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Sets JavaScript breakpoint before each call to the given function.
// If another function was created from the same source as a given one,
// calling it will also trigger the breakpoint. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpointOnFunctionCall.
pub fn (mut p DebuggerDomain) set_breakpoint_on_function_call(par DebuggerSetBreakpointOnFunctionCallParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setBreakpointOnFunctionCall',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Activates / deactivates all breakpoints on the page. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setBreakpointsActive.
pub fn (mut p DebuggerDomain) set_breakpoints_active(par DebuggerSetBreakpointsActiveParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setBreakpointsActive',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions,
// or caught exceptions, no exceptions. Initial pause on exceptions state is `none`. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setPauseOnExceptions.
pub fn (mut p DebuggerDomain) set_pause_on_exceptions(par DebuggerSetPauseOnExceptionsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setPauseOnExceptions',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Changes return value in top frame. Available only at return break position. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setReturnValue.
pub fn (mut p DebuggerDomain) set_return_value(par DebuggerSetReturnValueParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setReturnValue',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Edits JavaScript source live.
//
// In general, functions that are currently on the stack can not be edited with
// a single exception: If the edited function is the top-most stack frame and
// that is the only activation of that function on the stack. In this case
// the live edit will be successful and a `Debugger.restartFrame` for the
// top-most function is automatically triggered. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setScriptSource.
pub fn (mut p DebuggerDomain) set_script_source(par DebuggerSetScriptSourceParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setScriptSource',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc). see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setSkipAllPauses.
pub fn (mut p DebuggerDomain) set_skip_all_pauses(par DebuggerSetSkipAllPausesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setSkipAllPauses',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Changes value of variable in a callframe. Object-based scopes are not supported and must be
// mutated manually. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-setVariableValue.
pub fn (mut p DebuggerDomain) set_variable_value(par DebuggerSetVariableValueParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.setVariableValue',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Steps into the function call. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-stepInto.
pub fn (mut p DebuggerDomain) step_into(par DebuggerStepIntoParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.stepInto',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Steps out of the function call. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-stepOut.
pub fn (mut p DebuggerDomain) step_out(msg Message) !Result {
	return p.tab.send('Debugger.stepOut', msg)!
}

// Steps over the statement. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#method-stepOver.
pub fn (mut p DebuggerDomain) step_over(par DebuggerStepOverParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Debugger.stepOver',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Fired when breakpoint is resolved to an actual script and location. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#event-breakpointResolved.
pub fn (mut p DebuggerDomain) breakpoint_resolved(msg Message) !Result {
	return p.tab.send('Debugger.breakpointResolved', msg)!
}

// Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#event-paused.
pub fn (mut p DebuggerDomain) paused(msg Message) !Result {
	return p.tab.send('Debugger.paused', msg)!
}

// Fired when the virtual machine resumed execution. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#event-resumed.
pub fn (mut p DebuggerDomain) resumed(msg Message) !Result {
	return p.tab.send('Debugger.resumed', msg)!
}

// Fired when virtual machine fails to parse the script. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#event-scriptFailedToParse.
pub fn (mut p DebuggerDomain) script_failed_to_parse(msg Message) !Result {
	return p.tab.send('Debugger.scriptFailedToParse', msg)!
}

// Fired when virtual machine parses script. This event is also fired for all known and uncollected
// scripts upon enabling debugger. see https://chromedevtools.github.io/devtools-protocol/tot/Debugger/#event-scriptParsed.
pub fn (mut p DebuggerDomain) script_parsed(msg Message) !Result {
	return p.tab.send('Debugger.scriptParsed', msg)!
}

pub struct HeapProfilerDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use HeapProfiler domains.
pub fn (mut tab Tab) use_heap_profiler(opts ConfigCDVDomain) !&HeapProfilerDomain {
	if opts.enable && tab.is_inactive_deps('HeapProfiler') {
		tab.send('HeapProfiler.enable')!
		tab.deps << 'HeapProfiler'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Runtime'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &HeapProfilerDomain{tab}
}

// Enables console to refer to the node with given id via $x (see Command Line API for more details
//$x functions). see https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#method-addInspectedHeapObject.
pub fn (mut p HeapProfilerDomain) add_inspected_heap_object(par HeapProfilerAddInspectedHeapObjectParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('HeapProfiler.addInspectedHeapObject',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p HeapProfilerDomain) collect_garbage(msg Message) !Result {
	return p.tab.send('HeapProfiler.collectGarbage', msg)!
}

pub fn (mut p HeapProfilerDomain) disable(msg Message) !Result {
	return p.tab.send('HeapProfiler.disable', msg)!
}

pub fn (mut p HeapProfilerDomain) enable(msg Message) !Result {
	return p.tab.send('HeapProfiler.enable', msg)!
}

pub fn (mut p HeapProfilerDomain) get_heap_object_id(par HeapProfilerGetHeapObjectIdParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('HeapProfiler.getHeapObjectId',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p HeapProfilerDomain) get_object_by_heap_object_id(par HeapProfilerGetObjectByHeapObjectIdParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('HeapProfiler.getObjectByHeapObjectId',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p HeapProfilerDomain) get_sampling_profile(msg Message) !Result {
	return p.tab.send('HeapProfiler.getSamplingProfile', msg)!
}

pub fn (mut p HeapProfilerDomain) start_sampling(par HeapProfilerStartSamplingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('HeapProfiler.startSampling',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p HeapProfilerDomain) start_tracking_heap_objects(par HeapProfilerStartTrackingHeapObjectsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('HeapProfiler.startTrackingHeapObjects',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p HeapProfilerDomain) stop_sampling(msg Message) !Result {
	return p.tab.send('HeapProfiler.stopSampling', msg)!
}

pub fn (mut p HeapProfilerDomain) stop_tracking_heap_objects(par HeapProfilerStopTrackingHeapObjectsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('HeapProfiler.stopTrackingHeapObjects',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p HeapProfilerDomain) take_heap_snapshot(par HeapProfilerTakeHeapSnapshotParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('HeapProfiler.takeHeapSnapshot',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p HeapProfilerDomain) add_heap_snapshot_chunk(msg Message) !Result {
	return p.tab.send('HeapProfiler.addHeapSnapshotChunk', msg)!
}

// If heap objects tracking has been started then backend may send update for one or more fragments see https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#event-heapStatsUpdate.
pub fn (mut p HeapProfilerDomain) heap_stats_update(msg Message) !Result {
	return p.tab.send('HeapProfiler.heapStatsUpdate', msg)!
}

// If heap objects tracking has been started then backend regularly sends a current value for last
// seen object id and corresponding timestamp. If the were changes in the heap since last event
// then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event. see https://chromedevtools.github.io/devtools-protocol/tot/HeapProfiler/#event-lastSeenObjectId.
pub fn (mut p HeapProfilerDomain) last_seen_object_id(msg Message) !Result {
	return p.tab.send('HeapProfiler.lastSeenObjectId', msg)!
}

pub fn (mut p HeapProfilerDomain) report_heap_snapshot_progress(msg Message) !Result {
	return p.tab.send('HeapProfiler.reportHeapSnapshotProgress', msg)!
}

pub fn (mut p HeapProfilerDomain) reset_profiles(msg Message) !Result {
	return p.tab.send('HeapProfiler.resetProfiles', msg)!
}

pub struct ProfilerDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Profiler domains.
pub fn (mut tab Tab) use_profiler(opts ConfigCDVDomain) !&ProfilerDomain {
	if opts.enable && tab.is_inactive_deps('Profiler') {
		tab.send('Profiler.enable')!
		tab.deps << 'Profiler'
	}

	if opts.enable_deps {
		deps := if opts.deps.len == 0 { ['Runtime', 'Debugger'] } else { opts.deps }
		for dep in deps {
			if tab.is_inactive_deps(dep) {
				tab.send(dep + '.enable')!
				tab.deps << dep
			}
		}
	}

	return &ProfilerDomain{tab}
}

pub fn (mut p ProfilerDomain) disable(msg Message) !Result {
	return p.tab.send('Profiler.disable', msg)!
}

pub fn (mut p ProfilerDomain) enable(msg Message) !Result {
	return p.tab.send('Profiler.enable', msg)!
}

// Collect coverage data for the current isolate. The coverage data may be incomplete due to
// garbage collection. see https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-getBestEffortCoverage.
pub fn (mut p ProfilerDomain) get_best_effort_coverage(msg Message) !Result {
	return p.tab.send('Profiler.getBestEffortCoverage', msg)!
}

// Changes CPU profiler sampling interval. Must be called before CPU profiles recording started. see https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-setSamplingInterval.
pub fn (mut p ProfilerDomain) set_sampling_interval(par ProfilerSetSamplingIntervalParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Profiler.setSamplingInterval',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ProfilerDomain) start(msg Message) !Result {
	return p.tab.send('Profiler.start', msg)!
}

// Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code
// coverage may be incomplete. Enabling prevents running optimized code and resets execution
// counters. see https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-startPreciseCoverage.
pub fn (mut p ProfilerDomain) start_precise_coverage(par ProfilerStartPreciseCoverageParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Profiler.startPreciseCoverage',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p ProfilerDomain) stop(msg Message) !Result {
	return p.tab.send('Profiler.stop', msg)!
}

// Disable precise code coverage. Disabling releases unnecessary execution count records and allows
// executing optimized code. see https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-stopPreciseCoverage.
pub fn (mut p ProfilerDomain) stop_precise_coverage(msg Message) !Result {
	return p.tab.send('Profiler.stopPreciseCoverage', msg)!
}

// Collect coverage data for the current isolate, and resets execution counters. Precise code
// coverage needs to have started. see https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#method-takePreciseCoverage.
pub fn (mut p ProfilerDomain) take_precise_coverage(msg Message) !Result {
	return p.tab.send('Profiler.takePreciseCoverage', msg)!
}

pub fn (mut p ProfilerDomain) console_profile_finished(msg Message) !Result {
	return p.tab.send('Profiler.consoleProfileFinished', msg)!
}

// Sent when new profile recording is started using console.profile() call. see https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#event-consoleProfileStarted.
pub fn (mut p ProfilerDomain) console_profile_started(msg Message) !Result {
	return p.tab.send('Profiler.consoleProfileStarted', msg)!
}

// Reports coverage delta since the last poll (either from an event like this, or from
//`takePreciseCoverage` for the current isolate. May only be sent if precise code
// coverage has been started. This event can be trigged by the embedder to, for example,
// trigger collection of coverage data immediately at a certain point in time. see https://chromedevtools.github.io/devtools-protocol/tot/Profiler/#event-preciseCoverageDeltaUpdate.
pub fn (mut p ProfilerDomain) precise_coverage_delta_update(msg Message) !Result {
	return p.tab.send('Profiler.preciseCoverageDeltaUpdate', msg)!
}

// Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects.
// Evaluation results are returned as mirror object that expose object type, string representation
// and unique identifier that can be used for further object reference. Original objects are
// maintained in memory unless they are either explicitly released or are released along with the
// other objects in their object group. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime.
pub struct RuntimeDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Runtime domains.
pub fn (mut tab Tab) use_runtime(opts ConfigCDVDomain) !&RuntimeDomain {
	if opts.enable && tab.is_inactive_deps('Runtime') {
		tab.send('Runtime.enable')!
		tab.deps << 'Runtime'
	}

	return &RuntimeDomain{tab}
}

// Add handler to promise with given promise object id. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-awaitPromise.
pub fn (mut p RuntimeDomain) await_promise(par RuntimeAwaitPromiseParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.awaitPromise',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Calls function with given declaration on the given object. Object group of the result is
// inherited from the target object. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-callFunctionOn.
pub fn (mut p RuntimeDomain) call_function_on(par RuntimeCallFunctionOnParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.callFunctionOn',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Compiles expression. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-compileScript.
pub fn (mut p RuntimeDomain) compile_script(par RuntimeCompileScriptParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.compileScript',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Disables reporting of execution contexts creation. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-disable.
pub fn (mut p RuntimeDomain) disable(msg Message) !Result {
	return p.tab.send('Runtime.disable', msg)!
}

// Discards collected exceptions and console API calls. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-discardConsoleEntries.
pub fn (mut p RuntimeDomain) discard_console_entries(msg Message) !Result {
	return p.tab.send('Runtime.discardConsoleEntries', msg)!
}

// Enables reporting of execution contexts creation by means of `executionContextCreated` event.
// When the reporting gets enabled the event will be sent immediately for each existing execution
// context. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-enable.
pub fn (mut p RuntimeDomain) enable(msg Message) !Result {
	return p.tab.send('Runtime.enable', msg)!
}

// Evaluates expression on global object. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-evaluate.
pub fn (mut p RuntimeDomain) evaluate(par RuntimeEvaluateParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.evaluate',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns the isolate id. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getIsolateId.
pub fn (mut p RuntimeDomain) get_isolate_id(msg Message) !Result {
	return p.tab.send('Runtime.getIsolateId', msg)!
}

// Returns the JavaScript heap usage.
// It is the total usage of the corresponding isolate not scoped to a particular Runtime. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getHeapUsage.
pub fn (mut p RuntimeDomain) get_heap_usage(msg Message) !Result {
	return p.tab.send('Runtime.getHeapUsage', msg)!
}

// Returns properties of a given object. Object group of the result is inherited from the target
// object. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getProperties.
pub fn (mut p RuntimeDomain) get_properties(par RuntimeGetPropertiesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.getProperties',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Returns all let, const and class variables from global scope. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-globalLexicalScopeNames.
pub fn (mut p RuntimeDomain) global_lexical_scope_names(par RuntimeGlobalLexicalScopeNamesParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.globalLexicalScopeNames',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p RuntimeDomain) query_objects(par RuntimeQueryObjectsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.queryObjects',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Releases remote object with given id. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-releaseObject.
pub fn (mut p RuntimeDomain) release_object(par RuntimeReleaseObjectParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.releaseObject',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Releases all remote objects that belong to a given group. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-releaseObjectGroup.
pub fn (mut p RuntimeDomain) release_object_group(par RuntimeReleaseObjectGroupParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.releaseObjectGroup',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Tells inspected instance to run if it was waiting for debugger to attach. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-runIfWaitingForDebugger.
pub fn (mut p RuntimeDomain) run_if_waiting_for_debugger(msg Message) !Result {
	return p.tab.send('Runtime.runIfWaitingForDebugger', msg)!
}

// Runs script with given id in a given context. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-runScript.
pub fn (mut p RuntimeDomain) run_script(par RuntimeRunScriptParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.runScript',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Enables or disables async call stacks tracking. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-setAsyncCallStackDepth.
pub fn (mut p RuntimeDomain) set_async_call_stack_depth(par RuntimeSetAsyncCallStackDepthParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.setAsyncCallStackDepth',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p RuntimeDomain) set_custom_object_formatter_enabled(par RuntimeSetCustomObjectFormatterEnabledParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.setCustomObjectFormatterEnabled',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

pub fn (mut p RuntimeDomain) set_max_call_stack_size_to_capture(par RuntimeSetMaxCallStackSizeToCaptureParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.setMaxCallStackSizeToCapture',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Terminate current or next JavaScript execution.
// Will cancel the termination when the outer-most script execution ends. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-terminateExecution.
pub fn (mut p RuntimeDomain) terminate_execution(msg Message) !Result {
	return p.tab.send('Runtime.terminateExecution', msg)!
}

// If executionContextId is empty, adds binding with the given name on the
// global objects of all inspected contexts, including those created later,
// bindings survive reloads.
// Binding function takes exactly one argument, this argument should be string,
// in case of any other input, function throws an exception.
// Each binding function call produces Runtime.bindingCalled notification. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-addBinding.
pub fn (mut p RuntimeDomain) add_binding(par RuntimeAddBindingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.addBinding',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// This method does not remove binding function from global object but
// unsubscribes current runtime agent from Runtime.bindingCalled notifications. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-removeBinding.
pub fn (mut p RuntimeDomain) remove_binding(par RuntimeRemoveBindingParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.removeBinding',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// This method tries to lookup and populate exception details for a
// JavaScript Error object.
// Note that the stackTrace portion of the resulting exceptionDetails will
// only be populated if the Runtime domain was enabled at the time when the
// Error was thrown. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#method-getExceptionDetails.
pub fn (mut p RuntimeDomain) get_exception_details(par RuntimeGetExceptionDetailsParams) !Result {
	params := struct_to_map(par)!
	return p.tab.send('Runtime.getExceptionDetails',
		params: params
		cb:     par.cb
		wait:   par.wait
		ref:    par.ref
	)!
}

// Notification is issued every time when binding is called. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-bindingCalled.
pub fn (mut p RuntimeDomain) binding_called(msg Message) !Result {
	return p.tab.send('Runtime.bindingCalled', msg)!
}

// Issued when console API was called. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-consoleAPICalled.
pub fn (mut p RuntimeDomain) console_api_called(msg Message) !Result {
	return p.tab.send('Runtime.consoleAPICalled', msg)!
}

// Issued when unhandled exception was revoked. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-exceptionRevoked.
pub fn (mut p RuntimeDomain) exception_revoked(msg Message) !Result {
	return p.tab.send('Runtime.exceptionRevoked', msg)!
}

// Issued when exception was thrown and unhandled. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-exceptionThrown.
pub fn (mut p RuntimeDomain) exception_thrown(msg Message) !Result {
	return p.tab.send('Runtime.exceptionThrown', msg)!
}

// Issued when new execution context is created. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-executionContextCreated.
pub fn (mut p RuntimeDomain) execution_context_created(msg Message) !Result {
	return p.tab.send('Runtime.executionContextCreated', msg)!
}

// Issued when execution context is destroyed. see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-executionContextDestroyed.
pub fn (mut p RuntimeDomain) execution_context_destroyed(msg Message) !Result {
	return p.tab.send('Runtime.executionContextDestroyed', msg)!
}

// Issued when all executionContexts were cleared in browser see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-executionContextsCleared.
pub fn (mut p RuntimeDomain) execution_contexts_cleared(msg Message) !Result {
	return p.tab.send('Runtime.executionContextsCleared', msg)!
}

// Issued when object should be inspected (for example, as a result of inspect() command line API
// call). see https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-inspectRequested.
pub fn (mut p RuntimeDomain) inspect_requested(msg Message) !Result {
	return p.tab.send('Runtime.inspectRequested', msg)!
}

// This domain is deprecated. see https://chromedevtools.github.io/devtools-protocol/tot/Schema.
pub struct SchemaDomain {
pub mut:
	tab &Tab = unsafe { nil }
}

// use Schema domains.
pub fn (mut tab Tab) use_schema(opts ConfigCDVDomain) !&SchemaDomain {
	if opts.enable && tab.is_inactive_deps('Schema') {
		tab.send('Schema.enable')!
		tab.deps << 'Schema'
	}

	return &SchemaDomain{tab}
}

// Returns supported domains. see https://chromedevtools.github.io/devtools-protocol/tot/Schema/#method-getDomains.
pub fn (mut p SchemaDomain) get_domains(msg Message) !Result {
	return p.tab.send('Schema.getDomains', msg)!
}
